<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>剑指offer 56-60</title>
    <link href="/2021/07/07/%E5%89%91%E6%8C%87offer56-60/"/>
    <url>/2021/07/07/%E5%89%91%E6%8C%87offer56-60/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-56-60"><a href="#剑指offer-56-60" class="headerlink" title="剑指offer    56~60"></a>剑指offer    56~60</h1><h2 id="五十六、删除链表中重复的结点"><a href="#五十六、删除链表中重复的结点" class="headerlink" title="五十六、删除链表中重复的结点"></a>五十六、<a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">删除链表中重复的结点</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* dummynode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* pre;<br>        ListNode* cur;<br>        dummynode-&gt;next = pHead;<br>        pre = dummynode;<br>        cur = pHead;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;<br>                <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;<br>                    cur = cur-&gt;next;<br>                &#125;<br>                pre-&gt;next = cur-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                pre = pre-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummynode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>使用<strong>双指针</strong></p><ol><li>定义两个指针, 分别为遍历的当前节点 cur 和 前节点 pre ;</li><li>每次步进后, 判断 cur 与其后节点(cur.next)是否重复, 如果重复, 则需要向后遍历 cur 直到不重复</li><li>分别将 cur 与 pre 向后步进, 持续进行步骤2的判断;</li><li>直至遍历到链表的尾部结束遍历;</li></ol><h2 id="五十七、二叉树的下一个结点"><a href="#五十七、二叉树的下一个结点" class="headerlink" title="五十七、二叉树的下一个结点"></a>五十七、<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的下一个结点</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示。</p><p><img src="/2021/07/07/%E5%89%91%E6%8C%87offer56-60/D03B8D5BB902D4516BB92CB216E58EC4"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>输入:{8,6,10,5,7,9,11},8</p><p>返回:9</p><p>解析:这个组装传入的子树根节点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根节点8的下一个节点就是9，应该返回{9,10,11}，后台只打印子树的下一个节点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来。</p><p><img src="/2021/07/07/%E5%89%91%E6%8C%87offer56-60/E647707AEF2A4AE2C40F0FCCB549B6A5"></p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为2段，第一段是整体的二叉树，第二段是给定二叉树节点的值，后台会将这2个参数组装为一个二叉树局部的子树传入到函数GetNext里面，用户得到的输入只有一个子树根节点</p><h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的子树根节点的下一个节点，后台会打印输出这个节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        TreeLinkNode* node = pNode;<br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;right;<br>            <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                node = node-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        node = pNode;<br>        <span class="hljs-keyword">while</span> (node-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; node == node-&gt;next-&gt;right) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>这完全可以用中序遍历之后，打印出数组，再找到下一个节点，但是太复杂。</p><p>本题每个节点都含有一个 next 指针，指向父节点，就比较好做了。</p><p>因为中序遍历为 <strong>左中右</strong> ，下一个节点只有两种情况：</p><ol><li>当这个节点有右节点时，下一个节点必为该右节点中的最底层左节点</li><li>若这个节点没有右节点，就返回其父节点，直到父节点不是作为右节点存在时停止，返回这个节点的父节点</li></ol><p>总的思路：</p><ol><li>节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</li><li>右孩子不存在，如果节点不是根节点，如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</li></ol><h2 id="五十八、对称的二叉树"><a href="#五十八、对称的二叉树" class="headerlink" title="五十八、对称的二叉树"></a>五十八、<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">对称的二叉树</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">bool</span> outside = <span class="hljs-built_in">cmp</span>(left-&gt;left, right-&gt;right);<br>        <span class="hljs-keyword">bool</span> inside = <span class="hljs-built_in">cmp</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">bool</span> isSame = outside &amp;&amp; inside;<br>        <span class="hljs-keyword">return</span> isSame;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">cmp</span>(pRoot-&gt;left, pRoot-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>算法流程</strong>：</p><p><code>isSymmetrical(root) </code>：</p><ul><li>特例处理： 若根节点 <code>root</code> 为空，则直接返回 true 。</li><li>返回值： 即 <code>cmp(root.left, root.right)</code> ;</li></ul><p><code>cmp(L, R)</code> ：</p><ul><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 不等于 节点 R 值： 此树不对称，因此返回 false ；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right 是否对称，即 <code>cmp(L.left, R.right)</code> ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 <code>cmp(L.right, R.left)</code> ；</li></ul></li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li></ul><h2 id="五十九、按之字形顺序打印二叉树"><a href="#五十九、按之字形顺序打印二叉树" class="headerlink" title="五十九、按之字形顺序打印二叉树"></a>五十九、<a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">按之字形顺序打印二叉树</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">8</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> cursize = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursize; i++) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) <span class="hljs-built_in">reverse</span>(res[i].<span class="hljs-built_in">begin</span>(), res[i].<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>利用队列对二叉树层序遍历</p><p>再对奇数行反转即可。</p><h2 id="六十、把二叉树打印成多行"><a href="#六十、把二叉树打印成多行" class="headerlink" title="六十、把二叉树打印成多行"></a>六十、<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把二叉树打印成多行</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">8</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> cursize = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursize; i++) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>就是层序遍历</p>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类相关</title>
    <link href="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="什么是虚函数？什么是纯虚函数"><a href="#什么是虚函数？什么是纯虚函数" class="headerlink" title="什么是虚函数？什么是纯虚函数"></a>什么是虚函数？什么是纯虚函数</h2><p>面试高频指数：★★★★★</p><p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">v_fun</span>(); <span class="hljs-comment">// B::v_fun()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>纯虚函数</strong>：</p><ul><li>纯虚函数在类中声明时，加上 <code>=0</code>；</li><li><code>含有纯虚函数的类称为抽象类</code>（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li></ul><p>说明：</p><ul><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li><li>可以声明抽象类指针，可以声明抽象类的引用；</li><li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li></ul><h2 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h2><p>面试高频指数：★★★☆☆</p><ul><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（<strong>含有纯虚函数的类称为抽象基类</strong>）</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;</li><li><code>虚函数必须实现</code>，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li><code>析构函数最好定义为虚函数</code>，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li></ul><h2 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h2><p>面试高频指数：★★★★★</p><p><strong>实现机制</strong>：虚函数通过<code>虚函数表</code>来实现。<code>虚函数的地址保存在虚函数表中</code>，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p><p><strong>虚函数表相关知识点</strong>：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：<code>编译阶段</code>，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul><p>注：<code>虚函数表和类绑定</code>，<code>虚表指针和对象绑定</code>。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p><p><strong>实例</strong>：</p><p>无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681846-tyqCUP-image.png"></p><p>基类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679161-OtbPhj-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681900-RShiIP-image.png"></p><p>主函数中基类的指针 <code>p</code> 指向了派生类的对象，当调用函数 <code>B_fun1()</code> 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p><h2 id="单继承和多继承的虚函数表结构"><a href="#单继承和多继承的虚函数表结构" class="headerlink" title="单继承和多继承的虚函数表结构"></a>单继承和多继承的虚函数表结构</h2><p>面试高频指数：★★★★☆</p><p><strong>编译器处理虚函数表：</strong></p><ul><li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li><li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li><li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li><li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li></ul><ol><li><p>单继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681846-tyqCUP-image.png"></p><p>基类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679161-OtbPhj-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681900-RShiIP-image.png"></p></li><li><p>单继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::D_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682073-uNdCTl-image.png"></p></li><li><p>多继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B1_fun1</span>(); <span class="hljs-comment">// Base1::B1_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679879-DBSJce-image.png"></p><p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682139-oQZazN-image.png"></p></li><li><p>多继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base2 *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base3 *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p1-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p2-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p3-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681289-WjDonI-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682194-qhLdri-image.png"></p></li></ol><h2 id="如何禁止构造函数的使用？"><a href="#如何禁止构造函数的使用？" class="headerlink" title="如何禁止构造函数的使用？"></a>如何禁止构造函数的使用？</h2><p>面试高频指数：★★☆☆☆</p><p>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1;    <br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>)</span></span>; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：上述代码中，使用了已经删除 <code>delete</code> 的构造函数，程序出现错误。</p><p>用来禁止拷贝/复制构造函数。</p><h2 id="什么是类的默认构造函数？"><a href="#什么是类的默认构造函数？" class="headerlink" title="什么是类的默认构造函数？"></a>什么是类的默认构造函数？</h2><p>面试高频指数：★★★☆☆</p><p>默认构造函数：<code>未提供任何实参</code>，来控制默认初始化过程的构造函数称为默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123; <span class="hljs-comment">// 类的默认构造函数</span><br>        var = <span class="hljs-number">10</span>;<br>        c = <span class="hljs-string">&#x27;q&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">char</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex;<br>    cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">q</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：上述程序中定义变量 <code>ex</code> 时，未提供任何实参，程序运行时会调用默认的构造函数。</p><h2 id="构造函数、析构函数是否需要定义成虚函数？为什么？"><a href="#构造函数、析构函数是否需要定义成虚函数？为什么？" class="headerlink" title="构造函数、析构函数是否需要定义成虚函数？为什么？"></a>构造函数、析构函数是否需要定义成虚函数？为什么？</h2><p>面试高频指数：★★★★☆</p><p><strong>构造函数一般不定义为虚函数</strong>，原因：</p><ul><li>从存储空间的角度考虑：构造函数是在<code>实例化对象的时候进行调用</code>，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，<code>虚函数的指针只有在创建了对象才有</code>），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ul><p><strong>析构函数一般定义成虚函数</strong>，原因：</p><ul><li>析构函数定义成虚函数是<code>为了防止内存泄漏</code>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li></ul><h2 id="如何避免拷贝？"><a href="#如何避免拷贝？" class="headerlink" title="如何避免拷贝？"></a>如何避免拷贝？</h2><p>面试高频指数：★★☆☆☆</p><p>最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p><p>解决方法：声明一个基类，具体做法如下。</p><ul><li><p>定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private</p></li><li><p>派生类以私有 private 的方式继承基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncopyable</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-keyword">const</span> Uncopyable &amp;);            <span class="hljs-comment">// 拷贝构造函数</span><br>    Uncopyable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Uncopyable &amp;); <span class="hljs-comment">// 赋值构造函数</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">private</span> Uncopyable <span class="hljs-comment">// 注意继承方式</span><br>&#123; <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>简单解释：</p><ul><li>能够保证，在派生类 A 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。</li></ul><h2 id="如何减少构造函数开销？"><a href="#如何减少构造函数开销？" class="headerlink" title="如何减少构造函数开销？"></a>如何减少构造函数开销？</h2><p>面试高频指数：★★☆☆☆</p><p>在构造函数中<strong>使用类初始化列表</strong>，会减少调用默认的构造函数产生的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成员初始化列表：在类构造函数中，不在函数体内对变量赋值，而在参数列表后，跟一个冒号和初始化列表。</p><p>对于<code>非内置类型</code>，少了一次调用默认构造函数的过程。</p><h2 id="为什么用成员初始化列表会快一些？"><a href="#为什么用成员初始化列表会快一些？" class="headerlink" title="为什么用成员初始化列表会快一些？"></a>为什么用成员初始化列表会快一些？</h2><p>面试高频指数：★★★☆☆</p><p>说明：数据类型可分为<code>内置类型</code>和<code>用户自定义类型</code>（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p><p>原因：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前<strong>首先调用默认的构造函数</strong>为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，<strong>使用列表初始化会减少调用默认的构造函数的过程</strong>，效率高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test2</span>() <span class="hljs-comment">// 函数体中赋值的方式</span><br>    &#123;<br>        ex = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test1 ex1;<br>    cout &lt;&lt; endl;<br>    Test2 ex2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">A(int 2)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。</p><h2 id="实例化一个对象需要哪几个阶段"><a href="#实例化一个对象需要哪几个阶段" class="headerlink" title="实例化一个对象需要哪几个阶段"></a>实例化一个对象需要哪几个阶段</h2><p>面试高频指数：★★★☆☆</p><ol><li><p>分配空间</p><p>创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</p></li><li><p>初始化</p><p>首先明确一点：<code>初始化不同于赋值</code>。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</p></li><li><p>赋值</p><p>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</p></li></ol><p>注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li><li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li></ul><h2 id="多重继承时会出现什么状况？如何解决？"><a href="#多重继承时会出现什么状况？如何解决？" class="headerlink" title="多重继承时会出现什么状况？如何解决？"></a>多重继承时会出现什么状况？如何解决？</h2><p>面试高频指数：★★★★☆</p><p>多重继承（多继承）：是指从多个直接基类中产生派生类。</p><p>多重继承容易出现的问题：<code>命名冲突</code>和<code>数据冗余</code>问题。</p><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <span class="hljs-comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序的继承关系如下：（菱形继承）</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681677-Jgekej-image.png"></p><p><strong>上述代码中存的问题：</strong></p><p>对于派生类 Derive 上述代码中存在<code>直接继承关系</code>和<code>间接继承关系</code>。</p><ul><li>直接继承：Base2 、Base3</li><li>间接继承：Base1</li></ul><p>对于派生类中继承的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了<code>命名冲突</code>。</p><p><strong>解决方法 1</strong>： 声明出现冲突的成员变量来源于哪个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="hljs-comment">// 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方法 2</strong>： 虚继承</p><p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p><p>实现方式：在继承方式前面加上 virtual 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类，即虚基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类之间的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681729-IhAKvb-image.png"></p><h2 id="空类占多少字节？C-编译器会给一个空类自动生成哪些函数？"><a href="#空类占多少字节？C-编译器会给一个空类自动生成哪些函数？" class="headerlink" title="空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？"></a>空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</h2><p>面试高频指数：★★★☆☆</p><p><strong>空类声明时编译器不会生成任何成员函数：</strong></p><p>对于空类，<strong>声明</strong>编译器不会生成任何的成员函数，只会生成 <strong>1</strong> 个字节的占位符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空类定义时编译器会生成 6 个成员函数</strong>：</p><p>当空类 A <strong>定义对象</strong>时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：<code>缺省的构造函数</code>、<code>拷贝构造函数</code>、<code>析构函数</code>、<code>赋值运算符</code>、<code>两个取址运算符</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class A</span><br><span class="hljs-comment">&#123;&#125;; 该空类的等价写法如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-keyword">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">delete</span> p;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么拷贝构造函数必须为引用？"><a href="#为什么拷贝构造函数必须为引用？" class="headerlink" title="为什么拷贝构造函数必须为引用？"></a>为什么拷贝构造函数必须为引用？</h2><p>面试高频指数：★★☆☆☆</p><p>原因：避免拷贝构造函数<code>无限制的递归</code>，最终导致<code>栈溢出</code>。</p><p>举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">val</span>(tmp) <span class="hljs-comment">// 带参数构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 拷贝构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>    &#125;<br><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 赋值函数（赋值运算符重载）</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    A ex3 = ex1;<br>    ex2 = ex1;<br>    ex2.<span class="hljs-built_in">fun</span>(ex1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">A &amp;operator=(const A &amp;tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>说明 1：ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？<br>对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值函数；但是 ex3 还没有实例化，因此调用的是拷贝构造函数，构造出 ex3，而不是赋值函数，这里涉及到构造函数的<code>隐式调用</code>。</li><li>说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 = ex1;会出现什么问题？<br>构造 ex3，实质上是 ex3.A(ex1);，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp)的形参，在参数传递时相当于 A tmp = ex1，因为 tmp 没有被初始化，所以在 A tmp = ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1) ，必然又会有 ex1 作为函数 A(const A tmp); 的形参，在参数传递时相当于即 A tmp = ex1，那么又会触发拷贝构造函数，就这下永远的递归下去。</li><li>说明 3：为什么 ex2.fun(ex1); 会调用拷贝构造函数？<br>ex1 作为参数传递给 fun 函数， 即 A tmp = ex1;，这个过程会调用拷贝构造函数进行初始化。</li></ul><h2 id="C-类对象的初始化顺序"><a href="#C-类对象的初始化顺序" class="headerlink" title="C++ 类对象的初始化顺序"></a>C++ 类对象的初始化顺序</h2><p>面试高频指数：★★★☆☆</p><p>构造函数调用顺序：</p><ul><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；</li><li>按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；</li><li>执行派生类自身的构造函数。</li></ul><p>综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数</p><p>注：</p><ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关；</li><li>成员变量的初始化顺序与声明顺序有关；</li><li>析构顺序和构造顺序相反。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> :</span> <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B <span class="hljs-comment">// 派生列表</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    B ex1;<br>    A ex2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">B()   --&gt; B ex1</span><br><span class="hljs-comment">A()   --&gt; A ex2</span><br><span class="hljs-comment">Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序运行结果分析：</p><ul><li>首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；</li><li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li><li>最后调用派生类的构造函数；</li><li>接下来调用析构函数，和构造函数调用的顺序相反。</li></ul><h2 id="如何禁止一个类被实例化？"><a href="#如何禁止一个类被实例化？" class="headerlink" title="如何禁止一个类被实例化？"></a>如何禁止一个类被实例化？</h2><p>面试高频指数：★★☆☆☆</p><p>方法一：</p><ul><li>在类中定义一个纯虚函数，使该类成为<code>抽象基类</code>，因为不能创建抽象基类的实例化对象；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1; <span class="hljs-comment">// error: cannot declare variable &#x27;ex1&#x27; to be of abstract type &#x27;A&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：</p><ul><li>将类的构造函数声明为私有 <code>private</code></li></ul><h2 id="友元函数的作用及使用场景"><a href="#友元函数的作用及使用场景" class="headerlink" title="友元函数的作用及使用场景"></a>友元函数的作用及使用场景</h2><p>面试高频指数：★★☆☆☆</p><p>作用：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p><p>使用场景：</p><ol><li><p>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp); <span class="hljs-comment">// 声明为类的友元函数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp)<br>&#123;<br>    _cout &lt;&lt; tmp.var;<br>    <span class="hljs-keyword">return</span> _cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; ex &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>友元类：类之间共享数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">var</span>(<span class="hljs-number">10</span>)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl; <span class="hljs-comment">// 访问类 A 中的私有成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    A ex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B ex;<br>    ex.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun():10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="静态绑定和动态绑定是怎么实现的？"><a href="#静态绑定和动态绑定是怎么实现的？" class="headerlink" title="静态绑定和动态绑定是怎么实现的？"></a>静态绑定和动态绑定是怎么实现的？</h2><p>面试高频指数：★★★☆☆</p><p>静态类型和动态类型：</p><ul><li>静态类型：<code>变量在声明时的类型</code>，是在编译阶段确定的。静态类型不能更改。</li><li>动态类型：<code>目前所指对象的类型</code>，是在运行阶段确定的。动态类型可以更改。</li></ul><p>静态绑定和动态绑定：</p><ul><li>静态绑定是指程序在 <code>编译阶段</code> 确定对象的类型（静态类型）。</li><li>动态绑定是指程序在 <code>运行阶段</code> 确定对象的类型（动态类型）。</li></ul><p>静态绑定和动态绑定的区别：</p><ul><li>发生的时期不同：如上。</li><li><strong>对象的静态类型不能更改，动态类型可以更改。</strong></li></ul><p>注：对于类的成员函数，只有<strong>虚函数是动态绑定</strong>，其他都是静态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>     &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span>; <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(); <span class="hljs-comment">// p 的静态类型是 Base*，动态类型是 Derive*</span><br>    p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun 是虚函数，运行阶段进行动态绑定</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Derive::fun()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>面试高频指数：★★★★★</p><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。</p><ul><li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</li><li>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</li></ul><p>当类的成员变量中<strong>有指针变量时，最好使用深拷贝</strong>。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。</p><p><strong>浅拷贝实例</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p><p><strong>深拷贝实例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;tmp) <span class="hljs-comment">// 定义拷贝构造函数</span><br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*tmp.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">Test(const Test &amp;tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="编译时多态和运行时多态的区别"><a href="#编译时多态和运行时多态的区别" class="headerlink" title="编译时多态和运行时多态的区别"></a>编译时多态和运行时多态的区别</h2><p>面试高频指数：★★★☆☆</p><p>编译时多态：在程序<code>编译过程中</code>出现，发生在模板和函数<strong>重载</strong>中（泛型编程）。</p><p>运行时多态：在程序<code>运行过程中</code>出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的<strong>虚函数</strong>。</p><p>编译时多态和运行时多态的区别：</p><ul><li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li><li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。</li></ul><h2 id="实现一个类成员函数，要求不允许修改类的成员变量？"><a href="#实现一个类成员函数，要求不允许修改类的成员变量？" class="headerlink" title="实现一个类成员函数，要求不允许修改类的成员变量？"></a>实现一个类成员函数，要求不允许修改类的成员变量？</h2><p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 <code>const 关键字</code>来修饰该函数即可。</p><p>考察 const 关键字修饰成员函数的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span><br><span class="hljs-function">    </span>&#123;<br>        var1 = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何让类不能被继承？"><a href="#如何让类不能被继承？" class="headerlink" title="如何让类不能被继承？"></a>如何让类不能被继承？</h2><p>面试高频指数：★★★☆☆</p><p>解决方法一：借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span>:</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法二：借助友元、虚继承和私有构造函数来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br>    <span class="hljs-keyword">friend</span> T;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&lt;B&gt;&#123;   <span class="hljs-comment">//一定注意 必须是虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>()&#123;&#125;     <span class="hljs-comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    B b;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：在上述代码中 B 类是不能被继承的类。</p><p>具体原因：</p><ul><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的<code>友元</code>，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用<code>虚继承</code>的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ul><p>注意：在继承体系中，<code>友元关系不能被继承</code>，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p>]]></content>
    
    
    <categories>
      
      <category>面试突击</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译内存相关</title>
    <link href="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h2><p>面试高频指数：★★★★☆</p><p>编译过程分为四个过程：编译预处理，编译，汇编，链接。</p><ul><li>编译预处理：处理以 # 开头的指令；</li><li>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</li><li>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</li><li>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</li></ul><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/1612676946-HVvkdR-image.png"></p><p>链接分为两种：</p><ul><li>静态链接：代码从其所在的<strong>静态链接库</strong>中<code>拷贝</code>到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到<strong>动态链接库</strong>或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被<code>映射</code>到运行时相应进行的虚拟地址的空间。</li></ul><p>二者的优缺点：</p><ul><li>静态链接：<code>浪费空间</code>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：<code>节省内存、更新方便</code>，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>面试高频指数：★★★★★</p><p>C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p><ul><li>栈：存放函数的<code>局部变量、函数参数、返回地址</code>等，由<code>编译器自动分配和释放</code>。</li><li>堆：<code>动态申请的内存空间</code>，就是由 malloc 或 new 分配的内存块，由<code>程序员控制它的分配和释放</code>，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>全局区/静态存储区（.bss 段和 .data 段）：存放<code>全局变量和静态变量</code>，程序运行结束<code>操作系统自动释放</code>，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li><li>常量存储区（.data 段）：存放的是<code>常量</code>，不允许修改，程序运行结束自动释放。</li><li>代码区（.text 段）：存放<code>代码</code>，不允许修改，但可以执行。<code>编译后的二进制文件</code>存放在这里。</li></ul><p>说明：</p><ul><li><p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/7618933_1.jpg"></p></li></ul><p>程序实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> g_var = <span class="hljs-number">0</span>; <span class="hljs-comment">// g_var 在全局区（.data 段）已初始化</span><br><span class="hljs-keyword">char</span> *gp_var;  <span class="hljs-comment">// gp_var 在全局区（.bss 段）未初始化</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var;                    <span class="hljs-comment">// var 在栈区</span><br>    <span class="hljs-keyword">char</span> *p_var;                <span class="hljs-comment">// p_var 在栈区</span><br>    <span class="hljs-keyword">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;         <span class="hljs-comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">char</span> *p_var1 = <span class="hljs-string">&quot;123456&quot;</span>;    <span class="hljs-comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var = <span class="hljs-number">0</span>;       <span class="hljs-comment">// s_var 为静态变量，存在静态存储区（.data 段）</span><br>    p_var = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配得来的 10 个字节的区域在堆区</span><br>    <span class="hljs-built_in">free</span>(p_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h2><p>面试高频指数：★★★★★</p><ul><li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于<code>链表</code>（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li><li><code>栈在内存中是连续的一块空间（向低地址扩展）</code>最大容量是系统预定好的，<code>堆在内存中的空间（向高地址扩展）是不连续的</code>。</li><li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li><li>存放的内容：<code>栈中存放的是局部变量，函数的参数</code>；<code>堆中存放的内容由程序员控制</code>。</li></ul><h2 id="变量的区别"><a href="#变量的区别" class="headerlink" title="变量的区别"></a>变量的区别</h2><p>面试高频指数：★★★☆☆</p><p>全局变量、局部变量、静态全局变量、静态局部变量的区别</p><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：<code>全局作用域</code>，<code>局部作用域</code>，<code>语句作用域</code>，<code>类作用域</code>，<code>命名空间作用域</code>和<code>文件作用域</code>。</p><p>从作用域看：</p><ul><li><p><code>全局变量</code>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p></li><li><p><code>静态全局变量</code>：具有<strong>文件作用域</strong>。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样<strong>即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</strong>。</p></li><li><p><code>局部变量</code>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p></li><li><p><code>静态局部变量</code>：具有局部作用域。它<strong>只被初始化一次</strong>，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而<strong>静态局部变量只对定义自己的函数体始终可见</strong>。</p></li></ul><p>从分配内存空间看：</p><ul><li>静态存储区：全局变量，静态局部变量，静态全局变量。</li><li>栈：局部变量。</li></ul><p>说明：</p><ul><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（<strong>静态变量会自动初始化</strong>），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li><li>静态变量和全局变量的区别：静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见。</li></ul><h2 id="全局变量定义在头文件中有什么问题？"><a href="#全局变量定义在头文件中有什么问题？" class="headerlink" title="全局变量定义在头文件中有什么问题？"></a>全局变量定义在头文件中有什么问题？</h2><p>面试高频指数：★☆☆☆☆</p><p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此<strong>不能</strong>在头文件中定义全局变量。</p><h2 id="对象创建限制在堆或栈"><a href="#对象创建限制在堆或栈" class="headerlink" title="对象创建限制在堆或栈"></a>对象创建限制在堆或栈</h2><p>面试高频指数：★★★☆☆</p><p><strong>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</strong></p><p>说明：C++ 中的类的对象的建立分为两种：<code>静态建立</code>、<code>动态建立</code>。</p><ul><li>静态建立：由编译器为对象在<code>栈空间上分配内存</code>，直接<code>调用类的构造函数创建对象</code>。例如：<code>A a;</code></li><li>动态建立：使用 <code>new 关键字在堆空间上创建对象</code>，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li></ul><p>限制对象<strong>只能建立在堆上</strong>：</p><ul><li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p></li><li><p>解决方法 1：</p><ul><li><p><strong>将析构函数设置为私有</strong>。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即<code>编译器会检查析构函数的访问性</code>。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该方法存在的问题：</p></li><li><p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此<code>类内必须定义一个 destory() 函数</code>，用来释放 new 创建的对象（用来替代析构函数）。</p></li><li><p><code>无法解决继承问题</code>，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p></li></ul></li><li><p>解决方法 2：</p><ul><li><p>构造函数设置为 protected，并提供一个 <code>public 的静态函数来完成构造</code>，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A *<span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>限制对象<strong>只能建立在栈上</strong>：</p><ul><li><p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>面试高频指数：★★☆☆☆</p><p><strong>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</strong></p><p>内存对齐：编译器将程序中的每个“数据单元”安排在<code>字的整数倍的地址指向的内存</code>之中</p><p>内存对齐的原则：</p><ol><li>结构体变量的<code>首地址</code>能够被其<code>最宽基本类型成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>所<code>整除</code>；</li><li>结构体<code>每个成员</code>相对于结构体<code>首地址的偏移量</code> （offset） 都是该<code>成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>的<code>整数倍</code>，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的<code>总大小</code>为<code>结构体最宽基本类型成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>的<code>整数倍</code>，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">short</span> var; <span class="hljs-comment">// 2 字节</span><br>    <span class="hljs-keyword">int</span> var1;  <span class="hljs-comment">// 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8</span><br>    <span class="hljs-keyword">long</span> var2; <span class="hljs-comment">// 12 字节 8 + 4 (long) = 12</span><br>    <span class="hljs-keyword">char</span> var3; <span class="hljs-comment">// 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16</span><br>    string s;  <span class="hljs-comment">// 48 字节 16 + 32 (string) = 48</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">short</span> var;<br>    <span class="hljs-keyword">int</span> var1;<br>    <span class="hljs-keyword">long</span> var2;<br>    <span class="hljs-keyword">char</span> var3;<br>    string s;<br>    A ex1;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var) &lt;&lt; endl;  <span class="hljs-comment">// 2 short</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var1) &lt;&lt; endl; <span class="hljs-comment">// 4 int</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var2) &lt;&lt; endl; <span class="hljs-comment">// 4 long</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var3) &lt;&lt; endl; <span class="hljs-comment">// 1 char</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s) &lt;&lt; endl;    <span class="hljs-comment">// 32 string</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl;  <span class="hljs-comment">// 48 struct</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p><ol><li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p>内存对齐的优点：</p><ol><li><code>便于在不同的平台之间进行移植</code>，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li><code>提高内存的访问效率</code>，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><p>面试高频指数：★★☆☆☆</p><p><strong>类大小的计算</strong></p><p>说明：类的大小是指<code>类的实例化对象的大小</code>，用 sizeof 对类型名操作时，结果是该类型的对象的大小。</p><p>计算原则：</p><ul><li><code>遵循结构体的对齐原则</code>。</li><li>与<code>普通成员变量有关</code>，与成员函数和静态成员无关。即<code>普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响</code>。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li>虚函数对类的大小有影响，是因为<code>虚函数表指针</code>的影响。</li><li>虚继承对类的大小有影响，是因为<code>虚基表指针</code>带来的影响。</li><li>空类的大小是一个特殊情况，<code>空类的大小为 1</code>，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li></ul><p>实例：</p><ol><li><p>简单情况和空类情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                    <span class="hljs-comment">// 不影响类的大小</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    B ex2;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 12 字节</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex2) &lt;&lt; endl; <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                      <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::f&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::g&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::h&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    A *p;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl;   <span class="hljs-comment">// 8 字节 注意：指针所占的空间和指针指向的数据类型无关</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 24 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针，指针8字节。</p><p>当到char var1，类已经有12字节了，但是接下来虚函数指针在64位下，是8字节，需要是8字节的整数倍，因此在char var1处添加4个字节来保障。</p></li></ol><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>面试高频指数：★★★★☆</p><p>内存泄漏：由于疏忽或错误导致的程序<code>未能释放已经不再使用的内存</code>。</p><p>进一步解释：</p><ul><li><p>并非指内存从物理上消失，而是指程序在运行过程中，<code>由于疏忽或错误而失去了对该内存的控制</code>，从而造成了内存的浪费。</p></li><li><p>常指<code>堆内存泄漏</code>，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p></li><li><p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</p></li><li><p>指针重新赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">char</span> *p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>p = np;<br></code></pre></td></tr></table></figure><p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p></li></ul><h2 id="怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>怎么防止内存泄漏？内存泄漏检测工具的原理？</h2><p>面试高频指数：★★★☆☆</p><p><strong>防止内存泄漏的方法：</strong></p><ol><li><p>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造函数中分配内存空间</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>    &#125;;<br>    ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 析构函数中释放内存空间</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>            p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况，请看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = ex; <br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单解释：对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间，但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况，看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"> &#123;</span><br> <span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">char</span> *p;<br>     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br>     <span class="hljs-keyword">int</span> *p_count; <span class="hljs-comment">// 计数变量</span><br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 在构造函数中申请内存</span><br>     &#123;<br>         p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>         p_size = n;<br>         p_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>         *p_count = <span class="hljs-number">1</span>;<br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>     &#125;;<br>     <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;temp)<br>     &#123;<br>         p = temp.p;<br>         p_size = temp.p_size;<br>         p_count = temp.p_count;<br>         (*p_count)++; <span class="hljs-comment">// 复制时，计数变量 +1</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>     &#125;<br>     ~<span class="hljs-built_in">A</span>()<br>     &#123;<br>         (*p_count)--; <span class="hljs-comment">// 析构时，计数变量 -1</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl; <br><br>         <span class="hljs-keyword">if</span> (*p_count == <span class="hljs-number">0</span>) <span class="hljs-comment">// 只有当计数变量为 0 的时候才会释放该块内存空间</span><br>         &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;buf is deleted&quot;</span> &lt;&lt; endl;<br>             <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <br>             &#123;<br>                 <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>                 p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>                 <span class="hljs-keyword">if</span> (p_count != <span class="hljs-literal">NULL</span>)<br>                 &#123;<br>                     <span class="hljs-keyword">delete</span> p_count;<br>                     p_count = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>             &#125;<br>         &#125;<br>     &#125;;<br>     <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-keyword">return</span> p;<br>     &#125;;<br> &#125;;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>     <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>     <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>     cout &lt;&lt; p &lt;&lt; endl;<br><br>     A ex1 = ex; <span class="hljs-comment">// 此时计数变量会 +1</span><br>     cout &lt;&lt; <span class="hljs-string">&quot;ex1.p = &quot;</span> &lt;&lt; ex1.<span class="hljs-built_in">GetPointer</span>() &lt;&lt; endl;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">fun</span>();<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">count is : <span class="hljs-number">1</span><br>Test<br>count is : <span class="hljs-number">2</span><br>ex1.p = Test<br>count is : <span class="hljs-number">1</span><br>count is : <span class="hljs-number">0</span><br>buf is deleted<br></code></pre></td></tr></table></figure><p>解释下：程序运行结果的倒数 2、3 行是调用两次析构函数时进行的操作，在第二次调用析构函数时，进行内存空间的释放，从而会有倒数第 1 行的输出结果。</p></li><li><p>智能指针</p><p>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</p></li></ol><p><strong>内存泄漏检测工具的实现原理：</strong></p><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/1612687346-kyLXKn-image.png"></p><p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li>Massif：检查程序中堆栈使用中出现的问题。</li><li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li></ul><p>检测原理：</p><ul><li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li><li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li></ul><h2 id="智能指针有哪几种？智能指针的实现原理？"><a href="#智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="智能指针有哪几种？智能指针的实现原理？"></a>智能指针有哪几种？智能指针的实现原理？</h2><p>面试高频指数：★★★★★</p><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <memory> 头文件中。</memory></p><p>C++11 中智能指针包括以下三种：</p><ul><li>共享指针（shared_ptr）：<code>资源可以被多个指针共享</code>，使用<code>计数机制</code>表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li><li>独占指针（unique_ptr）：<code>独享所有权</code>的智能指针，资源只能被一个指针占有，<code>该指针不能拷贝构造和赋值</code>。但可以进行移动构造和移动赋值构造（<code>调用 move() 函数</code>），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</li><li>弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够<code>解决由shared_ptr带来的循环引用问题</code>。</li></ul><p>智能指针的实现原理： 计数原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span> : <br>T *_ptr;<br><span class="hljs-keyword">size_t</span> *_count;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) : _ptr(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (_ptr)<br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">SmartPtr</span>()<br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">SmartPtr</span>(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 拷贝构造：计数 +1</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>&#125;<br>&#125;<br><br>SmartPtr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 赋值运算符重载 </span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) <span class="hljs-comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span><br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++; <span class="hljs-comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>T &amp;<span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>&#125;<br><br>T *<span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;count;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？"><a href="#一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？" class="headerlink" title="一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？"></a>一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h2><p>面试高频指数：★★☆☆☆</p><p>借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A 作为一个类 </span><br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::unique_ptr&lt;A&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br></code></pre></td></tr></table></figure><h2 id="使用智能指针会出现什么问题？怎么解决？"><a href="#使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="使用智能指针会出现什么问题？怎么解决？"></a>使用智能指针会出现什么问题？怎么解决？</h2><p>面试高频指数：★★★★★</p><p>智能指针可能出现的问题：<code>循环引用</code></p><p>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环引用的解决方法： <code>weak_ptr</code></p><p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p><ul><li>weak_ptr 对被 shared_ptr 管理的对象存在 <code>非拥有性（弱）引用</code>，在访问所引用的对象前必须先转化为 shared_ptr；</li><li>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li><li>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//shared_ptr&lt;Child&gt; ChildPtr;</span><br>    weak_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//new shared_ptr</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">lock</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试突击</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 51-55</title>
    <link href="/2021/06/25/%E5%89%91%E6%8C%87offer51-55/"/>
    <url>/2021/06/25/%E5%89%91%E6%8C%87offer51-55/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-51-55"><a href="#剑指offer-51-55" class="headerlink" title="剑指offer    51~55"></a>剑指offer    51~55</h1><h2 id="五十一、构建乘积数组"><a href="#五十一、构建乘积数组" class="headerlink" title="五十一、构建乘积数组"></a>五十一、<a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&&tqId=11204&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">构建乘积数组</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。<strong>不能使用除法</strong>。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p><p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">120</span>,<span class="hljs-number">60</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(A.size())</span></span>;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] * A[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= A[i + <span class="hljs-number">1</span>];<br>            res[i] *= tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>本题的难点在于 <strong>不能使用除法</strong> ，即需要 <strong>只用乘法</strong> 生成数组 B 。根据题目对 B[i] 的定义，可列表格，如下图所示。</p><p>根据表格的主对角线（全为 1 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p><p><img src="/2021/06/25/%E5%89%91%E6%8C%87offer51-55/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png"></p><p><strong>算法流程</strong>：</p><ol><li>初始化：数组 B ，其中 B[0] = 1 ；辅助变量 tmp = 1 ；</li><li>计算 B[i] 的 <strong>下三角</strong> 各元素的乘积，直接乘入B[i] ；</li><li>计算 B[i] 的 <strong>上三角</strong> 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li><li>返回 B 。</li></ol><h2 id="☆☆☆五十二、正则表达式匹配（困难）"><a href="#☆☆☆五十二、正则表达式匹配（困难）" class="headerlink" title="☆☆☆五十二、正则表达式匹配（困难）"></a>☆☆☆五十二、<a href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">正则表达式匹配（困难）</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来匹配包括’ . ‘和’ * ‘的正则表达式。模式中的字符’ . ‘表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * ac * a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-comment">&quot;aaa&quot;</span>,<span class="hljs-comment">&quot;a*a&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span> n = p.<span class="hljs-built_in">size</span>();<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j = j + <span class="hljs-number">2</span>) &#123;<br>dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>dp[i][j] = p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> ?<br>dp[i][j - <span class="hljs-number">2</span>] || dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; (p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>]) :<br>dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>动态规划解析：</strong></p><ul><li><p><strong>状态定义</strong>： 设动态规划矩阵 <code>dp</code> ， <code>dp[i][j]</code> 代表字符串 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符能否匹配。</p></li><li><p><strong>转移方程</strong>： 需要注意，由于 <code>dp[0][0]</code> 代表的是空字符的状态， 因此 <code>dp[i][j]</code> 对应的添加字符是 <code>s[i - 1]</code> 和 <code>p[j - 1]</code> 。</p><ul><li><p>当 <code>p[j - 1] = &#39;*&#39;</code> 时， <code>dp[i][j]</code> 在当以下任一情况为 $true$ 时等于 $true$ ：</p><ol><li><p><code>dp[i][j - 2]</code>： 即将字符组合 <code>p[j - 2] *</code> 看作出现 0 次时，能否匹配；</p></li><li><p><code>dp[i - 1][j]</code> 且 <code>s[i - 1] = p[j - 2]</code>: 即让字符 <code>p[j - 2]</code> 多出现 1 次时，能否匹配；</p></li><li><p><code>dp[i - 1][j]</code> 且 <code>p[j - 2] = &#39;.&#39;</code>: 即让字符 <code>&#39;.&#39;</code> 多出现 1 次时，能否匹配；</p></li></ol></li><li><p>当 <code>p[j - 1] != &#39;*&#39;</code> 时， <code>dp[i][j]</code> 在当以下任一情况为 $true$ 时等于 $true$ ：</p><ol><li><p><code>dp[i - 1][j - 1]</code> 且 <code>s[i - 1] = p[j - 1]</code>： 即让字符 <code>p[j - 1]</code> 多出现一次时，能否匹配；</p></li><li><p><code>dp[i - 1][j - 1]</code> 且 <code>p[j - 1] = &#39;.&#39;</code>： 即将字符 . 看作字符 <code>s[i - 1]</code> 时，能否匹配；</p></li></ol></li></ul></li><li><p><strong>初始化</strong>： 需要先初始化 <code>dp</code> 矩阵首行，以避免状态转移时索引越界。</p><ul><li><p><code>dp[0][0] = true</code>： 代表两个空字符串能够匹配。</p></li><li><p><code>dp[0][j] = dp[0][j - 2]</code> 且 <code>p[j - 1] = &#39;*&#39;</code>： 首行 <code>s</code> 为空字符串，因此当 <code>p</code> 的偶数位为 <code>*</code> 时才能够匹配（即让 p 的奇数位出现 0 次，保持 <code>p</code> 是空字符串）。因此，循环遍历字符串 <code>p</code> ，步长为 2（即只看偶数位）。</p></li></ul></li><li><p><strong>返回值</strong>： <code>dp</code> 矩阵右下角字符，代表字符串 <code>s</code> 和 <code>p</code> 能否匹配。</p></li></ul><p>参考：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/">剑指 Offer 19. 正则表达式匹配（动态规划，清晰图解） - 正则表达式匹配 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="五十三、表示数值的字符串"><a href="#五十三、表示数值的字符串" class="headerlink" title="五十三、表示数值的字符串"></a>五十三、<a href="https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">表示数值的字符串</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;123.45e+6&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;1.2.3&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt;<span class="hljs-built_in">states</span>(<span class="hljs-number">9</span>);<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">1</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>));<br>states[<span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">4</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">5</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">6</span>));<br>states[<span class="hljs-number">5</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">6</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">7</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">7</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">8</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> t;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str) &#123;<br><span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)t = <span class="hljs-string">&#x27;d&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>)t = <span class="hljs-string">&#x27;s&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span>)t = <span class="hljs-string">&#x27;e&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span> || c == <span class="hljs-string">&#x27; &#x27;</span>)t = c;<br><span class="hljs-keyword">else</span> t = <span class="hljs-string">&#x27;?&#x27;</span>;<br><span class="hljs-keyword">if</span> (!states[p].<span class="hljs-built_in">count</span>(t))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>p = states[p][t];<br>&#125;<br><span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>有限状态自动机</strong></p><p><strong>状态定义：</strong></p><p>按照字符串从左到右的顺序，定义以下 9 种状态。</p><ol><li><p>开始的空格</p></li><li><p>幂符号前的正负号</p></li><li><p>小数点前的数字</p></li><li><p>小数点、小数点后的数字</p></li><li><p>当小数点前为空格时，小数点、小数点后的数字</p></li><li><p>幂符号</p></li><li><p>幂符号后的正负号</p></li><li><p>幂符号后的数字</p></li><li><p>结尾的空格</p></li></ol><p><strong>结束状态：</strong></p><p>合法的结束状态有 2, 3, 7, 8 。</p><p><img src="/2021/06/25/%E5%89%91%E6%8C%87offer51-55/6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1.png"></p><p><strong>算法流程：</strong></p><ol><li><p><strong>初始化</strong>：</p><ol><li>状态转移表 $states$ ： 设 $states[i]$ ，其中 $i$ 为所处状态， $states[i]$ 使用哈希表存储可转移至的状态。键值对 $(key, value)$ 含义：若输入 $key$ ，则可从状态 $i$ 转移至状态 $value$ 。</li><li>当前状态 $p$ ： 起始状态初始化为 $p = 0$ 。</li></ol></li><li><p><strong>状态转移循环</strong>： 遍历字符串 $s$ 的每个字符 $c$ 。</p><ol><li><p>记录字符类型 $t$ ： 分为四种情况。</p><ul><li><p>当 $c$ 为正负号时，执行 <code>t = &#39;s&#39;</code> ;</p></li><li><p>当 $c$ 为数字时，执行 <code>t = &#39;d&#39;</code> ;</p></li><li><p>当 $c$ 为 <code>e , E</code> 时，执行 <code>t = &#39;e&#39; </code>;</p></li><li><p>当 $c$ 为 <code>.</code> , <code>空格</code> 时，执行 <code>t = c</code> （即用字符本身表示字符类型）;</p></li><li><p>否则，执行 <code>t = &#39;?&#39;</code> ，代表为不属于判断范围的非法字符，后续直接返回 $ false $ 。</p></li></ul></li><li><p>终止条件： 若字符类型 $t$ 不在哈希表 $states[p]$ 中，说明无法转移至下一状态，因此直接返回 $ false$ 。</p></li><li><p>状态转移： 状态 $p$ 转移至 $ states[p][t] $ 。</p></li></ol></li><li><p><strong>返回值</strong>： 跳出循环后，若状态 $p \in {2, 3, 7, 8}$，说明结尾合法，返回 $ true $ ，否则返回 $ false $ 。</p></li></ol><p><strong>另一种方法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* string)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> sign = <span class="hljs-literal">false</span>, decimal = <span class="hljs-literal">false</span>,hasE = <span class="hljs-literal">false</span>;<span class="hljs-comment">//正负号 小数点 e</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(string);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;e&#x27;</span> || string[i] == <span class="hljs-string">&#x27;E&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>( i == len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//e 的后面必须要出现数字 对应 12e</span><br>            <span class="hljs-keyword">if</span>(hasE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//只能有一个e</span><br>            hasE = <span class="hljs-literal">true</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;+&#x27;</span> || string[i] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;                <br>            <span class="hljs-keyword">if</span>(!sign &amp;&amp; i&gt;<span class="hljs-number">0</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-comment">// 12e+5 如果第一次出现，且不是在开头，那么也要紧跟在e/E之后</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(sign &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-comment">// +5e-6  第二次出现，那也要跟在 e/E之后</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            sign = <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(decimal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">if</span>(hasE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// E后面不能跟小数点  12e+4.3</span><br><br>            decimal = <span class="hljs-literal">true</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || string[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">//不合法字符</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五十四、字符流中第一个不重复的字符"><a href="#五十四、字符流中第一个不重复的字符" class="headerlink" title="五十四、字符流中第一个不重复的字符"></a>五十四、<a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">字符流中第一个不重复的字符</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>后台会用以下方式调用Insert 和 FirstAppearingOnce 函数</p><blockquote><p>string caseout = “”;</p><p>1.读入测试用例字符串casein</p><p>2.如果对应语言有Init()函数的话，执行Init() 函数</p><p>3.循环遍历字符串里的每一个字符ch {</p><p>Insert(ch);</p><p>caseout += FirstAppearingOnce()</p><p>}</p><p>2.输出caseout，进行比较。</p></blockquote><p><strong>返回值描述：</strong></p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;google&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;ggg<span class="hljs-subst">#ll</span>&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">char</span>&gt; vec;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; res;<br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(ch);<br>        res[ch]++;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : vec) &#123;<br>            <span class="hljs-keyword">if</span>(res[ch] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>vector 读取字符流中的字符</p><p>map 存每个字符出现的次数</p><p>遍历 vector ，判断当字符次数为 1 时，返回当前字符</p><p>若遍历结束还没有符合的字符，返回 #</p><h2 id="五十五、链表中环的入口结点"><a href="#五十五、链表中环的入口结点" class="headerlink" title="五十五、链表中环的入口结点"></a>五十五、<a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">链表中环的入口结点</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p><strong>输入描述</strong>：</p><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这2个会组装成一个有环或者无环单链表</p><p><strong>返回值描述</strong>：</p><p>返回链表的环的入口结点即可。而我们后台程序会打印这个节点</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,2&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;3,4,5&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">返回环形链表入口节点，我们后台会打印该环形链表入口节点，即3    <br></code></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;null&quot;</span><br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">没有环，返回<span class="hljs-keyword">null</span>，后台打印<span class="hljs-string">&quot;null&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">只有环形链表节点2，返回节点2，后台打印2   <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-keyword">int</span>&gt;m;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            m[pHead]++;<br>            <span class="hljs-keyword">if</span>(m[pHead] == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> pHead;<br>            pHead = pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>方法一：哈希表</strong></p><p>通过map函数判断是否存在环路，此时将value值设置为出现的次数</p><p><strong>方法二：快慢指针</strong></p><p>两个指针一个fast、一个slow同时从一个链表的头部出发 fast一次走2步，slow一次走一步，如果该链表有环，两个指针必然在环内相遇 此时只需要把其中的一个指针重新指向链表头部，另一个不变（还在环内）， 这次两个指针一次走一步，相遇的地方就是入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode*fast = pHead,*low = pHead;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            low = low-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == low)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        low = pHead;<span class="hljs-comment">//low从链表头出发</span><br>        <span class="hljs-keyword">while</span>(fast != low) &#123;<span class="hljs-comment">//fast从相遇点出发</span><br>            fast = fast-&gt;next;<br>            low = low-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>算法流程：</strong></p><ol><li><p>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p><ol><li><p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；</p><ul><li>TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；</li></ul></li><li><p>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：</p><ul><li><p>设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数）；设两指针分别走了 f，s 步，则有：</p></li><li><p>fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）</p></li><li><p>fast 比 slow多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；</p></li><li><p>以上两式相减得：f=2nb，s=nb，即 fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。</p></li></ul></li></ol></li><li><p>目前情况分析：</p><ul><li>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li><li>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</li><li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</li></ul></li><li><p>双指针第二次相遇：</p><ul><li><p>slow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；</p><ul><li>TIPS：此时 f=0，s=nb ；</li></ul></li><li><p>当 fast 指针走到 f=a 步时，slow 指针走到步 s=a+nb，此时 两指针重合，并同时指向链表环入口 。</p></li></ul></li><li><p>返回slow指针指向的节点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 46-50</title>
    <link href="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/"/>
    <url>/2021/06/24/%E5%89%91%E6%8C%87offer46-50/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-46-50"><a href="#剑指offer-46-50" class="headerlink" title="剑指offer    46~50"></a>剑指offer    46~50</h1><h2 id="四十六、孩子们的游戏-圆圈中最后剩下的数"><a href="#四十六、孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="四十六、孩子们的游戏(圆圈中最后剩下的数)"></a>四十六、<a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏(圆圈中最后剩下的数)</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            pos = (pos + m) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>约瑟夫问题</strong></p><p>下面这个例子是<code>N=8 m=3</code>的例子</p><p>我们定义<code>F(n,m)</code>表示最后剩下那个人的<code>索引号</code>，因此我们只关系最后剩下来这个人的索引号的变化情况即可</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF1.png"></p><p>从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p><ul><li><p>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</p></li><li><p>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</p></li><li><p>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</p></li><li><p>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</p></li></ul><p><strong>最终活着的人编号的反推</strong></p><p>现在我们知道了G的索引号的变化过程，那么我们反推一下</p><p>从<code>N = 7</code> 到<code>N = 8</code> 的过程</p><p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p><p>我们先把被杀掉的<code>C</code>补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面</p><p>经过这个操作就恢复了N = 8 的排列了！</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/68509352d82d4a19678ed67a5bde338f86c7d0da730e3a69546f6fa61fb0063c-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF2.png"></p><p>因此我们可以推出递推公式 f(8,3) = [f(7, 3) + 3] % 8​</p><p>进行推广泛化，即 <code>f(n,m) = [f(n-1, m) + m] % n​</code></p><h2 id="四十七、求1-2-3-…-n"><a href="#四十七、求1-2-3-…-n" class="headerlink" title="四十七、求1+2+3+…+n"></a>四十七、<a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">求1+2+3+…+n</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">15<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">bool</span> x = n &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Sum_Solution</span>(n - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>;<br>        res += n;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>1+2+…+(n−1)+n 的计算方法主要有三种：平均计算、迭代、递归。</p><p>本题只能使用递归</p><p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：</p><p>if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</p><p>if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</p><p>本题需要实现 “当 n = 1 时终止递归” 的需求，可通过短路效应实现。</p><p>n &gt; 1 &amp;&amp; sumNums(n - 1)   // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</p><h2 id="四十八、不用加减乘除做加法"><a href="#四十八、不用加减乘除做加法" class="headerlink" title="四十八、不用加减乘除做加法"></a>四十八、<a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">不用加减乘除做加法</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(num2 != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>            num1 ^= num2;<br>            num2 = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第二版便于理解</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(num2 != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> sum = num1 ^ num2;<br>        <span class="hljs-keyword">int</span> carray = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>        num1 = sum;<br>        num2 = carray;<br>    &#125; <br>    <span class="hljs-keyword">return</span> num1;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>设两数字的二进制形式 $a$, $b$，其求和 $s = a + b$ ， $a(i)$ 代表 $a$ 的二进制第 $i$ 位，则分为以下四种情况：</p><table><thead><tr><th align="center">$a(i)$</th><th align="center">$b(i)$</th><th align="center"><strong>无进位和</strong> $n(i)$</th><th align="center"><strong>进位</strong> $c(i+1)$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>观察发现，<code>无进位和</code> 与 <code>异或运算</code> 规律相同，进位 和 与运算 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；<br>n=a⊕b           非进位和：异或运算</p><p>c=a&amp;b&lt;&lt;1      进位：与运算+左移一位</p><p>（和 s ）=（非进位和 n ）+（进位 c ）。即可将 s = a + b 转化为：$s = a + b \Rightarrow s = n + c$</p><p>循环求 n 和 c，直至进位 c = 0；此时 s = n ，返回 n 即可。</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png"></p><h2 id="四十九、把字符串转换成整数"><a href="#四十九、把字符串转换成整数" class="headerlink" title="四十九、把字符串转换成整数"></a>四十九、<a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把字符串转换成整数</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p><strong>输入描述：</strong></p><p>输入一个字符串,包括数字字母符号,可以为空</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>如果是合法的数值表达则返回该数字，否则返回0</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;+2147483647&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2147483647</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;1a33&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">0<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StrToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//为空，直接返回即可</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, flag = <span class="hljs-number">1</span>,isSingal = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 索引 正负号标志位  正负号出现次数</span><br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//默认flag = 1，正数</span><br>        <span class="hljs-keyword">while</span> (i&lt;len &amp;&amp; str[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">//若str全为空格，str[i] = &#x27;\0&#x27;(最后一个i)</span><br>        <span class="hljs-keyword">if</span> (i &gt;= len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//全部都是空格，直接返回</span><br>        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; <br>            flag = <span class="hljs-number">-1</span>; <br>            i++; <br>            isSingal++; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; str[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123; <br>            i++; <br>            isSingal++; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (isSingal &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (  ; i &lt; len ; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span> || str[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            res = res * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (res &gt;= INT_MAX &amp;&amp; flag == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  INT_MAX;<br>            <span class="hljs-keyword">if</span> (res &gt; INT_MAX &amp;&amp; flag == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>  INT_MIN;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag * res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>直接看代码解析</p><p>需要有正负号标志位  正负号出现次数</p><h2 id="五十、数组中重复的数字"><a href="#五十、数组中重复的数字" class="headerlink" title="五十、数组中重复的数字"></a>五十、<a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中重复的数字</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>或<span class="hljs-number">3</span>都是对的 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(numbers.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s[numbers[i]]++;<br>            <span class="hljs-keyword">if</span>(s[numbers[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析：</p><p>类似于<strong>哈希表</strong>做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span>(map[num]) <span class="hljs-keyword">return</span> num;<br>            map[num] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者</p><p><strong>原地交换</strong>，空间复杂度 $O(1)$</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/1618146573-bOieFQ-Picture0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i])<br>                <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[nums[i]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 其他知识点</title>
    <link href="/2021/06/24/C++11%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/06/24/C++11%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="八、C-11-其他知识点"><a href="#八、C-11-其他知识点" class="headerlink" title="八、C++11 其他知识点"></a>八、C++11 其他知识点</h1><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>直接看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = vec.<span class="hljs-built_in">begin</span>(); iter != vec.<span class="hljs-built_in">end</span>(); iter++) &#123; <span class="hljs-comment">// before c++11</span><br>   cout &lt;&lt; *iter &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : vec) &#123; <span class="hljs-comment">// c++11基于范围的for循环</span><br>cout &lt;&lt; <span class="hljs-string">&quot;i&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p><p><strong>不使用委托构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>()&#123;&#125;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-comment">// 好麻烦</span><br>       a_ = a;<br>       b_ = b;<br>  &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) &#123; <span class="hljs-comment">// 好麻烦</span><br>       a_ = a;<br>       b_ = b;<br>       c_ = c;<br>  &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>使用委托构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>()&#123;&#125;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">A</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">A</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：</p><p><strong>不使用继承构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-built_in">Base</span>() &#123;&#125;<br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br>   <span class="hljs-built_in">Derived</span>() &#123;&#125;<br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a) : <span class="hljs-built_in">Base</span>(a) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a, b) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b, c) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Derived <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用继承构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-built_in">Base</span>() &#123;&#125;<br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br>   <span class="hljs-keyword">using</span> Base::Base;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Derived <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要使用using Base::Base继承构造函数，就免去了很多重写代码的麻烦。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;func ptr&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;func i&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 编译失败，会产生二义性</span><br>   <span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 输出func ptr</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final-amp-override"><a href="#final-amp-override" class="headerlink" title="final &amp; override"></a>final &amp; override</h2><p>c++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><p>示例代码1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 确保func被重写</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fu</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// error，基类没有fu()，不可以被重写</span><br>       <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// 编译失败，final修饰的类不可以被继承</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>c++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a; <span class="hljs-comment">// 编译出错</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“<code>=default;</code>”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a1;<br>   A a2 = a1;  <span class="hljs-comment">// 正确，调用编译器隐式生成的默认拷贝构造函数</span><br>   A a3;<br>   a3 = a1;  <span class="hljs-comment">// 正确，调用编译器隐式生成的默认拷贝赋值操作符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp;) = <span class="hljs-keyword">delete</span>;<br>   A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A&amp;) = <span class="hljs-keyword">delete</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a1;<br>   A a2 = a1;  <span class="hljs-comment">// 错误，拷贝构造函数被禁用</span><br>   A a3;<br>   a3 = a1;  <span class="hljs-comment">// 错误，拷贝赋值操作符被禁用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>delele函数在c++11中很常用，<code>std::unique_ptr</code>就是通过delete修饰来禁止对象的拷贝的。</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：</p><p>不用explicit：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> value) &#123; <span class="hljs-comment">// 没有explicit关键字</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;value&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以隐式转换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用explicit:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;value&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，不可以隐式转换</span><br>   <span class="hljs-function">A <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// ok</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>因为要讲后面的constexpr，所以这里简单介绍下const。</p><p>const字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p><p>主要用法如下：</p><ol><li><p>用于定义常量，const的修饰的变量不可更改。</p></li><li><p>指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针,还是指针所指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> ptr; <span class="hljs-comment">// 指针本身是常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr; <span class="hljs-comment">// 指针指向的变量为常量</span><br></code></pre></td></tr></table></figure></li><li><p>在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> A&amp; a)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> value;<br><span class="hljs-built_in">B</span>(<span class="hljs-keyword">int</span> v) : <span class="hljs-built_in">value</span>(v)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>修饰类对象，类对象只能调用该对象的const成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">const</span> A a;<br>a.<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure></li></ol><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，<strong>这个函数的返回值会尽可能在编译期间被计算出来当作一个常量</strong>，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>   <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>   <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h2><p>c++11新增有作用域的枚举类型，看代码</p><p><strong>不带作用域的枚举代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AColor</span> &#123;</span><br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BColor</span> &#123;</span><br>   kWhite,<br>   kBlack,<br>   kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (kRed == kWhite) &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。</p><p><strong>有作用域的枚举代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AColor</span> &#123;</span><br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BColor</span> &#123;</span><br>   kWhite,<br>   kBlack,<br>   kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (AColor::kRed == BColor::kWhite) &#123; <span class="hljs-comment">// 编译失败</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AColor</span> :</span> <span class="hljs-keyword">char</span> &#123;<br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</p><h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>c++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-keyword">int</span> *b;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span> &#123;</span><br>   A a; <span class="hljs-comment">// 非POD类型 c++11之前不可以这样定义联合体</span><br>   <span class="hljs-keyword">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于什么是POD类型，大家可以自行查下资料，大体上可以理解为对象可以直接memcpy的类型。</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>c++11中sizeof可以用的类的数据成员上，看代码：</p><p><strong>c++11前：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> data[<span class="hljs-number">10</span>];<br>   <span class="hljs-keyword">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a;<br>   cout &lt;&lt; <span class="hljs-string">&quot;size &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a.data) &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>c++11</strong>后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> data[<span class="hljs-number">10</span>];<br>   <span class="hljs-keyword">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;size &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A::data) &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p><h2 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h2><p>c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>, message);<br></code></pre></td></tr></table></figure><h2 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h2><p>c++11可以自定义字面量，我们平时c++中都或多或少使用过chrono中的时间，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 100ms</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 100s</span><br></code></pre></td></tr></table></figure><p>其实没必要这么麻烦，也可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">100</span>ms); <span class="hljs-comment">// c++14里可以这么使用，这里只是举个自定义字面量使用的例子</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">100</span>s);<br></code></pre></td></tr></table></figure><p>这就是自定义字面量的使用，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mytype</span> &#123;</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value;<br>&#125;;<br><span class="hljs-keyword">constexpr</span> mytype <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mytype ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n ) &#123;<br>   <span class="hljs-keyword">return</span> mytype&#123;n&#125;;<br>&#125;<br>mytype mm = <span class="hljs-number">123</span>_mytype;<br>cout &lt;&lt; mm.value &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><strong>什么是内存对齐</strong></p><p>理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数<strong>N的倍数</strong>，这就是内存对齐。</p><p><strong>为什么要内存对齐</strong></p><ol><li>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。</li><li>提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</li></ol><p>在c++11之前如果想创建内存对齐需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">align_cpp11_before</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> data[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A)];<br>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> kAlign = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">char</span> *align_ptr =<br>       <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span> *&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(data + kAlign) &amp; ~kAlign);<br>   A *attr = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (align_ptr) A;<br>&#125;<br></code></pre></td></tr></table></figure><p>c++11关于内存对齐新增了一些函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">align_cpp11_after</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">static</span> std::aligned_storage&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A),<br>                               <span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(A)&gt;::type data;<br>   A *attr = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (&amp;data) A;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><p>c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name)</span> </span>&#123;<br>        <span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        ++count;<br>        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name)</span> </span>&#123;<br>    A a1;<br>    a1.<span class="hljs-built_in">test</span>(name);<br>    a1.<span class="hljs-built_in">test</span>(name);<br>    A a2;<br>    a2.<span class="hljs-built_in">test</span>(name);<br>    a2.<span class="hljs-built_in">test</span>(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">thread</span>(func, <span class="hljs-string">&quot;thread1&quot;</span>).<span class="hljs-built_in">join</span>();<br>    std::<span class="hljs-built_in">thread</span>(func, <span class="hljs-string">&quot;thread2&quot;</span>).<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">thread1</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。</p><h2 id="基础数值类型"><a href="#基础数值类型" class="headerlink" title="基础数值类型"></a>基础数值类型</h2><p>c++11新增了几种数据类型：long long、char16_t、char32_t等</p><h2 id="随机数功能"><a href="#随机数功能" class="headerlink" title="随机数功能"></a>随机数功能</h2><p>c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">std::default_random_engine <span class="hljs-title">random</span><span class="hljs-params">(time(<span class="hljs-literal">nullptr</span>))</span></span>;<br><br>   <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">int_dis</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 整数均匀分布</span><br>   <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">real_dis</span><span class="hljs-params">(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">// 浮点数均匀分布</span><br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>       cout &lt;&lt; <span class="hljs-built_in">int_dis</span>(random) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>   cout &lt;&lt; endl;<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>       cout &lt;&lt; <span class="hljs-built_in">real_dis</span>(random) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>   cout &lt;&lt; endl;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">38</span> <span class="hljs-number">100</span> <span class="hljs-number">93</span> <span class="hljs-number">7</span> <span class="hljs-number">66</span> <span class="hljs-number">0</span> <span class="hljs-number">68</span> <span class="hljs-number">99</span> <span class="hljs-number">41</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">232202</span> <span class="hljs-number">0</span>.<span class="hljs-number">617716</span> <span class="hljs-number">0</span>.<span class="hljs-number">959241</span> <span class="hljs-number">0</span>.<span class="hljs-number">970859</span> <span class="hljs-number">0</span>.<span class="hljs-number">230406</span> <span class="hljs-number">0</span>.<span class="hljs-number">430682</span> <span class="hljs-number">0</span>.<span class="hljs-number">477359</span> <span class="hljs-number">0</span>.<span class="hljs-number">971858</span> <span class="hljs-number">0</span>.<span class="hljs-number">0171148</span> <span class="hljs-number">0</span>.<span class="hljs-number">64863</span><br></code></pre></td></tr></table></figure><p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>c++11引入了regex库更好的支持正则表达式，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::string s = <span class="hljs-string">&quot;I know, I&#x27;ll use2 regular expressions.&quot;</span>;<br><span class="hljs-comment">// 忽略大小写</span><br>   <span class="hljs-function">std::regex <span class="hljs-title">self_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;REGULAR EXPRESSIONS&quot;</span>, std::regex_constants::icase)</span></span>;<br>   <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(s, self_regex)) &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;Text contains the phrase &#x27;regular expressions&#x27;\n&quot;</span>;<br>  &#125;<br><br>   <span class="hljs-function">std::regex <span class="hljs-title">word_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;(\\w+)&quot;</span>)</span></span>;  <span class="hljs-comment">// 匹配字母数字等字符</span><br>   <span class="hljs-keyword">auto</span> words_begin = std::<span class="hljs-built_in">sregex_iterator</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), word_regex);<br>   <span class="hljs-keyword">auto</span> words_end = std::<span class="hljs-built_in">sregex_iterator</span>();<br><br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(words_begin, words_end) &lt;&lt; <span class="hljs-string">&quot; words\n&quot;</span>;<br><br>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6</span>;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Words longer than &quot;</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">&quot; characters:\n&quot;</span>;<br>   <span class="hljs-keyword">for</span> (std::sregex_iterator i = words_begin; i != words_end; ++i) &#123;<br>       std::smatch match = *i;<br>       std::string match_str = match.<span class="hljs-built_in">str</span>();<br>       <span class="hljs-keyword">if</span> (match_str.<span class="hljs-built_in">size</span>() &gt; N) &#123;<br>           std::cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; match_str &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>      &#125;<br>  &#125;<br><br>   <span class="hljs-function">std::regex <span class="hljs-title">long_word_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;(\\w&#123;7,&#125;)&quot;</span>)</span></span>;<br>   <span class="hljs-comment">// 超过7个字符的单词用[]包围</span><br>   std::string new_s = std::<span class="hljs-built_in">regex_replace</span>(s, long_word_regex, <span class="hljs-string">&quot;[$&amp;]&quot;</span>);<br>   std::cout &lt;&lt; new_s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h2><p>c++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点：</p><ul><li>duration</li><li>time_point</li><li>clocks</li></ul><p><strong>duration</strong></p><p>std::chrono::duration 表示一段时间，常见的单位有s、ms等，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拿休眠一段时间举例，这里表示休眠100ms</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p>sleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> duration&lt;<span class="hljs-keyword">int64_t</span>, milli&gt; milliseconds;<br><span class="hljs-keyword">typedef</span> duration&lt;<span class="hljs-keyword">int64_t</span>&gt; seconds;<br></code></pre></td></tr></table></figure><p>duration具体模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span> =</span> ratio&lt;<span class="hljs-number">1</span>&gt; &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">duration</span>;</span><br></code></pre></td></tr></table></figure><p>Rep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration&lt;Rep, Period&gt;已经定义好了，在std::chrono::duration下：</p><ul><li>ratio&lt;3600, 1&gt;：hours</li><li>ratio&lt;60, 1&gt;：minutes</li><li>ratio&lt;1, 1&gt;：seconds</li><li>ratio&lt;1, 1000&gt;：microseconds</li><li>ratio&lt;1, 1000000&gt;：microseconds</li><li>ratio&lt;1, 1000000000&gt;：nanosecons</li></ul><p>ratio的具体模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">intmax_t</span> N, <span class="hljs-keyword">intmax_t</span> D = <span class="hljs-number">1</span>&gt; class ratio;<br></code></pre></td></tr></table></figure><p>N代表分子，D代表分母，所以ratio表示一个分数，我们可以自定义Period，比如ratio&lt;2, 1&gt;表示单位时间是2秒。</p><p><strong>time_point</strong></p><p>表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">chrono::time_point&lt;std::chrono::high_resolution_clock&gt; <span class="hljs-title">Now</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>&#125;<br><span class="hljs-comment">// std::chrono::high_resolution_clock为高精度时钟，下面会提到</span><br></code></pre></td></tr></table></figure><p><strong>clocks</strong></p><p>时钟，chrono里面提供了三种时钟：</p><ul><li>steady_clock</li><li>system_clock</li><li>high_resolution_clock</li></ul><ol><li><p><strong>steady_clock</strong></p><p>稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。</p></li><li><p><strong>system_clock</strong></p><p>表示当前的系统时钟，可以用于获取当前时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">using</span> std::chrono::system_clock;<br>   system_clock::time_point today = system_clock::<span class="hljs-built_in">now</span>();<br><br>   std::<span class="hljs-keyword">time_t</span> tt = system_clock::<span class="hljs-built_in">to_time_t</span>(today);<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;today is: &quot;</span> &lt;&lt; <span class="hljs-built_in">ctime</span>(&amp;tt);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// today is: Sun May 10 09:48:36 2020</span><br></code></pre></td></tr></table></figure></li><li><p><strong>high_resolution_clock</strong></p><p>high_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，我之前看gcc chrono源码中high_resolution_clock是steady_clock的typedef。</p></li></ol><h2 id="新增数据结构"><a href="#新增数据结构" class="headerlink" title="新增数据结构"></a>新增数据结构</h2><ul><li><p>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; fl = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;elem : fl) &#123;<br>   cout &lt;&lt; elem;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似</p></li><li><p>std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似</p></li><li><p>std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组</p></li><li><p>std::tuple：元组类型，类似pair，但比pair扩展性好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; Mytuple;<br><span class="hljs-function">Mytuple <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">0</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">1</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">2</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;3 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">3</span>&gt;(t);<br></code></pre></td></tr></table></figure></li></ul><h2 id="新增算法"><a href="#新增算法" class="headerlink" title="新增算法"></a>新增算法</h2><ul><li><p>all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">all_of</span>(v.<span class="hljs-built_in">cbegin</span>(), v.<span class="hljs-built_in">cend</span>(), [](<span class="hljs-keyword">int</span> i) &#123; <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;)) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;All numbers are even\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样</p></li><li><p>none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样</p></li><li><p>find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反</p></li><li><p>copy_if：复制满足条件的元素</p></li><li><p>itoa：对容器内的元素按序递增</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>std::<span class="hljs-built_in">iota</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-number">19</span>); <span class="hljs-comment">// 19为初始值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : l) std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">// 19 20 21 22 23 24 25 26 27 28</span><br></code></pre></td></tr></table></figure></li><li><p>minmax_element：返回容器内最大元素和最小元素位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;<br><br>   <span class="hljs-keyword">auto</span> result = std::<span class="hljs-built_in">minmax_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;min element at: &quot;</span> &lt;&lt; *(result.first) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;max element at: &quot;</span> &lt;&lt; *(result.second) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// min element at: 1</span><br><span class="hljs-comment">// max element at: 9</span><br></code></pre></td></tr></table></figure></li><li><p>is_sorted、is_sorted_until：返回容器内元素是否已经排好序。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 线程相关所有知识点</title>
    <link href="/2021/06/23/C++11%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/06/23/C++11%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="七、线程相关所有知识点"><a href="#七、线程相关所有知识点" class="headerlink" title="七、线程相关所有知识点"></a>七、线程相关所有知识点</h1><p>c++11关于并发引入了好多好东西，这里按照如下顺序介绍：</p><ul><li>std::thread相关</li><li>std::mutex相关</li><li>std::lock相关</li><li>std::atomic相关</li><li>std::call_once相关</li><li>volatile相关</li><li>std::condition_variable相关</li><li>std::future相关</li><li>async相关</li></ul><h2 id="std-thread相关"><a href="#std-thread相关" class="headerlink" title="std::thread相关"></a>std::thread相关</h2><p>c++11之前你可能使用pthread_xxx来创建线程，繁琐且不易读，c++11引入了std::thread来创建线程，支持对线程 join 或者 detach 。直接看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = []() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>()) &#123;<br>        t.<span class="hljs-built_in">detach</span>();    <span class="hljs-comment">//线程分离</span><br>    &#125;<br>    <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">tt</span><span class="hljs-params">(func1, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (tt.<span class="hljs-built_in">joinable</span>()) &#123; <span class="hljs-comment">// 检查线程可否被join</span><br>        tt.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>上述代码中，函数 func 和 func1 运行在线程对象 t 和 tt 中，从刚创建对象开始就会新建一个线程用于执行函数，调用 join 函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的 detach 函数，表示将线程和线程对象分离。</p><p>如果没有调用 join 或者 detach 函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用 join() ，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用 detach() ，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过 join 来等待线程执行完。</p><p>这里可以对 thread 进行封装，避免没有调用 join 或者 detach 可导致程序出错的情况出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGuard</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DesAction</span> &#123;</span> join, detach &#125;;<br><br>   <span class="hljs-built_in">ThreadGuard</span>(std::thread&amp;&amp; t, DesAction a) : <span class="hljs-built_in">t_</span>(std::<span class="hljs-built_in">move</span>(t)), <span class="hljs-built_in">action_</span>(a)&#123;&#125;;<br><br>   ~<span class="hljs-built_in">ThreadGuard</span>() &#123;<br>       <span class="hljs-keyword">if</span> (t_.<span class="hljs-built_in">joinable</span>()) &#123;<br>           <span class="hljs-keyword">if</span> (action_ == DesAction::join) &#123;<br>               t_.<span class="hljs-built_in">join</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>               t_.<span class="hljs-built_in">detach</span>();<br>          &#125;<br>  &#125;<br>  &#125;<br><br>   <span class="hljs-built_in">ThreadGuard</span>(ThreadGuard&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>   ThreadGuard&amp; <span class="hljs-keyword">operator</span>=(ThreadGuard&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>   <span class="hljs-function">std::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t_; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>   std::thread t_;<br>   DesAction action_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">ThreadGuard <span class="hljs-title">t</span><span class="hljs-params">(std::thread([]() &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">           std::cout &lt;&lt; <span class="hljs-string">&quot;thread guard &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">      &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">       std::cout &lt;&lt; std::endl;&#125;), ThreadGuard::DesAction::join)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">thread</span> guard <span class="hljs-number">0</span> thread guard <span class="hljs-number">1</span> thread guard <span class="hljs-number">2</span> thread guard <span class="hljs-number">3</span> thread guard <span class="hljs-number">4</span> thread guard <span class="hljs-number">5</span> thread guard <span class="hljs-number">6</span> thread guard <span class="hljs-number">7</span> thread guard <span class="hljs-number">8</span> thread guard <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>c++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前线程ID &quot;</span> &lt;&lt; t.<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前cpu个数 &quot;</span> &lt;&lt; std::thread::<span class="hljs-built_in">hardware_concurrency</span>() &lt;&lt; endl;<br><span class="hljs-keyword">auto</span> handle = t.<span class="hljs-built_in">native_handle</span>();<span class="hljs-comment">// handle可用于pthread相关操作</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h2 id="std-mutex相关"><a href="#std-mutex相关" class="headerlink" title="std::mutex相关"></a>std::mutex相关</h2><p>std::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。</p><p>mutex分为四种：</p><ul><li>std::mutex：独占的互斥量，不能递归使用，不带超时功能</li><li>std::recursive_mutex：递归互斥量，可重入，不带超时功能</li><li>std::timed_mutex：带超时的互斥量，不能递归</li><li>std::recursive_timed_mutex：带超时的互斥量，可以递归使用</li></ul><p>拿一个std::mutex和std::timed_mutex举例吧，别的都是类似的使用方式：</p><p><strong>std::mutex:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::mutex mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       mutex_.<span class="hljs-built_in">lock</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>       mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">20</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p><strong>std::timed_mutex:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::timed_mutex timed_mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       timed_mutex_.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>       timed_mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">200</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-lock相关"><a href="#std-lock相关" class="headerlink" title="std::lock相关"></a>std::lock相关</h2><p>这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。</p><p>c++11主要有 std::lock_guard 和 std::unique_lock 两种方式，使用方式都类似，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::mutex mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       <span class="hljs-comment">// std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span><br>       std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mutex_);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">200</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>std::lock_gurad 相比于 std::unique_lock 更加轻量级，少了一些成员函数，std::unique_lock 类有 unlock 函数，可以手动释放锁，所以条件变量都配合 std::unique_lock 使用，而不是 std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力。</p><h2 id="std-atomic相关"><a href="#std-atomic相关" class="headerlink" title="std::atomic相关"></a>std::atomic相关</h2><p>c++11提供了原子类型std::atomic&lt; T &gt;，理论上这个T可以是任意类型，但是我平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就<strong>不需要使用 std::mutex 来保护该变量</strong>啦。看一个计数器的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OriginCounter</span> &#123;</span> <span class="hljs-comment">// 普通的计数器</span><br>   <span class="hljs-keyword">int</span> count;<br>   std::mutex mutex_;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       ++count;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       --count;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       <span class="hljs-keyword">return</span> count;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewCounter</span> &#123;</span> <span class="hljs-comment">// 使用原子变量的计数器</span><br>   std::atomic&lt;<span class="hljs-keyword">int</span>&gt; count;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       ++count;<br>       <span class="hljs-comment">// count.store(++count);这种方式也可以</span><br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;<br>       --count;<br>       <span class="hljs-comment">// count.store(--count);</span><br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> count.<span class="hljs-built_in">load</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="std-call-once相关"><a href="#std-call-once相关" class="headerlink" title="std::call_once相关"></a>std::call_once相关</h2><p>c++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>std::once_flag onceflag;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CallOnce</span><span class="hljs-params">()</span> </span>&#123;<br>   std::<span class="hljs-built_in">call_once</span>(onceflag, []() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;call once&quot;</span> &lt;&lt; endl;<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(CallOnce);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="volatile相关"><a href="#volatile相关" class="headerlink" title="volatile相关"></a>volatile相关</h2><p>volatile通常用来建立内存屏障，volatile修饰的变量，编译器对访问该变量的代码通常不再进行优化，看下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = xxx;<br><span class="hljs-keyword">int</span> a = *p;<br><span class="hljs-keyword">int</span> b = *p;<br></code></pre></td></tr></table></figure><p>a 和 b 都等于 p 指向的值，一般编译器会对此做优化，把 *p 的值放入<code>寄存器</code>，就是传说中的工作内存(不是主内存)，之后 a 和 b 都等于寄存器的值，但是如果中间 p 地址的值改变，内存上的值改变啦，但 a , b 还是从寄存器中取的值(不一定，看编译器优化结果)，这就不符合需求，所以在此对 p 加 <code>volatile </code>修饰可以避免进行此类优化。</p><blockquote><p><strong>注意：</strong>volatile不能解决多线程安全问题，针对特种内存才需要使用 volatile，它和 atomic 的特点如下：</p></blockquote><p>• std::atomic 用于多线程访问的数据，且不用互斥量，用于并发编程中</p><p>• volatile 用于读写操作不可以被优化掉的内存，用于特种内存中</p><h2 id="std-condition-variable相关"><a href="#std-condition-variable相关" class="headerlink" title="std::condition_variable相关"></a>std::condition_variable相关</h2><p><code>条件变量</code>是c++11引入的一种同步机制，它可以阻塞一个线程或者个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的 std::unique_lock。</p><p>这里使用条件变量实现一个CountDownLatch（倒计时锁存器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatch</span> &#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> count)</span> : count_(count);</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CountDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        --count_;<br>        <span class="hljs-keyword">if</span> (count_ == <span class="hljs-number">0</span>) &#123;<br>            cv_.<span class="hljs-built_in">notify_all</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Await</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> time_ms = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">while</span> (count_ &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (time_ms &gt; <span class="hljs-number">0</span>) &#123;<br>                cv_.<span class="hljs-built_in">wait_for</span>(lock, std::chrono::<span class="hljs-built_in">milliseconds</span>(time_ms));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cv_.<span class="hljs-built_in">wait</span>(lock);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">GetCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>      <span class="hljs-keyword">return</span> count_;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span>:<br>    std::condition_variable cv_;<br>    <span class="hljs-keyword">mutable</span> std::mutex mutex_;<br>    <span class="hljs-keyword">uint32_t</span> count_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="std-future相关"><a href="#std-future相关" class="headerlink" title="std::future相关"></a>std::future相关</h2><p>c++11关于异步操作提供了 <code>future</code> 相关的类，主要有 std::future、std::promise和std::packaged_task，std::future 比 std::thread 高级些，std::future 作为异步结果的传输通道，通过 get() 可以很方便的获取线程函数的返回值，std::promise 用来包装一个值，将数据和 future 绑定起来，而 std::packaged_task 则用来包装一个调用对象，将函数和 future 绑定起来，方便异步调用。而 std::future 是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。</p><p><strong>std::promise 与 std::future 配合使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::future&lt;<span class="hljs-keyword">int</span>&gt;&amp; fut)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = fut.<span class="hljs-built_in">get</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-keyword">int</span>&gt; prom;<br>    std::future&lt;<span class="hljs-keyword">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func, std::ref(fut))</span></span>;<br>    prom.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">144</span>);<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">value</span>: <span class="hljs-number">144</span><br></code></pre></td></tr></table></figure><p><strong>std::packaged_task 与 std::future 配合使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> in + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(func)</span></span>;<br>    std::future&lt;<span class="hljs-keyword">int</span>&gt; fut = task.<span class="hljs-built_in">get_future</span>();<br>    std::<span class="hljs-built_in">thread</span>(std::<span class="hljs-built_in">move</span>(task), <span class="hljs-number">5</span>).<span class="hljs-built_in">detach</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;result &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">result</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>三者之间的关系</strong></p><p>std::future 用于访问异步操作的结果，而 std::promise 和 std::packaged_task 在 future 高一层，它们内部都有一个 future，promise 包装的是一个值，packaged_task 包装的是一个函数，当需要获取线程中的某个值，可以使用 std::promise，当需要获取线程函数返回值，可以使用 std::packaged_task。</p><h2 id="async相关"><a href="#async相关" class="headerlink" title="async相关"></a>async相关</h2><p>async 是比 future，packaged_task，promise 更高级的东西，它是基于任务的异步操作，通过 async 可以直接创建异步的任务，返回的结果会保存在 future 中，不需要像 packaged_task 和 promise 那么麻烦，关于线程操作应该优先使用 async，看一段使用代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> in + <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">async</span>(func, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// res.wait();</span><br>    cout &lt;&lt; res.<span class="hljs-built_in">get</span>() &lt;&lt; endl; <span class="hljs-comment">// 阻塞直到函数返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用async异步执行函数是不是方便多啦。</p><p>async具体语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span>(std::launch::<span class="hljs-keyword">async</span> | std::launch::deferred, func, args...);<br></code></pre></td></tr></table></figure><p>第一个参数是创建策略：</p><ul><li>std::launch::async 表示任务执行在另一线程</li><li>std::launch::deferred 表示延迟执行任务，调用 get 或者 wait 时才会执行，不会创建线程，惰性执行在当前线程。 </li></ul><p>如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。</p><p>若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future 的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">async</span>(std::launch::async, []&#123; <span class="hljs-built_in">f</span>(); &#125;); <span class="hljs-comment">// 临时量的析构函数等待 f()</span><br>std::<span class="hljs-built_in">async</span>(std::launch::async, []&#123; <span class="hljs-built_in">g</span>(); &#125;); <span class="hljs-comment">// f() 完成前不开始</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>std::thread使线程的创建变得非常简单，还可以获取线程id等信息。</li><li>std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。</li><li>std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。</li><li>std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量</li><li>std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。</li><li>volatile常用于读写操作不可以被优化掉的内存中。</li><li>std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。</li><li>std::future用于异步调用的包装和返回值。</li><li>async更方便的实现了异步调用，异步调用优先使用async取代创建线程。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : c++11新特性之线程相关所有知识点 (<a href="https://mp.weixin.qq.com/s/rPjRTOTYK2SGr6WxgWI_Vg">https://mp.weixin.qq.com/s/rPjRTOTYK2SGr6WxgWI_Vg</a>)</p><p>[ 2 ] : C++11 并发指南系列_章志强的专栏-CSDN博客(<a href="https://blog.csdn.net/zhangzq86/article/details/70623394">https://blog.csdn.net/zhangzq86/article/details/70623394</a>)</p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 41-45</title>
    <link href="/2021/06/22/%E5%89%91%E6%8C%87offer41-45/"/>
    <url>/2021/06/22/%E5%89%91%E6%8C%87offer41-45/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-41-45"><a href="#剑指offer-41-45" class="headerlink" title="剑指offer    41~45"></a>剑指offer    41~45</h1><h2 id="四十一、和为S的连续正数序列"><a href="#四十一、和为S的连续正数序列" class="headerlink" title="四十一、和为S的连续正数序列"></a>四十一、<a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">和为S的连续正数序列</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">9<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><p>一刷：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-keyword">int</span> target) &#123;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;ret;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;vec;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i;; j++) &#123;<br>sum += j;<br><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target) &#123;<br>vec.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++) &#123;<br>vec.<span class="hljs-built_in">push_back</span>(k);<br>&#125;<br>ret.<span class="hljs-built_in">push_back</span>(vec);<br>sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>暴力搜索，从 $1 $ 开始加，一直加到 $target$ 的一半</p><ul><li>若 $&gt;target$ ，$sum = 0$ ，重新从 $2$ 开始加</li><li>若 $=target$ ，把值给 $vec$</li></ul><p><strong>二刷：</strong></p><p><strong>滑动窗口（双指针）</strong></p><blockquote><p>算法流程：</p></blockquote><ol><li>初始化： 左边界 $i = 1$ ，右边界 $j = 2$ ，元素和 $s = 3$ ，结果列表 $res$ ；</li><li>循环： 当 $i \geq j$ 时跳出；<ul><li>当 $s &gt; target$ 时： 向右移动左边界 $i = i + 1$ ，并更新元素和 $s$ ；</li><li>当 $s &lt; target$ 时： 向右移动右边界 $j = j + 1$ ，并更新元素和 $s$ ；</li><li>当 $s = target$ 时： 记录连续整数序列，并向右移动左边界 $i = i + 1$ ；</li></ul></li><li>返回值： 返回结果列表 $res$ ；</li></ol><p><img src="/2021/06/22/%E5%89%91%E6%8C%87offer41-45/1611495306-LsrxgS-Picture2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>, s = <span class="hljs-number">3</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">if</span>(s == sum) &#123;<br>                vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(k);<br>                &#125;<br>                res.<span class="hljs-built_in">push_back</span>(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= sum)&#123;<br>                s -= i;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>                s += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四十二、和为S的两个数字"><a href="#四十二、和为S的两个数字" class="headerlink" title="四十二、和为S的两个数字"></a>四十二、<a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">和为S的两个数字</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。</p><h3 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>对应每个测试案例，输出两个数，小的先输出。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,4,7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">11</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = array.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> s = array[i] + array[j];<br>            <span class="hljs-keyword">if</span>(s &gt; sum)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; sum) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;array[i], array[j]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>算法流程：</strong></p><ol><li>初始化： 双指针 $i$ , $j$ 分别指向数组 $nums$ 的左右两端 （俗称对撞双指针）。</li><li>循环搜索： 当双指针相遇时跳出；<ol><li>计算和 $s = nums[i] + nums[j]$ ；</li><li>若 $s &gt; target$ ，则指针 $j$ 向左移动，即执行 $j = j - 1$ ；</li><li>若 $s &lt; target$ ，则指针 ii 向右移动，即执行 $i = i + 1$ ；</li><li>若 $s = target$ ，立即返回数组 $nums[i],nums[j]$ ；</li></ol></li><li>返回空数组，代表无和为 $target$ 的数字组合。</li></ol><h2 id="四十三、左旋转字符串"><a href="#四十三、左旋转字符串" class="headerlink" title="四十三、左旋转字符串"></a>四十三、<a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">左旋转字符串</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）。例如，字符序列S=”abcXYZdef”,要求输出循环左移 3 位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-string">&quot;abcXYZdef&quot;</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;XYZdefabc&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">begin</span>() + n);<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>() + n, str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>例如：输入: s = “abcdefg”, k = 2</p><ol><li>“abcdefg” 反转前2个字符 “bacdefg”</li><li>“bacdefg” 反转后5个字符 “bagfedc”</li><li>“bagfedc” 反转整个字符串 “cdefgab”</li></ol><h2 id="四十四、翻转单词序列"><a href="#四十四、翻转单词序列" class="headerlink" title="四十四、翻转单词序列"></a>四十四、<a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">翻转单词序列</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;nowcoder. <span class="hljs-selector-tag">a</span> am <span class="hljs-selector-tag">I</span>&quot;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">I</span> am <span class="hljs-selector-tag">a</span> nowcoder.&quot;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">//删除最前面的空格</span><br><span class="hljs-keyword">while</span> (str.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>());<br>&#125;<br><span class="hljs-comment">//删除最后面的空格</span><br><span class="hljs-keyword">while</span> (str.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; str[str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>() + str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br>        <span class="hljs-keyword">int</span> j = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, i = j;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; str[i] != <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            res = res + str.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - i) + <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) i--;<br>            j = i;<br>        &#125;<br>        res.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//去除最后多加的一个空格</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>双指针</strong></p><p>加了首尾若有空格的情况</p><p>算法解析：</p><ul><li>倒序遍历字符串 $s$ ，记录单词左右索引边界 $i$ , $j$ ；</li><li>每确定一个单词的边界，则将其添加至单词列表 $res$ ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><h2 id="四十五、扑克牌顺子"><a href="#四十五、扑克牌顺子" class="headerlink" title="四十五、扑克牌顺子"></a>四十五、<a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">扑克牌顺子</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。<br>有如下规则：</p><ol><li>A为1，J为11，Q为12，K为13，A不能视为14</li><li>大、小王为 0，0可以看作任意牌</li><li>如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。</li></ol><p>例如：给出数据[6,0,2,0,4]</p><p>中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]</p><p>这样这五张牌在[2,6]区间连续，输出true</p><p>数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">13</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-keyword">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> joker = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[i] == <span class="hljs-number">0</span>) joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[i] == numbers[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">4</span>] - numbers[joker] &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>根据题意，此 5 张牌是顺子的 <strong>充分条件</strong> 如下：</p><ol><li>除大小王外，所有牌 <strong>无重复</strong> ；</li><li>设此 5 张牌中最大的牌为 $max$ ，最小的牌为 $min$ （大小王除外），则需满足：$max - min &lt; 5$</li></ol><p><strong>排序 + 遍历</strong></p><ul><li>先对数组执行排序。</li><li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 $nums[i] = nums[i + 1]$ 是否成立来判重。</li><li>获取最大 / 最小的牌： 排序后，数组末位元素 $nums[4]$ 为最大牌；元素 $nums[joker]$ 为最小牌，其中 $joker$ 为大小王的数量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 36-40</title>
    <link href="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/"/>
    <url>/2021/06/21/%E5%89%91%E6%8C%87offer36-40/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-36-40"><a href="#剑指offer-36-40" class="headerlink" title="剑指offer    36~40"></a>剑指offer    36~40</h1><h2 id="三十六、两个链表的第一个公共结点"><a href="#三十六、两个链表的第一个公共结点" class="headerlink" title="三十六、两个链表的第一个公共结点"></a>三十六、<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">两个链表的第一个公共结点</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,2,3&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;4,5&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;6,7&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">第一个参数</span><span class="hljs-template-variable">&#123;1,2,3&#125;</span><span class="xml">代表是第一个链表非公共部分，第二个参数</span><span class="hljs-template-variable">&#123;4,5&#125;</span><span class="xml">代表是第二个链表非公共部分，最后的</span><span class="hljs-template-variable">&#123;6,7&#125;</span><span class="xml">表示的是2个链表的公共部分</span><br><span class="xml">这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的    </span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2,3&#125;</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span>个链表没有公共节点 ,返回<span class="hljs-literal">null</span>，后台打印&#123;&#125; <br></code></pre></td></tr></table></figure><p><strong>一刷写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        ListNode* p = pHead1;<br>        ListNode* q = pHead2;<br>        <span class="hljs-keyword">int</span> size1 = <span class="hljs-number">0</span>, size2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>) &#123;<br>            size1++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>) &#123;<br>            size2++;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(size1 - size2);<br>        <span class="hljs-keyword">if</span>(size1 &gt; size2)&#123;<br>            p = pHead1;<br>            q = pHead2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = pHead2;<br>            q = pHead1;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num)&#123;<br>            p = p-&gt;next;<br>            num--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p == q) <span class="hljs-keyword">return</span> p;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><ol><li>先计算两个链表的长度 $size1$，$size2$</li><li>根据长度差使头指针 $p$，$q$ 在同一起跑线</li><li> $p$，$q$ 同时后移，相等时即为公共节点</li></ol><p><strong>二刷思路：</strong></p><p>设「第一个公共节点」为 <code>node</code> ，「链表 <code>pHead1</code>」的节点数量为 $a$ ，「链表 <code>pHead2</code>」的节点数量为 $b$ ，「两链表的公共尾部」的节点数量为 $ c$ ，则有：</p><ul><li>头节点 <code>pHead1</code> 到 <code>node</code> 前，共有 $a - c$ 个节点；</li><li>头节点 <code>pHead2</code> 到 <code>node</code> 前，共有 $b - c$ 个节点；</li></ul><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/1615224578-EBRtwv-Picture1.png"></p><p>考虑构建两个节点指针 <code>A</code> , <code>B</code> 分别指向两链表头节点 <code>pHead1</code> , <code>pHead2</code> ，做如下操作：</p><ul><li>指针 <code>A</code> 先遍历完链表 <code>pHead1</code> ，再开始遍历链表 <code>pHead2</code> ，当走到 <code>node</code> 时，共走步数为：$a+(b−c)$</li><li>指针 <code>B</code> 先遍历完链表 <code>pHead2</code> ，再开始遍历链表 <code>pHead1</code> ，当走到 <code>node</code> 时，共走步数为：$b + (a - c)$</li></ul><p>此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：$a + (b - c) = b + (a - c)$</p><ol><li><p>若两链表 <strong>有</strong> 公共尾部 (即 $c &gt; 0$ ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</p></li><li><p>若两链表 <strong>无</strong> 公共尾部 (即 $c = 0$ ) ：指针 <code>A</code> , <code>B</code> 同时指向 $nullptr$ 。</p></li></ol><p>因此返回 <code>A</code> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        ListNode *A = pHead1, *B = pHead2;<br>        <span class="hljs-keyword">while</span> (A != B) &#123;<br>            A = A != <span class="hljs-literal">nullptr</span> ? A-&gt;next : pHead2;<br>            B = B != <span class="hljs-literal">nullptr</span> ? B-&gt;next : pHead1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三十七、数字在升序数组中出现的次数"><a href="#三十七、数字在升序数组中出现的次数" class="headerlink" title="三十七、数字在升序数组中出现的次数"></a>三十七、<a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数字在升序数组中出现的次数</a></h2><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>统计一个数字在升序数组中出现的次数。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,3,3</span>,<span class="hljs-number">3,3,4,5</span>],<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(data[left] &lt; k &amp;&amp; left &lt; data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)left++;<br>        <span class="hljs-keyword">while</span>(data[right] &gt; k &amp;&amp; right &gt; <span class="hljs-number">0</span>)right--;<br>        <span class="hljs-keyword">if</span>(left == right)<span class="hljs-keyword">return</span> data[left] == k;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &lt; right)<span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>定义左指针 $left$ ，右指针 $right$</p><p>向内收缩判断出现次数</p><p>注意当 $left == right$ 时，可能存在<code>目标元素</code>不存在数组里的情况，此时要判断指针所指的元素是否等于<code>目标元素</code></p><p><strong>二分法：</strong></p><p>当题目为排序数组时，首先应该想到二分法！</p><p>本题要求统计数字 $target$ 的出现次数，可转化为：使用二分法分别找到 左边界 $left$ 和 右边界 $right$ ，易得数字 $target$ 的数量为 $right - left - 1$ 。</p><blockquote><p>算法解析：</p></blockquote><ol><li>初始化： 左边界 $i = 0$ ，右边界 $j = nums.size() - 1$ 。</li><li>循环二分： 当闭区间 [i, j][i,j] 无元素时跳出；<ol><li>计算中点 $m = (i + j) /2$ （向下取整）；</li><li>若 $nums[m] &lt; target$ ，则 $target$ 在闭区间 [m + 1, j] 中，因此执行 $i = m + 1$；</li><li>若 $nums[m] &gt; target$ ，则 $target$ 在闭区间 [i, m - 1] 中，因此执行 $j = m - 1$ ;</li><li>若 $nums[m] = target$ ，则右边界 $right$ 在闭区间 [m+1, j] 中；左边界 $left$ 在闭区间 [i, m-1] 中。因此分为以下两种情况：<ol><li>若查找 右边界 $right$ ，则执行 $i = m + 1$ ；（跳出时 $i$ 指向右边界）</li><li>若查找 左边界 $left$ ，则执行 $j = m - 1$ ；（跳出时 $j$ 指向左边界）</li></ol></li></ol></li><li>返回值： 应用两次二分，分别查找 $right$ 和 $left$ ，最终返回 $right - left - 1$ 即可。</li></ol><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/b4521d9ba346cad9e382017d1abd1db2304b4521d4f2d839c32d0ecff17a9c0d-Picture1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m] &lt;= k) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> right = i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; data[j] != k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 搜索左边界 right</span><br>        i = <span class="hljs-number">0</span>, j = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m] &lt; k) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = j;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="三十八、二叉树的深度"><a href="#三十八、二叉树的深度" class="headerlink" title="三十八、二叉树的深度"></a>三十八、<a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的深度</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,#,<span class="hljs-number">6</span>,#,#,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1</p><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png"></p><p><strong>算法解析：</strong></p><ol><li>终止条件： 当 root 为空，说明已越过叶节点，因此返回 深度 0 。</li><li>递推工作： 本质上是对树做后序遍历。<ol><li>计算节点 root 的 左子树的深度 ，即调用 maxDepth(root.left)；</li><li>计算节点 root 的 右子树的深度 ，即调用 maxDepth(root.right)；</li></ol></li><li>返回值： 返回 此树的深度 ，即 max(maxDepth(root.left), maxDepth(root.right)) + 1。</li></ol><h2 id="三十九、平衡二叉树"><a href="#三十九、平衡二叉树" class="headerlink" title="三十九、平衡二叉树"></a>三十九、<a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">平衡二叉树</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p><p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>注：我们约定空树是平衡二叉树。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);<br><span class="hljs-keyword">if</span> (leftdepth == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);<br><span class="hljs-keyword">if</span> (rightdepth == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftdepth - rightdepth) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(pRoot) != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则“剪枝”，直接向上返回。</p><p><strong>算法流程：</strong></p><p><strong>getdepth(root) 函数：</strong></p><ul><li><p>返回值：</p><ol><li><p>当节点 <code>root</code> 左 / 右子树的深度差 $\leq 1$ ：则返回当前子树的深度，即节点 <code>root</code> 的左 / 右子树的深度最大值 $+1$ （ <code>max(left, right) + 1</code> ）；</p></li><li><p>当节点<code>root</code> 左 / 右子树的深度差 $&gt; 2$ ：则返回 $-1$ ，代表 <strong>此子树不是平衡树</strong> 。</p></li></ol></li><li><p>终止条件：</p><ol><li><p>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 $0$ ；</p></li><li><p>当左（右）子树深度为 $-1$ ：代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 $-1$ ；</p></li></ol></li></ul><p><strong>IsBalanced_Solution(root) 函数：</strong></p><p>返回值： 若 <code>getdepth(root) != -1</code> ，则说明此树平衡，返回 $true$ ； 否则返回 $false$ 。</p><h2 id="四十、数组中只出现一次的两个数字"><a href="#四十、数组中只出现一次的两个数字" class="headerlink" title="四十、数组中只出现一次的两个数字"></a>四十、<a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中只出现一次的两个数字</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>说明：</p><p>返回的结果中较小的数排在前面 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;map;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;ret;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>map[array[i]]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : map) &#123;<br><span class="hljs-keyword">if</span> (m.second == <span class="hljs-number">1</span>)ret.<span class="hljs-built_in">push_back</span>(m.first);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>常规做法：<strong>哈希表</strong></p><p>创建哈希表计算元素个数，再遍历哈希表找出个数为1的元素</p><p>方法二：<strong>位运算</strong></p><p><strong>算法流程：</strong></p><ol><li><p><strong>遍历 $nums$ 执行异或：</strong></p><ul><li>设整型数组 $nums = [a, a, b, b, …, x, y]$ ，对 $nums$ 中所有数字执行异或，得到的结果为 $ x \oplus y$ ，即：<br>$\begin{aligned} &amp; \ \ a \oplus a \oplus b \oplus b \oplus … \oplus x \oplus y \ = &amp; \ \ 0 \oplus 0 \oplus … \oplus x \oplus y \ = &amp; \ \ x \oplus y \end{aligned}$</li></ul></li><li><p><strong>循环左移计算 $m$ ：</strong></p></li></ol><ul><li>根据异或运算定义，若整数 $x \oplus y$ 某二进制位为 $1$ ，则 $x$ 和 $y$ 的此二进制位一定不同。换言之，找到 $x \oplus y$ 某为 $1$ 的二进制位，即可将数组 $nums$ 拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 $a$ 有：<ul><li><p>若 a &amp; 0001 = 1 ，则 $a$ 的第一位为 $1$ ；</p></li><li><p>若 a &amp; 0010 = 1 ，则 $a$ 的第二位为 $1$ ；</p></li><li><p>以此类推……</p></li></ul></li><li>因此，初始化一个辅助变量 $m = 1$ ，通过与运算从右向左循环判断，可获取整数 $x \oplus y$ 首位 $1$ ，记录于 $m$中</li></ul><ol start="3"><li><strong>拆分 $nums$ 为两个子数组：</strong></li><li><strong>分别遍历两个子数组执行异或：</strong><ul><li>通过遍历判断 $nums$ 中各数字和 $m$ 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字</li></ul></li><li><strong>返回值</strong>：<ul><li>返回只出现一次的数字 x, y 即可。</li></ul></li></ol><blockquote><p>设 nums = [3, 3, 4, 4, 1, 6] ，以上计算流程如下图所示。</p></blockquote><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/1614836837-oygHyk-Picture2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : array)         <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) == <span class="hljs-number">0</span>)         <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : array) &#123;       <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>(num &amp; m) x ^= num;   <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;          <span class="hljs-comment">// 4. 当 num &amp; m == 0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &lt; y)<span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;x, y&#125;;<span class="hljs-comment">// 5. 返回出现一次的数字</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;y, x&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序总结</title>
    <link href="/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h1><p><img src="/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png"></p><p>1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p><p>2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序</p><p>3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p><p>4、非原地排序：需要利用额外的数组来辅助排序。</p><p>5、时间复杂度：一个算法执行所消耗的时间。</p><p>6、空间复杂度：运行完一个算法所需的内存大小</p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。</p><p><strong>算法思想</strong>：</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ol><p><img src="/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/640"></p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; <span class="hljs-comment">//保存最大的位数</span><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= p)<br>            &#123;<br>                p *= <span class="hljs-number">10</span>;<br>                d++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">maxbit</span>(nums, n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> j, k;<br>        <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//进行d次排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= d; i++) &#123;<br>            <span class="hljs-comment">//每次分配前清空计数器</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                count[j] = <span class="hljs-number">0</span>; <br>            <span class="hljs-comment">//统计每个桶中的记录数</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                k = (nums[j] / radix) % <span class="hljs-number">10</span>; <br>                count[k]++;<br>            &#125;<br>            <span class="hljs-comment">//将tmp中的位置依次分配给每个桶,类似于计数排序</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                count[j] += count[j - <span class="hljs-number">1</span>]; <br>            <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>            <span class="hljs-keyword">for</span> (j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <br>            &#123;<br>                k = (nums[j] / radix) % <span class="hljs-number">10</span>;<br>                tmp[count[k] - <span class="hljs-number">1</span>] = nums[j];<br>                count[k]--;<br>            &#125;<br>            <span class="hljs-comment">//将临时数组的内容复制到nums中</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++) <br>                nums[j] = tmp[j];<br>            radix = radix * <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">radixsort</span>(nums, nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序</title>
    <link href="/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序可以说是<strong>插入排序的一种变种</strong>。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p><p>希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。</p><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p><img src="/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/111111.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellinsertsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> gap, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">int</span> inserted = nums[i];<br><span class="hljs-keyword">int</span> j = i - gap;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; inserted &lt; nums[j]) &#123;<br>nums[j + gap] = nums[j];<br>j -= gap;<br>&#125;<br>nums[j + gap] = inserted;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//进行分组，最开始的时候，gap为数组长度一半</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; n; i++) &#123;<br><span class="hljs-built_in">shellinsertsort</span>(nums, gap, i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br><span class="hljs-built_in">shellsort</span>(nums);<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序统计小于等于该元素值的元素的个数 $i$ ，于是该元素就放在目标数组的索引 $i$ 位（ $i≥0$ ）。</p><ul><li>计数排序基于一个假设，待排序数列的所有数均为<code>整数</code>，且出现在（0，k）的区间之内。</li><li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来<code>排序 0 到 100 之间的数字</code>的最好的算法，但是它不适合按字母顺序排序人名。</li><li>计数排序不是比较排序，<strong>排序的速度快于任何比较排序算法</strong>。</li></ul><p><strong>算法思想</strong>：</p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li><li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li></ol><p><img src="/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//使用nums的最大值 +1 作为计数容器countvec的大小</span><br><span class="hljs-keyword">int</span> vecSize = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">countvec</span>(vecSize, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//计算每个键值出现的次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>countvec[nums[i]]++;<br>&#125;<br><span class="hljs-comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vecSize; i++) &#123;<br>countvec[i] += countvec[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//将键值放到目标位置</span><br><span class="hljs-comment">//此处逆序是为了保持相同键值的稳定性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>res[--countvec[nums[i]]] = nums[i];<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;nums)</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">res</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">countsort</span>(nums, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 31-35</title>
    <link href="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/"/>
    <url>/2021/06/17/%E5%89%91%E6%8C%87offer31-35/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-31-35"><a href="#剑指offer-31-35" class="headerlink" title="剑指offer    31~35"></a>剑指offer    31~35</h1><h2 id="三十一、整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#三十一、整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="三十一、整数中1出现的次数（从1到n整数中1出现的次数）"></a>三十一、<a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">整数中1出现的次数（从1到n整数中1出现的次数）</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数<br>例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">13<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> digit = <span class="hljs-number">1</span>, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) ret += high * digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>) ret += high * digit + low + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> ret += high * digit + digit;<br>            low += cur * digit;<br>            cur = high % <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>将 1 ~ $n$ 的个位、十位、百位、…的 $1 $ 出现次数相加，即为 $1$ 出现的总次数。</p><p>设数字 $n$ 是个 $x$ 位数，记 $n$ 的第 $ i$ 位为 $n_i$ ，则可将 $n$ 写为 $n_{x} n_{x-1} \cdots n_{2} n_{1}$ ：</p><ul><li>称 “  $n_i$ “ 为当前位 ，记为 $cur$ ，</li><li>将 “ $n_{i-1} n_{i-2} \cdots n_{2} n_{1}$” 称为低位 ，记为 $low$ ；</li><li>将 “ $n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}$” 称为高位 ，记为 $high$ 。</li><li>将 $10^i$ 称为位因子 ，记为 $digit$ 。</li></ul><p><strong>某位中 11 出现次数的计算方法：</strong></p><p>根据当前位 $cur$ 值的不同，分为以下三种情况：</p><ol><li><p>当 $cur = 0$ 时： 此位 $1$ 的出现次数只由高位 $high$ 决定，计算公式为：$high \times digit$</p><p>如下图所示，以 $n = 2304$ 为例，求 $digit = 10$（即十位）的 $1$ 出现次数。</p></li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture1.png"></p><ol start="2"><li><p>当 $cur = 1$ 时： 此位 $1$ 的出现次数由高位 $high$ 和低位 $low$ 决定，计算公式为：$high \times digit + low + 1$ </p><p>如下图所示，以 $n = 2314$ 为例，求 $digit = 10$ （即十位）的 $1$ 出现次数。</p></li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture2.png"></p><ol start="3"><li>当 $cur = 2, 3, \cdots, 9$ 时： 此位 $1$ 的出现次数只由高位 $high$ 决定，计算公式为：$(high + 1) \times digit$<br>如下图所示，以 $n = 2324$ 为例，求 $digit = 10$ （即十位）的 $1$ 出现次数。</li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture3.png"></p><h2 id="三十二、把数组排成最小的数"><a href="#三十二、把数组排成最小的数" class="headerlink" title="三十二、把数组排成最小的数"></a>三十二、<a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把数组排成最小的数</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-number">321</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;321323&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; x, <span class="hljs-keyword">const</span> string&amp; y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y &lt; y + x;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        vector&lt;string&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : numbers) &#123;<br>            str.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(x));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), cmp);<br>        string ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : str) &#123;<br>            ret += s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 $numbers$ 中任意两数字的字符串为 $x$ 和 $y$ ，则规定 排序判断规则为：</p><ul><li><p>若拼接字符串 $x + y &gt; y + x$ ，则 $x$ “大于” $y$ ；</p></li><li><p>反之，若 $x + y &lt; y + x$ ，则 $x$ “小于” $y$ ；</p></li></ul><p>$x $ “小于” $y$ 代表：排序完成后，数组中 $x$ 应在 $y$ 左边；“大于” 则反之。</p><p>根据以上规则，套用任何排序方法对 $numbers$ 执行排序即可。</p><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture4.png"></p><h2 id="三十三、丑树"><a href="#三十三、丑树" class="headerlink" title="三十三、丑树"></a>三十三、<a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">丑树</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">8<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(index + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">1</span>, p3 = <span class="hljs-number">1</span>, p5 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= index; i++)&#123;<br>            <span class="hljs-keyword">int</span> num2 = dp[p2] * <span class="hljs-number">2</span>, num3 = dp[p3] * <span class="hljs-number">3</span>, num5 = dp[p5] * <span class="hljs-number">5</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(num2, num3), num5);<br>            <span class="hljs-keyword">if</span>(dp[i] == num2) p2++;<br>            <span class="hljs-keyword">if</span>(dp[i] == num3) p3++;<br>            <span class="hljs-keyword">if</span>(dp[i] == num5) p5++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>定义数组 $\textit{dp}$，其中 $\textit{dp}[i]$ 表示第 $i$ 个丑数，第 $n$ 个丑数即为 $\textit{dp}[n]$ 。</p><p>由于最小的丑数是 $1$，因此 $\textit{dp}[1]=1$ 。</p><p>如何得到其余的丑数呢？定义三个指针 $p_2$,$p_3$,$p_5$，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 $1$ 。</p><p>当 $2 \le i \le n$ 时，令 $\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)$，然后分别比较 $\textit{dp}[i]$ 和 $\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]$是否相等，如果相等则将对应的指针加 $1$。</p><h2 id="三十四、第一个只出现一次的字符"><a href="#三十四、第一个只出现一次的字符" class="headerlink" title="三十四、第一个只出现一次的字符"></a>三十四、<a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">第一个只出现一次的字符</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;google&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            mp[str[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[str[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>使用哈希表存储频数</strong></p><p>我们可以对字符串进行两次遍历。</p><p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。</p><p>在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符索引，否则在遍历结束后返回 $-1$ 。</p><h2 id="☆☆☆三十五、数组中的逆序对"><a href="#☆☆☆三十五、数组中的逆序对" class="headerlink" title="☆☆☆三十五、数组中的逆序对"></a>☆☆☆三十五、<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中的逆序对</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出 P % 1000000007</p><p>对于50%的数据, $size\leq 10^4$<br>对于100%的数据, $size\leq 10^5$</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>题目保证输入的数组中没有的相同的数字</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; data, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; tmp)</span> </span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//递归划分</span><br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">mergeSort</span>(l, mid, data, tmp);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">mergeSort</span>(mid + <span class="hljs-number">1</span>, r, data, tmp);<br>        <span class="hljs-comment">//合并阶段</span><br>        <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++)<br>            tmp[k] = data[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)<br>                data[k] = tmp[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == r + <span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j])<br>                data[k] = tmp[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                data[k] = tmp[j++];<br>                res = (res + (mid - i + <span class="hljs-number">1</span>)) % <span class="hljs-number">1000000007</span>; <span class="hljs-comment">// 统计逆序对</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (res + left + right) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(data.size())</span></span>;<br>        ret = <span class="hljs-built_in">mergeSort</span>(<span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, data, tmp);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>「归并排序」与「逆序对」是息息相关的</strong></p><p><strong>merge_sort( ) 归并排序与逆序对统计：</strong></p><ol><li>终止条件： 当 $l \geq r$ 时，代表子数组长度为 1 ，此时终止划分；</li><li>递归划分： 计算数组中点 $m$ ，递归划分左子数组 <code>merge_sort(l, m)</code> 和右子数组 <code>merge_sort(m + 1, r)</code> ；</li><li>合并与逆序对统计：<ol><li>暂存数组 $nums$ 闭区间 [i, r]内的元素至辅助数组 $tmp$ ；</li><li>循环合并： 设置双指针 $i$ , $j$ 分别指向左 / 右子数组的首元素；<ul><li>当 $i = m + 1$ 时： 代表左子数组已合并完，因此添加右子数组当前元素 $tmp[j]$ ，并执行 $j = j + 1$ ；</li><li>否则，当 $j=r+1$ 时： 代表右子数组已合并完，因此添加左子数组当前元素 $tmp[i]$ ，并执行 $i=i+1$ ；</li><li>否则，当 $tmp[i] \leq tmp[j]$ 时： 添加左子数组当前元素 $tmp[i]$ ，并执行 $i = i + 1$；</li><li>否则（即 $tmp[i] &gt; tmp[j]$）时： 添加右子数组当前元素 $tmp[j]$ ，并执行 $j = j + 1$ ；此时构成 $m−i+1$ 个「逆序对」，统计添加至 $res$ ；</li></ul></li></ol></li><li>返回值： 返回直至目前的逆序对总数 $res$ ；</li></ol><p><strong>InversePairs() 主函数：</strong></p><ol><li>初始化： 辅助数组 $tmp$ ，用于合并阶段暂存元素；</li><li>返回值： 执行归并排序 merge_sort() ，并返回逆序对总数即可；</li></ol><p>如下图所示，为数组 [7, 3, 2, 6, 0, 1, 5, 4] 的归并排序与逆序对统计过程。</p><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture5.png"></p>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 26-30</title>
    <link href="/2021/06/16/%E5%89%91%E6%8C%87offer26-30/"/>
    <url>/2021/06/16/%E5%89%91%E6%8C%87offer26-30/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-26-30"><a href="#剑指offer-26-30" class="headerlink" title="剑指offer    26~30"></a>剑指offer    26~30</h1><h2 id="☆二十六、二叉搜索树与双向链表"><a href="#☆二十六、二叉搜索树与双向链表" class="headerlink" title="☆二十六、二叉搜索树与双向链表"></a>☆二十六、<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树与双向链表</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p><p><img src="/2021/06/16/%E5%89%91%E6%8C%87offer26-30/1.jpg"></p><p>注意:</p><ol><li>要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继</li><li>返回链表中的第一个节点的指针</li><li>函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构</li><li>你不用输出或者处理，示例中输出里面的英文，比如”From left to right are:”这样的，程序会根据你的返回值自动打印输出</li></ol><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">From</span> left to right are:<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>;From right to left are:<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        vector&lt;TreeNode*&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (pRootOfTree != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(pRootOfTree);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            result[i + <span class="hljs-number">1</span>]-&gt;left = result[i];<br>            result[i]-&gt;right = result[i + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>采用<strong>代码随想录</strong>中<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484687&idx=1&sn=85cd297b3c9927467e4048b1f50aa938&scene=21#wechat_redirect">二叉树遍历模板</a>，将二叉搜索树中序遍历后，这样在数组中节点就按顺序保存了，然后再来修改指针。</p><h2 id="二十七、字符串的排列"><a href="#二十七、字符串的排列" class="headerlink" title="二十七、字符串的排列"></a>二十七、<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">字符串的排列</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;ab&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    string cur;<br>    vector&lt;string&gt;res;<br>    set&lt;string&gt;store;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string&amp; str,vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;<br>            store.<span class="hljs-built_in">insert</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            cur += str[i];<br>            <span class="hljs-built_in">backtracking</span>(str, used);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt;<span class="hljs-built_in">used</span>(str.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtracking</span>(str, used);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : store) res.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>采用<code>回溯</code>的方法</p><p>因为要按字典序输出，先把结果存在<code>set容器</code>中，再从set中取到vector</p><p>用一个used判断字符是否使用</p><h2 id="二十八、数组中出现次数超过一半的数字"><a href="#二十八、数组中出现次数超过一半的数字" class="headerlink" title="二十八、数组中出现次数超过一半的数字"></a>二十八、<a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中出现次数超过一半的数字</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1&lt;=数组长度&lt;=50000</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> numbers[numbers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>先给数组排序，返回数组中位数就是数组中出现次数超过一半的数字</p><p><strong>方法二：哈希表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;mp;<br>        <span class="hljs-keyword">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : numbers) &#123;<br>            mp[x]++;<br>            <span class="hljs-keyword">if</span> (mp[x] &gt; n / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二十九、最小的K个数"><a href="#二十九、最小的K个数" class="headerlink" title="二十九、最小的K个数"></a>二十九、<a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">最小的K个数</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">4,5,1,6</span>,<span class="hljs-number">2,7,3,8</span>],<span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt; k) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : input) &#123;<br>            q.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>构造一个小顶堆的优先队列priority_queue&lt;int, vector&lt; int &gt;, greater&lt; int &gt;&gt; q</p><p>一般遇到最小或最大的K个数优先想到使用优先队列</p><h2 id="三十、连续子数组的最大和"><a href="#三十、连续子数组的最大和" class="headerlink" title="三十、连续子数组的最大和"></a>三十、<a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">连续子数组的最大和</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-5</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">18<br></code></pre></td></tr></table></figure><p>说明：输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4,7,2}，因此输出为该子数组的和 18。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(array.<span class="hljs-built_in">size</span>());<br>        dp[<span class="hljs-number">0</span>] = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + array[i], array[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>动态规划解析：</strong></p><ul><li><p>状态定义： 设动态规划列表 $dp$ ，$dp[i]$ 代表以元素 $array[i]$ 为结尾的连续子数组最大和。</p><ul><li>为何定义最大和 $dp[i]$ 中必须包含元素 $array[i]$ ：保证 $dp[i]$ 递推到 $dp[i+1]$ 的正确性；如果不包含 $array[i]$ ，递推时则不满足题目的 连续子数组 要求。</li></ul></li><li><p>转移方程： 若 $dp[i-1] \leq 0$ ，说明 $dp[i - 1]$ 对 $dp[i]$ 产生负贡献，即 $dp[i-1] + array[i]$] 还不如 $array[i]$ 本身大。</p><ul><li>当 $dp[i - 1] &gt; 0$ 时：执行 $dp[i] = dp[i-1] + array[i]$ ；</li><li>当 $dp[i - 1] \leq 0$ 时：执行 $dp[i] = array[i]$ ；</li></ul></li><li><p>初始状态： $dp[0] = array[0]$，即以 $array[0]$ 结尾的连续子数组最大和为 $array[0]$ 。</p></li><li><p>返回值： 返回 $dp$ 列表中的最大值，代表全局最大值。</p></li></ul><p><img src="/2021/06/16/%E5%89%91%E6%8C%87offer26-30/2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 智能指针</title>
    <link href="/2021/06/15/c++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2021/06/15/c++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="六、智能指针"><a href="#六、智能指针" class="headerlink" title="六、智能指针"></a>六、智能指针</h1><p>c++的<code>内存管理</code>，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过c++11引入的<code>智能指针</code>来解决。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p><h2 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h3><p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p><ul><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li><li>每次创建类的新对象时，初始化指针并将引用计数置为1</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li><li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li></ul><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClassWrapper</span> &#123;</span><br>    <span class="hljs-built_in">ClassWrapper</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct&quot;</span> &lt;&lt; endl;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    &#125;<br>    ~<span class="hljs-built_in">ClassWrapper</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;print&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">int</span>* data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(std::shared_ptr&lt;ClassWrapper&gt; ptr)</span> </span>&#123;<br>    ptr-&gt;<span class="hljs-built_in">Print</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> smart_ptr = std::make_shared&lt;ClassWrapper&gt;();<br>    <span class="hljs-keyword">auto</span> ptr2 = smart_ptr; <span class="hljs-comment">// 引用计数+1</span><br>    ptr2-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-built_in">Func</span>(smart_ptr); <span class="hljs-comment">// 引用计数+1</span><br>    smart_ptr-&gt;<span class="hljs-built_in">Print</span>();<br>    ClassWrapper *p = smart_ptr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 可以通过get获取裸指针</span><br>    p-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">construct<br>print<br>print<br>print<br>print<br>deconstruct<br></code></pre></td></tr></table></figure><p>智能指针还可以自定义删除器，在引用计数为0的时候自动调用删除器来释放对象的内存，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>, [](<span class="hljs-keyword">int</span> *p)&#123; <span class="hljs-keyword">delete</span> p; &#125;)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>关于shared_ptr有几点需要注意：</strong></p><p>• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃</p><p>• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能会导致重复析构，不能把this指针交给智能指针管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">GetSelf</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>       <span class="hljs-comment">// return shared_ptr&lt;A&gt;(this); 错误，会导致double free</span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>尽量使用make_shared，少用new。</li><li>不要delete get()返回来的裸指针。</li><li>不是new出来的空间要自定义删除器。</li><li>要避免<code>循环引用</code>，循环引用导致内存永远不会被释放，造成内存泄漏。</li></ul><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   std::shared_ptr&lt;B&gt; bptr;<br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span><br>   std::shared_ptr&lt;A&gt; aptr;<br>   ~<span class="hljs-built_in">B</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;B delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> aaptr = std::make_shared&lt;A&gt;();<br>   <span class="hljs-keyword">auto</span> bbptr = std::make_shared&lt;B&gt;();<br>   aaptr-&gt;bptr = bbptr;<br>   bbptr-&gt;aptr = aaptr;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码，产生了循环引用，导致aptr和bptr的引用计数为2，离开作用域后aptr和bptr的引用计数-1，但是永远不会为0，导致指针永远不会析构，产生了内存泄漏，如何解决这种问题呢，答案是使用weak_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><strong>weak_ptr</strong></h3><p>weak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝和析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。</p><ul><li>作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针；</li><li>作用2：解决循环引用问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   std::shared_ptr&lt;B&gt; bptr;<br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span><br>   std::weak_ptr&lt;A&gt; aptr; <span class="hljs-comment">// 这里改成weak_ptr</span><br>   ~<span class="hljs-built_in">B</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;B delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (!aptr.<span class="hljs-built_in">expired</span>()) &#123; <span class="hljs-comment">// 监视shared_ptr的生命周期</span><br>           <span class="hljs-keyword">auto</span> ptr = aptr.<span class="hljs-built_in">lock</span>();<br>           ptr-&gt;<span class="hljs-built_in">Print</span>();<br>      &#125;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> aaptr = std::make_shared&lt;A&gt;();<br>   <span class="hljs-keyword">auto</span> bbptr = std::make_shared&lt;B&gt;();<br>   aaptr-&gt;bptr = bbptr;<br>   bbptr-&gt;aptr = aaptr;<br>   bbptr-&gt;<span class="hljs-built_in">PrintA</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">delete</span><br><span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">delete</span><br></code></pre></td></tr></table></figure><p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h3><p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p><p>unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> ptr = std::unique_ptr&lt;A&gt;(<span class="hljs-keyword">new</span> A);<br>   <span class="hljs-keyword">auto</span> tptr = std::make_unique&lt;A&gt;(); <span class="hljs-comment">// error, c++11还不行，需要c++14</span><br>   std::unique_ptr&lt;A&gt; tem = ptr; <span class="hljs-comment">// error, unique_ptr不允许移动</span><br>   ptr-&gt;<span class="hljs-built_in">Print</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><strong>auto_ptr</strong></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p><p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p><p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p><ol><li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li><li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li><li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li><li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li><li>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li><li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li><li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li><li>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</li></ol><h2 id="手写实现智能指针类需要实现哪些函数？"><a href="#手写实现智能指针类需要实现哪些函数？" class="headerlink" title="手写实现智能指针类需要实现哪些函数？"></a>手写实现智能指针类需要实现哪些函数？</h2><ol><li><p>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</p><p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p><p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p></li><li><p>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : c++11新特性之智能指针(<a href="https://mp.weixin.qq.com/s/Aujdxj3k_apNwW9Cnd3_eg">https://mp.weixin.qq.com/s/Aujdxj3k_apNwW9Cnd3_eg</a>)</p><p>[ 2 ] : 阿秀的学习笔记 (interviewguide.cn)(<a href="https://interviewguide.cn/#/Doc/Knowledge/C++/C++11%E6%96%B0%E6%A0%87%E5%87%86/C++11%E6%96%B0%E6%A0%87%E5%87%86">https://interviewguide.cn/#/Doc/Knowledge/C++/C++11新标准/C++11新标准</a>)</p><p>[ 3 ] : 搞定技术面试：C++ 11 智能指针详解 (juejin.cn)(<a href="https://juejin.cn/post/6844903993055920141#heading-16">https://juejin.cn/post/6844903993055920141#heading-16</a>)</p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 21-25</title>
    <link href="/2021/06/15/%E5%89%91%E6%8C%87offer21-25/"/>
    <url>/2021/06/15/%E5%89%91%E6%8C%87offer21-25/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-21-25"><a href="#剑指offer-21-25" class="headerlink" title="剑指offer    21~25"></a>剑指offer    21~25</h1><h2 id="二十一、栈的压入、弹出序列"><a href="#二十一、栈的压入、弹出序列" class="headerlink" title="二十一、栈的压入、弹出序列"></a>二十一、<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">栈的压入、弹出序列</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4,3,5,1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pushV,vector&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : pushV) &#123;<br>            st.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popV[i]) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>借助一个辅助栈</p><p><strong>算法流程：</strong></p><ol><li><p>初始化： 辅助栈 stack ，弹出序列的索引 $i$ ；</p></li><li><p>遍历压栈序列： 各元素记为 $num$ ；</p><ol><li><p>元素 $num$ 入栈；</p></li><li><p>循环出栈：若 stack 的栈顶元素 == 弹出序列元素 $popV[i]$ ，则执行出栈与 $i++$ ；</p></li></ol></li><li><p>返回值： 若 stack 为空，则此弹出序列合法。</p></li></ol><h2 id="二十二、从上往下打印二叉树"><a href="#二十二、从上往下打印二叉树" class="headerlink" title="二十二、从上往下打印二叉树"></a>二十二、<a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">从上往下打印二叉树</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,#,<span class="hljs-number">3</span>,#,<span class="hljs-number">2</span>,#,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;();<br>        queue&lt;TreeNode*&gt;q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        TreeNode *node = <span class="hljs-literal">nullptr</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>算法流程：</strong></p><ol><li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li><li>初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li><li>BFS 循环： 当队列 queue 为空时跳出；<ol><li>出队： 队首元素出队，记为 node；</li><li>打印： 将 node.val 添加至列表 res 尾部；</li><li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li></ol></li><li>返回值： 返回打印结果列表 res 即可。</li></ol><h2 id="☆☆二十三、二叉搜索树的后序遍历序列"><a href="#☆☆二十三、二叉搜索树的后序遍历序列" class="headerlink" title="☆☆二十三、二叉搜索树的后序遍历序列"></a>☆☆二十三、<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉搜索树的后序遍历序列</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; sequence, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> root = sequence[end];<span class="hljs-comment">//根节点</span><br>        <span class="hljs-keyword">int</span> pos = start;<br>        <span class="hljs-keyword">for</span> (; pos &lt; end; pos++) &#123;<br>            <span class="hljs-comment">//右子树全部大于根节点，找到第一个大于根节点的元素，那么在他之前都是左子树，之后都是右子树</span><br>            <span class="hljs-keyword">if</span>(sequence[pos] &gt; root) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = pos; j &lt; end; j++) &#123;<br>            <span class="hljs-keyword">if</span>(sequence[j] &lt; root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//右子树必须全部大于根，否则返回false</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(sequence, start, pos - <span class="hljs-number">1</span>) <span class="hljs-comment">//判断左子树</span><br>            &amp;&amp; <span class="hljs-built_in">recur</span>(sequence, pos, end - <span class="hljs-number">1</span>);<span class="hljs-comment">//判断右子树</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>递归解析：</strong></p><ul><li><p>终止条件： 当 $start \geq end$ ，说明此子树节点数量 $\leq 1$ ，无需判别正确性，因此直接返回 $true$ ；</p></li><li><p>递推工作：</p><ol><li><p>划分左右子树： 遍历后序遍历的 $[start, end]$ 区间元素，寻找第一个大于根节点的节点，索引记为 $pos$ 。此时，可划分出左子树区间 $[start,pos-1]$ 、右子树区间 $[pos, end - 1]$ 、根节点索引 $end$ 。</p></li><li><p>判断是否为二叉搜索树：</p><ul><li><p>左子树区间 $[start, pos - 1]$ 内的所有节点都应 $&lt;sequence[end]$ 。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p></li><li><p>右子树区间 $[pos, end-1]$ 内的所有节点都应 $&gt; sequence[end]$ 。实现方式为遍历，当遇到 $\leq sequence[end]$ 的节点则返回 $false$ 。</p></li></ul></li></ol></li><li><p>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp; 连接。</p><ol><li>$recur(start, pos - 1)$ ： 判断 此树的左子树是否正确。</li><li>$recur(pos, end - 1)$ ： 判断 此树的右子树是否正确。</li></ol></li></ul><h2 id="二十四、二叉树中和为某一值的路径"><a href="#二十四、二叉树中和为某一值的路径" class="headerlink" title="二十四、二叉树中和为某一值的路径"></a>二十四、<a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树中和为某一值的路径</a></h2><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">10,5,12,4</span>,<span class="hljs-number">7</span>&#125;,<span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">10,5,12,4</span>,<span class="hljs-number">7</span>&#125;,<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;path;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;ret;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        target -= root-&gt;val;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            ret.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">backtracking</span>(root-&gt;left, target);<br>        <span class="hljs-built_in">backtracking</span>(root-&gt;right, target);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">FindPath</span>(TreeNode* root,<span class="hljs-keyword">int</span> expectNumber) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        ret.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(root, expectNumber);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析:</p></blockquote><p><strong>算法流程：</strong></p><p><strong>$FindPath(root, expectNumber)$ 函数：</strong></p><ul><li><p>初始化： 结果列表 $ret$ ，路径列表 $path$ 。</p></li><li><p>返回值： 返回 $ret$ 即可。</p></li></ul><p><strong>$backtracking(root, target)$ 函数：</strong></p><ul><li>递推参数： 当前节点 $root$ ，当前目标值 $target$ 。</li><li>终止条件： 若节点 $root$ 为空，则直接返回。</li><li>递推工作：<ol><li>路径更新： 将当前节点值 $root.val$ 加入路径 $path$ ；</li><li>目标值更新： $target = target - root.val$（即目标值 $target$ 从 $expectNumber$ 减至 0 ）；</li><li>路径记录： 当 ① $root$ 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 $path$ 加入 $ret$ 。</li><li>先序遍历： 递归左 / 右子节点。</li><li>路径恢复： 向上回溯前，需要将当前节点从路径 $path$ 中删除，即执行 path.pop_back() 。</li></ol></li></ul><h2 id="二十五、复杂链表的复制"><a href="#二十五、复杂链表的复制" class="headerlink" title="二十五、复杂链表的复制"></a>二十五、<a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">复杂链表的复制</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p><img src="/2021/06/15/%E5%89%91%E6%8C%87offer21-25/e1.png" alt="img"></p><p>输入：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        RandomListNode* node = pHead;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            RandomListNode* clonenode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(node-&gt;label);<br>            clonenode-&gt;next = node-&gt;next;<br>            node-&gt;next = clonenode;<br>            node = clonenode-&gt;next;<br>        &#125;<br>        node = pHead;<br>        RandomListNode* clonehead = node-&gt;next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;random != <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;next-&gt;random = node-&gt;random-&gt;next;<br>            &#125;<br>            node = node-&gt;next-&gt;next;<br>        &#125;<br>        node = pHead;<br>        RandomListNode* clonenode = clonehead;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node-&gt;next-&gt;next;<br>            node = node-&gt;next;<br>            <span class="hljs-keyword">if</span> (clonenode-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>                clonenode-&gt;next = clonenode-&gt;next-&gt;next;<br>                clonenode = clonenode-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> clonehead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>方法一：拼接 + 拆分</strong><br>考虑构建 <code>原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; ……</code> 的拼接链表，如此便可在访问原节点的 <code>random</code> 指向节点的同时找到新对应新节点的 <code>random</code> 指向节点。</p><p><strong>算法流程：</strong></p><ol><li><p>复制各节点，构建拼接链表:</p><ul><li>设原链表为 $node1 \rightarrow node2 \rightarrow \cdots$ ，构建的拼接链表如下所示：<br>$<br>node1 \rightarrow node1_{clone} \rightarrow node2 \rightarrow node2_{clone} \rightarrow \cdots<br>$</li></ul></li><li><p>构建新链表各节点的 <code>random</code> 指向：</p><ul><li>当访问原节点 <code>node</code> 的随机指向节点 <code>node.random</code> 时，对应新节点 <code>node.next</code> 的随机指向节点为 <code>node.random.next</code> 。</li></ul></li><li><p>拆分原 / 新链表：</p><ul><li>设置 <code>node</code> / <code>clonenode</code> 分别指向原 / 新链表头节点，遍历执行 <code>node.next = node.next.next</code> 和 <code>clonenode.next = clonenode.next.next</code> 将两链表拆分开。</li></ul></li><li><p>返回新链表的头节点 <code>clonehead</code> 即可。</p></li></ol><p>需要三次遍历链表</p><p><strong>方法二：哈希表</strong></p><p>利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。</p><p><strong>算法流程：</strong></p><ol><li>若头节点 head 为空节点，直接返回 null ；</li><li>初始化： 哈希表 dic ， 节点 cur 指向头节点；</li><li>复制链表：<ol><li>建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li>构建新链表的引用指向：<ol><li>构建新节点的 next 和 random 引用指向；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li>返回值： 新链表的头节点 dic[head] ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        unordered_map&lt;RandomListNode*, RandomListNode*&gt;dic;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        RandomListNode* cur = pHead;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            dic[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur = pHead;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            dic[cur]-&gt;next = dic[cur-&gt;next];<br>            dic[cur]-&gt;random = dic[cur-&gt;random];<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dic[pHead];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 16-20</title>
    <link href="/2021/06/12/%E5%89%91%E6%8C%87offer16-20/"/>
    <url>/2021/06/12/%E5%89%91%E6%8C%87offer16-20/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-16-20"><a href="#剑指offer-16-20" class="headerlink" title="剑指offer    16~20"></a>剑指offer    16~20</h1><h2 id="十六、合并两个排序的链表"><a href="#十六、合并两个排序的链表" class="headerlink" title="十六、合并两个排序的链表"></a>十六、<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&&tqId=11169&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">合并两个排序的链表</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,3,5&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2,4,6&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span> (pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead1;<br>        ListNode* node;<br>        <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>            node = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            node = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>        ListNode* cur = node;<br>        <span class="hljs-keyword">while</span>(pHead1 &amp;&amp; pHead2) &#123;<br>            <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>                cur-&gt;next = pHead1;<br>                pHead1 = pHead1-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = pHead2;<br>                pHead2 = pHead2-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        cur-&gt;next = (pHead1 ? pHead1:pHead2);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>先把最小的值放在头结点，之后循环比较 $pHead1$ 和 $pHead2$ ，小的放进链表。</p><p>注意每次放进链表后，$cur=cur-&gt;next$ </p><p>另一种递归版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span> (pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead1;<br>        <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>            pHead1-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1-&gt;next, pHead2);<br>            <span class="hljs-keyword">return</span> pHead1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            pHead2-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1, pHead2-&gt;next);<br>            <span class="hljs-keyword">return</span> pHead2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="☆十七、树的子结构"><a href="#☆十七、树的子结构" class="headerlink" title="☆十七、树的子结构"></a>☆十七、<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">树的子结构</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,#,<span class="hljs-number">9</span>,#,<span class="hljs-number">2</span>,#,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,#,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; <span class="hljs-built_in">recur</span>(pRoot1-&gt;right, pRoot2-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot1, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>recur</strong>(A, B) 函数：</p><ol><li>终止条件：<ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；<br>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li></ol><p><strong>HasSubtree</strong>(A, B) 函数：</p><ol><li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false；</li><li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol><li>以 节点 A 为根节点的子 包含树 B ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 HasSubtree(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 HasSubtree(A.right, B)；</li></ol></li></ol><h2 id="十八、二叉树的镜像"><a href="#十八、二叉树的镜像" class="headerlink" title="十八、二叉树的镜像"></a>十八、<a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的镜像</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>比如：    </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> 源二叉树 <br>    <span class="hljs-number">8</span><br>   /  <span class="hljs-string">\</span><br>  <span class="hljs-number">6</span>   <span class="hljs-number">10</span><br> / <span class="hljs-string">\</span>  / <span class="hljs-string">\</span><br><span class="hljs-number">5</span>   <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span><br> 镜像二叉树<br>    <span class="hljs-number">8</span><br>   /  <span class="hljs-string">\</span><br>  <span class="hljs-number">10</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span>  / <span class="hljs-string">\</span><br><span class="hljs-number">11</span>  <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">11</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        stack&lt;TreeNode*&gt;s;<br>        s.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>辅助栈（或队列）</strong></p><ul><li>利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点</li></ul><p>算法流程：</p><ol><li>特例处理： 当 root 为空时，直接返回 null ；</li><li>初始化： 栈（或队列），本文用栈，并加入根节点 root 。</li><li>循环交换： 当栈 stack 为空时跳出；</li><li>出栈： 记为 node ；</li><li>添加子节点： 将 node 左和右子节点入栈；</li><li>交换： 交换 node 的左 / 右子节点。</li><li>返回值： 返回根节点 root 。</li></ol><h2 id="十九、顺时针打印矩阵"><a href="#十九、顺时针打印矩阵" class="headerlink" title="十九、顺时针打印矩阵"></a>十九、<a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">顺时针打印矩阵</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],<br>[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]]<br></code></pre></td></tr></table></figure><p>则依次打印出数字</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = left; j &lt;= right; j++)&#123;<br>                ret.<span class="hljs-built_in">push_back</span>(matrix[top][j]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top + <span class="hljs-number">1</span>; i &lt;= bottom; i++)&#123;<br>                ret.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = right - <span class="hljs-number">1</span>; j &gt; left; j--)&#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(matrix[bottom][j]);<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt; top; i--)&#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>按层模拟</p><p>可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。</p><p>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 $(\textit{top}, \textit{left} )$，右下角位于$ (\textit{bottom}, \textit{right})$，按照如下顺序遍历当前层的元素。</p><ol><li>从左到右遍历上侧元素，依次为 $(\textit{top}, \textit{left})$到 $(\textit{top}, \textit{right})$。</li><li>从上到下遍历右侧元素，依次为 $(\textit{top} + 1, \textit{right})$到 $(\textit{bottom}, \textit{right})$。</li><li>如果 $\textit{left} &lt; \textit{right}$ 且 $\textit{top} &lt; \textit{bottom}$，则从右到左遍历下侧元素，依次为 $(\textit{bottom}, \textit{right} - 1)$ 到 $(\textit{bottom}, \textit{left} + 1)$，以及从下到上遍历左侧元素，依次为 $(\textit{bottom}, \textit{left})$ 到 $(\textit{top} + 1, \textit{left})$。</li></ol><p>遍历完当前层的元素之后，将 $\textit{left}$ 和 $\textit{top}$ 分别增加 1，将 $\textit{right}$ 和 $\textit{bottom}$ 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p><h2 id="二十、包含min函数的栈"><a href="#二十、包含min函数的栈" class="headerlink" title="二十、包含min函数的栈"></a>二十、<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">包含min函数的栈</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$ ）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; minst;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        st.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(minst.<span class="hljs-built_in">empty</span>()) minst.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> minst.<span class="hljs-built_in">push</span>(value &lt; minst.<span class="hljs-built_in">top</span>() ? value : minst.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        minst.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minst.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>普通栈的 push() 和 pop() 函数的复杂度为 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) </p><p><strong>本题难点：</strong> 将 min() 函数复杂度降为 O(1) ，可通过建立<code>辅助栈</code>实现；</p><ul><li><p>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</p></li><li><p>辅助栈 B ： 栈 B 中存储栈 A 中所有非严格降序的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</p></li></ul><p>因此，只需设法维护好栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1) 复杂度。</p><p><strong>函数设计：</strong></p><p>push(value) 函数： 重点为保持栈 B 的元素是非严格降序的。</p><ol><li><p>将 value 压入栈 A （即 A.push(value) ）；</p></li><li><p>① 若栈 B 为空，说明是第一个元素，直接将 value 压入栈 B （即 B.push(value) ）</p><p>② value 与 栈 B 的栈顶元素比较，则将 小的那个 压入栈 B （即 B.push(value &lt; B.top() ? value : B.top())）。</p></li></ol><p>pop() 函数： 重点为保持栈 A, B 的元素一致性 。</p><ol><li>执行栈 A 出栈（即 A.pop()）；</li><li>执行栈 B 出栈（即 B.pop()）。</li></ol><p>top() 函数： 直接返回栈 A 的栈顶元素即可，即返回 A.top() 。</p><p>min() 函数： 直接返回栈 B 的栈顶元素即可，即返回 B.top() 。</p>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 11-15</title>
    <link href="/2021/06/10/%E5%89%91%E6%8C%87offer11-15/"/>
    <url>/2021/06/10/%E5%89%91%E6%8C%87offer11-15/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-11-15"><a href="#剑指offer-11-15" class="headerlink" title="剑指offer    11~15"></a>剑指offer    11~15</h1><h2 id="十一、二进制中1的个数"><a href="#十一、二进制中1的个数" class="headerlink" title="十一、二进制中1的个数"></a>十一、<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二进制中1的个数</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>         <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>             n= (n &amp; n - <span class="hljs-number">1</span>);<br>             res++;<br>         &#125;<br>         <span class="hljs-keyword">return</span> res;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>一刷在LeetCode上，给的格式是uint32_t。当时写的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n) &#123;<br>ret += (n &amp; <span class="hljs-number">1</span>);<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当时想法是循环取 $n$ 的最后一位，是 $1$ 就 $ret$ 加一。</p><p>二刷牛客网给的类型是 int</p><p>思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有高位将不会受到影响。</p><p><strong>举个例子</strong>：一个二进制数 $1100$，从左边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是 $1011$ 。我们发现减1的结果是把最右边的一个1开始的所有位都取反了。</p><p>这个时候如果我们再把原来的整数和减去1之后的结果做&amp;运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100 &amp; 1011 = 1000 。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><h2 id="十二、数值的整数次方"><a href="#十二、数值的整数次方" class="headerlink" title="十二、数值的整数次方"></a>十二、<a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数值的整数次方</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</p><p>保证 base 和 exponent 不同时为 0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面 0 的位数。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00000</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>.<span class="hljs-number">00000</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">10000</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">9</span>.<span class="hljs-number">26100</span><br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00000</span>,-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">25000</span><br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>的-<span class="hljs-number">2</span>次方等于<span class="hljs-number">1</span>/<span class="hljs-number">4</span>=<span class="hljs-number">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>) &#123;<br>            base = <span class="hljs-number">1</span> / base;<br>            exponent = - exponent;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(exponent &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(exponent &amp; <span class="hljs-number">1</span>)&#123;<br>                res *= base;<br>            &#125;<br>            base *= base;<br>            exponent &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>快速幂算法</p><p>快速幂实际上是二分思想的一种应用。</p><ul><li><p>二分推导： $x^n = x^{n/2} \times x^{n/2} = (x^2)^{n/2}$ ，令 $n/2$ 为整数，则需要分为奇偶两种情况（设向下取整除法符号为 “//“ ）：</p><ul><li>当 $n$ 为偶数： $x^n = (x^2)^{n//2}$ ；</li><li>当 $n$ 为奇数： $x^n = x(x^2)^{n//2}$ ，即会多出一项 $x$ ；</li></ul></li><li><p>幂结果获取：</p><ul><li>根据二分推导，可通过循环 $x = x^2$ 操作，每次把幂从 $n$ 降至 $n//2$ ，直至将幂降为 $0$ ；</li><li>设 $res=1$ ，则初始状态 $x^n = x^n \times res$x 。在循环二分时，每当 $n$ 为奇数时，将多出的一项 $x$ 乘入 $res$ ，则最终可化至 $x^n = x^0 \times res = res$ ，返回 $res$ 即可。</li></ul></li></ul><p><img src="/2021/06/10/%E5%89%91%E6%8C%87offer11-15/1.png" alt="Picture2.png"></p><ul><li><p>转化为位运算：</p><ul><li><p>向下整除 $n // 2$ 等价于右移一位 $n &gt;&gt; 1$ ；</p></li><li><p>取余数 $n % 2$ 等价于判断二进制最右一位值 n &amp; 1​；</p></li></ul></li></ul><p><code>算法流程：</code></p><ol><li>当 $x = 0$ 时：直接返回 $0$ （避免后续 $x = 1 / x$ 操作报错）。</li><li>初始化 $res = 1$ ；</li><li>当 $n &lt; 0$ 时：把问题转化至 $n \geq 0$ 的范围内，即执行 $x = 1/x$，$n = - n$ ；</li><li>循环计算：当 $n = 0$ 时跳出；<ol><li>当 n &amp; 1 = 1 时：将当前 $x$ 乘入 $res$ （即 $res *= x$ ）；</li><li>执行 $x = x^2$（即 $x *= x$ ）；</li><li>执行 $n$ 右移一位（即 $n &gt;&gt;= 1$）。</li></ol></li><li>返回 $res$ 。</li></ol><p><code>复杂度分析：</code></p><p>时间复杂度 $O(log_2 n)$ ：二分的时间复杂度为对数级别。</p><p>空间复杂度 $O(1)$ ：$ res$ 变量占用常数大小额外空间。</p><p>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></p><h2 id="☆十三、调整数组顺序使奇数位于偶数前面"><a href="#☆十三、调整数组顺序使奇数位于偶数前面" class="headerlink" title="☆十三、调整数组顺序使奇数位于偶数前面"></a>☆十三、<a href="https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">调整数组顺序使奇数位于偶数前面</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = array.<span class="hljs-built_in">size</span>(),evenIndex = <span class="hljs-number">0</span>,oddIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> array;        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ( (array[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)  array[oddIndex++] = array[i];<br>            <span class="hljs-keyword">else</span>&#123;<br>                temp[evenIndex++] = array[i];<span class="hljs-comment">//将偶数另外保存起来</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; evenIndex; ++j) &#123;<br>            array[j + oddIndex] = temp[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>开辟一个新的数组空间 $temp$，从前往后遍历数组 $array$ ,遇到偶数就存到 $temp$ 里，最后将 $temp$ 接在 $array$ 之后</p><ul><li>下面是另一种方法（在牛客上超时）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len - <span class="hljs-number">1</span>; j &gt; i; --j) &#123;<br>                <span class="hljs-keyword">if</span> ( (array[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; (array[j - <span class="hljs-number">1</span>] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">swap</span>(array[j], array[j - <span class="hljs-number">1</span>]);    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从后向前进行修正，类似于冒泡法。遇到先偶后奇的情况时，就交换。把奇数放到前面去，空间复杂度为$O(1)$ 。不知道为什么超时，可能是时间复杂度 $O(n^2)$ 的缘故</p><ul><li>LeetCode上没有保证奇数和奇数，偶数和偶数之间的相对位置不变的条件，一刷的时候使用了<code>双指针</code>的写法，代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//双指针</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">if</span> ((nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>left++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> ((nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>right--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>left++;<br>right--;<br>&#125;<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="十四、链表中倒数最后-k-个结点"><a href="#十四、链表中倒数最后-k-个结点" class="headerlink" title="十四、链表中倒数最后 $k$ 个结点"></a>十四、<a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">链表中倒数最后 $k$ 个结点</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第 $k$ 个结点至尾节点的全部节点。</p><p>如果该链表长度小于 $k$，请返回一个长度为 0 的链表。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = pHead;<br>        <span class="hljs-keyword">while</span>(k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(pHead != <span class="hljs-literal">nullptr</span>) pHead = pHead-&gt;next;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            pHead = pHead-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>快慢指针</p><p>先定义慢指针 $slow$ ，先让 $pHead$ 走 $k$ 步，再让 $slow$ 与 $pHead$ 同时走，当 $pHead$ 走到 $nullptr$ 时，$slow$ 正好走到倒数 $k$个结点</p><p>另一种方法，先计算链表长度 $num$ , $pHead$ 只要走 $num-k$ 步就行。代码如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* cur = pHead;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>num++;<br>cur = cur-&gt;next;<br>&#125;<br>        <span class="hljs-keyword">if</span>(k &gt; num)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>cur = pHead;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num - k; i++) &#123;<br>cur = cur-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="☆☆☆十五、反转链表"><a href="#☆☆☆十五、反转链表" class="headerlink" title="☆☆☆十五、反转链表"></a>☆☆☆十五、<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">反转链表</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = pHead;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>借助三个结点进行不断更替</p><p>$cur$ 为当前指针， $pre$ 为当前指针的前一指针， $tmp$ 为当前指针的后一指针</p><ol><li><code>pre</code>置为<code>nullptr</code>，它将作为链表的尾结点向前推进处理，<code>cur</code>指向旧链表的头指针<code>head</code>，<code>tmp</code>指向旧链表的头指针的<code>next</code>结点。</li><li>开始遍历链表，循环判定因子为<code>cur</code>，当它为空时到达链表尾部跳出循环。否则在表中执行循环内逻辑：将<code>cur</code>指向<code>pre</code>，即前一个结点。此时<code>pre</code>为<code>nullptr</code>，那么<code>cur</code>的下一个结点就为空了，它现在是最后一个结点。</li><li>然后将<code>pre</code>指针指向<code>cur</code>，将<code>cur</code>指针指向<code>tmp</code>，注意这两步不可以调换顺序，否则不能向后挪移一位。此时完成了三个指针的一轮更迭。</li><li>判定<code>cur</code>指针是否为空，如果为空说明此时<code>cur</code>到达了链表结尾。如果不为空，将<code>cur</code>更新到下一个结点，进行下一次循环。</li><li>下一次进行循环时，就会把截断结点链接到新链表的头部，同时更新三个指针。继续循环。</li><li>循环终止条件为：<code>cur</code>指向了链表尾部的<code>nullptr</code>，此时<code>cur</code>的前指针<code>pre</code>即指向了反转后的链表，它就是新链表的<code>head</code>头指针。此时返回<code>pre</code>即可。</li></ol><blockquote><p>另一种方法：头插法</p></blockquote><p>先对原链表做头删操作，再对新链表做头插</p><ol><li><p>定义一个新<code>head</code>头指针，标记为<code>newHead</code>，将它初始为<code>NULL</code>，并非指向<code>NULL</code>，最后我们选择返回这个<code>newHead</code>指针作为新链表的头指针。</p></li><li><p>定义一个结点<code>node</code>作为”临时中转站”，初始化与否并无大影响。</p></li><li><p>进行循环遍历链表各个结点，判定<code>head</code>指针是否为空，即是否到达了原链表的结尾。如果不为空，说明还没有到达尾部。如果程序第一次运行就没有进入循环，说明传入了一个空链表，此时返回<code>newHead</code>新链表的头指针，同样返回<code>NULL</code>，这样处理也是合理的。</p></li><li><p>以下开始逆序链表逻辑：在当前指针不为<code>NULL</code>时，先对原链表做头删操作，再对新链表做头插操作。即使用循环进行操作</p></li><li><p>让<code>node</code>指针指向传入函数链表的头指针<code>head</code>，两指针指向保持相同。</p></li><li><p>然后让<code>head</code>指针指向它的<code>next</code>结点，此时旧链表已经完成了头删操作。第一个结点已经被”切割”下来。接下来要做的就是对新链表进行头插操作，使结点放入新链表。</p></li><li><p>让<code>node</code>指针的<code>next</code>下一个结点指向新链表的头指针<code>newHead</code>，完成结点的链接，即头插入新的链表中。然后更新<code>newHead</code>指向为新链表的头结点。进行下一次循环。</p></li><li><p>最终<code>head</code>指针指向了原链表的结尾，即为<code>NULL</code>，退出循环，此时新链表已经反转完毕</p></li><li><p>最终返回新链表头指针<code>newHead</code>即可。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* newhead = <span class="hljs-literal">nullptr</span>;<br>        ListNode* node;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = pHead;<br>            pHead = pHead-&gt;next;<br>            node-&gt;next = newhead;<br>            newhead = node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newhead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 6-10</title>
    <link href="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/"/>
    <url>/2021/06/09/%E5%89%91%E6%8C%87offer6-10/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-6-10"><a href="#剑指offer-6-10" class="headerlink" title="剑指offer    6~10"></a>剑指offer    6~10</h1><h2 id="六、旋转数组的最小数字"><a href="#六、旋转数组的最小数字" class="headerlink" title="六、旋转数组的最小数字"></a>六、<a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">旋转数组的最小数字</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = rotateArray.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-keyword">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(rotateArray[pivot] &lt; rotateArray[high]) high = pivot;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotateArray[pivot] &gt; rotateArray[high]) low = pivot + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> high = high - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rotateArray[low];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/1.png"></p><p>考虑数组中的最后一个元素 $x$：在最小值右侧的元素，它们的值一定都小于等于 $x$；而在最小值左侧的元素，它们的值一定都大于等于 $x$。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p><p>我们将中轴元素 $rotateArray[pivot]$ 与右边界元素 $rotateArray[high]$ 进行比较，可能会有以下的三种情况：</p><p><code>第一种情况</code>是 $rotateArray[pivot]$ &lt; $rotateArray[high]$ 。如下图所示，这说明$rotateArray[pivot]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/2.png"></p><p><code>第二种情况</code>是  $rotateArray[pivot]$ &gt; $rotateArray[high]$ 。如下图所示，这说明 $rotateArray[pivot]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/3.png"></p><p><code>第三种情况</code>是  $rotateArray[pivot]$ == $rotateArray[high]$。如下图所示，由于重复元素的存在，我们并不能确定 $rotateArray[pivot]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 $rotateArray[high]$ 是不是最小值，都有一个它的「替代品」$rotateArray[high]$，因此我们可以忽略二分查找区间的右端点。</p><p>![](剑指offer 6-10/4.png)</p><p>当二分查找结束时，我们就得到了最小值所在的位置。</p><h2 id="七、斐波那契数列"><a href="#七、斐波那契数列" class="headerlink" title="七、斐波那契数列"></a>七、<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">斐波那契数列</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p><p><em>n</em> ≤ 39</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">1</span>, num2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">3</span>)&#123;<br>            sum = num1 + num2;<br>            num1 = num2;<br>            num2 = sum;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>用三个变量存储中间值</p><p>斐波那契数列为 1,1,2,3,5,8,13……</p><p>$num1$ 为第一个数，$num2$ 为第二个数，$sum$ 为两数相加。之后把 $num1$ 更新为 $num2$，把 $num2$ 更新为 $sum$</p><p>递归做法容易超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="八、跳台阶"><a href="#八、跳台阶" class="headerlink" title="八、跳台阶"></a>八、<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">跳台阶</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// n-2跳法</span><br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<span class="hljs-comment">// n-1跳法</span><br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<span class="hljs-comment">// n 跳法</span><br>        <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span> || number == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> number;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>; i &lt;= number; i++)&#123;<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>总体思路跟斐波那契数列一致</p><p>下面是dp算法的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//dp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(number + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="九、变态跳台阶"><a href="#九、变态跳台阶" class="headerlink" title="九、变态跳台阶"></a>九、<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1(https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)">变态跳台阶</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">jumpFloorII</span>(number - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>,a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; i++)&#123;<br>            count = a * <span class="hljs-number">2</span>;<br>            a = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>设 $f[i]$ 表示当前跳到第 $i$ 个台阶的方法数。那么$f[n]$就是所求答案。</p><p>假设现在已经跳到了第 $n$ 个台阶，那么前一步可以从哪些台阶到达呢？</p><p>如果上一步跳 1 步到达第 $n$ 个台阶，说明上一步在第 $n-1$ 个台阶。已知跳到第 $n-1$ 个台阶的方法数为 $f[n-1]$</p><p>如果上一步跳 2 步到达第 $n$ 个台阶，说明上一步在第 $n-2$ 个台阶。已知跳到第 $n-2$ 个台阶的方法数为 $f[n-2]$</p><p>。。。</p><p>如果上一步跳 $n$ 步到达第 $n$ 个台阶，说明上一步在第 0 个台阶。已知跳到第0个台阶的方法数为 $f[0]$</p><p>那么总的方法数就是所有可能的和。也就是 $f[n] = f[n-1] + f[n-2] + … + f[0]$</p><p>显然初始条件 $f[0] = f[1] = 1$</p><p>所以我们就可以先求 $f[2]$，然后 $f[3]…f[n-1]$， 最后 $f[n]$</p><p>由：$f[n-1] = f[n-2] + f[n-3] + … + f[0]$</p><p>得到 $f[n] = 2*f[n-1]$</p><p>可以采用递归，记忆化递归，动态规划，递推。</p><h2 id="十、矩形覆盖"><a href="#十、矩形覆盖" class="headerlink" title="十、矩形覆盖"></a>十、<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩形覆盖</a></h2><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，从同一个方向看总共有多少种不同的方法？</p><p>比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/5.jpg"></p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>2*1的小矩形的总个数n</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>覆盖一个2*n的大矩形总共有多少种不同的方法(从同一个方向看)</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> rectCover(<span class="hljs-built_in">int</span> <span class="hljs-keyword">number</span>) &#123;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">number</span> == <span class="hljs-number">1</span> || <span class="hljs-keyword">number</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">number</span>;<br>        &#125;<br>        for (<span class="hljs-built_in">int</span> i =<span class="hljs-number">2</span>; i &lt;= <span class="hljs-keyword">number</span>; i++)&#123;<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>实际上就是斐波那契数列的变种</p>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 std::function和lambda表达式</title>
    <link href="/2021/06/08/c++11stdfunction%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/06/08/c++11stdfunction%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="五、std-function和lambda表达式"><a href="#五、std-function和lambda表达式" class="headerlink" title="五、std::function和lambda表达式"></a>五、std::function和lambda表达式</h1><h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p>满足以下条件之一就可称为<code>可调用对象</code>：</p><ul><li>是一个函数指针</li><li>是一个具有operator()成员函数的类对象(传说中的仿函数)，lambda表达式</li><li>是一个可被转换为函数指针的类对象</li><li>是一个类成员(函数)指针</li><li>bind表达式或其它函数对象</li></ul><p>而std::function就是上面这种可调用对象的封装器，可以把std::function看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标，若std::function不含目标，则称它为空，调用空的std::function的目标会抛出std::bad_function_call异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::function</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>     <span class="hljs-comment">//普通函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; (a + b) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">class_func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>  <span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>   <span class="hljs-comment">//仿函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//普通函数</span><br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; func1 = func;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">24</span>);<br><br>    <span class="hljs-comment">//类的静态成员函数</span><br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; func2 = A::class_func;<br>    cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">2048</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//仿函数</span><br>    B m_b;<br>    function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; func3 = m_b;<br>    cout &lt;&lt; <span class="hljs-built_in">func3</span>(<span class="hljs-number">4096</span>) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">func</span>(<span class="hljs-number">1024</span>)<br><span class="hljs-selector-tag">A</span>::<span class="hljs-selector-tag">class_func</span>(<span class="hljs-number">2048</span>)<br><span class="hljs-selector-tag">2048</span><br><span class="hljs-selector-tag">B</span>::<span class="hljs-selector-tag">operator</span> ()(<span class="hljs-number">4096</span>)<br><span class="hljs-selector-tag">4096</span><br></code></pre></td></tr></table></figure><p>从上面可以看到std::function的使用方法，当给std::function填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。std::function还可以用作回调函数，或者在C++里如果需要使用回调那就一定要使用std::function，特别方便。</p><h3 id="std-function作为回调函数"><a href="#std-function作为回调函数" class="headerlink" title="std::function作为回调函数"></a>std::function作为回调函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::function</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt;&amp; func) :<span class="hljs-built_in">f_callback</span>(func)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; f_callback;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span>  <span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; <span class="hljs-built_in">f_callback</span>(num) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>   <span class="hljs-comment">//仿函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x * <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//仿函数</span><br>    B m_b;<br>    <span class="hljs-function">A <span class="hljs-title">m_a</span><span class="hljs-params">(m_b)</span></span>;<br>    m_a.<span class="hljs-built_in">notify</span>(<span class="hljs-number">1024</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">B:</span>:<span class="hljs-keyword">operator</span> ()(<span class="hljs-number">2048</span>)<br><span class="hljs-symbol">A:</span>:notify(<span class="hljs-number">1024</span>)<br></code></pre></td></tr></table></figure><p>在上面的例子中std::function可以取代函数指针的作用。因为它可以保存函数延迟执行，所以比较适合作为回调函数，也可以把它看做类似于C#中特殊的托管。</p><h3 id="std-function作为函数参数"><a href="#std-function作为函数参数" class="headerlink" title="std::function作为函数参数"></a>std::function作为函数参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::function</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>     <span class="hljs-comment">//普通函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; (a + b) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call_func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, std::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt;&amp; f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(x, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; func1 = func;<br>    <span class="hljs-built_in">call_func</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">96</span>, func1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span>(<span class="hljs-number">1120</span>)</span><br></code></pre></td></tr></table></figure><h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind用来将可调用对象与其参数进行绑定。绑定之后的结果可以使用std::function进行保存，并延迟调用到任何需要的时候。一般来讲，它主要有两大作用：</p><p>（1）将可调用对象与其参数一起绑定成为一个仿函数</p><p>（2）将多元可调用对象转换成为1元或是（n-1）元调用对象，既只是绑定部分参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>   <span class="hljs-comment">//std::function</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>     <span class="hljs-comment">//普通函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; (a + b) &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call_func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">const</span> std::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt;&amp; f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>(x, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> func2 = std::<span class="hljs-built_in">bind</span>(func, std::placeholders::_1, std::placeholders::_2);<br>    <span class="hljs-built_in">call_func</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">96</span>, func2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span>(<span class="hljs-number">1120</span>)</span><br></code></pre></td></tr></table></figure><p>实际上std::bind的返回类型是一个stl内部定义的仿函数类型，在这里就只需要知道它是一个仿函数，可以赋值给一个std::function，这里直接用std::function类型来保存std::bind的返回值也是可以的。</p><p>其中std::placeholders::_1是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数代替。</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式可以说是c++11引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;<br></code></pre></td></tr></table></figure><p>其中func是可以当作lambda表达式的名字，作为一个函数使用，<code>capture</code>是捕获列表，<code>params</code>是参数表，<code>opt</code>是函数选项(mutable之类)， <code>ret</code>是返回值类型，<code>func_body</code>是函数体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> a) -&gt; <span class="hljs-keyword">int</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-keyword">auto</span> func2 = [](<span class="hljs-keyword">int</span> a) &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>; &#125;;  <span class="hljs-comment">//省略了返回值类型</span><br>cout &lt;&lt; <span class="hljs-built_in">func1</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">2</span>) &lt;&lt; endl; <span class="hljs-comment">// 2 4</span><br></code></pre></td></tr></table></figure><p>如上代码，很多时候lambda表达式返回值是很明显的，c++11允许省略表达式的返回值定义。</p><p>lambda表达式允许捕获一定范围内的变量：</p><ul><li>[]不捕获任何变量</li><li>[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用</li><li>[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用</li><li>[=, &amp;a]值捕获外部作用域所有变量，按引用捕获a变量</li><li>[a]只值捕获a变量，不捕获其它变量</li><li>[this]捕获当前类中的this指针</li></ul><p>lambda表达式示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> f1 = [=]()&#123; <span class="hljs-keyword">return</span> a; &#125;; <span class="hljs-comment">// 值捕获a</span><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>() &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">//auto f2 = [=]() &#123; return a++; &#125;; // 修改按值捕获的外部变量，error</span><br><span class="hljs-keyword">auto</span> f3 = [=]() <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> ++a; &#125;; <span class="hljs-comment">// 0 1</span><br></code></pre></td></tr></table></figure><p>代码中的f2是编译不过的，因为我们修改了按值捕获的外部变量，其实lambda表达式就相当于是一个仿函数，仿函数是一个有operator()成员函数的类对象，这个operator()默认是const的，所以不能修改成员变量，而加了mutable，就是去掉const属性。</p><p>还可以使用lambda表达式自定义stl的规则，例如自定义sort排序规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-keyword">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   vector&lt;A&gt; vec;<br>   std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">const</span> A &amp;left, <span class="hljs-keyword">const</span> A &amp;right) &#123; <span class="hljs-keyword">return</span> left.a &lt; right.a; &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于lambda表达式的全部知识"><a href="#关于lambda表达式的全部知识" class="headerlink" title="关于lambda表达式的全部知识"></a>关于lambda表达式的全部知识</h3><ol><li><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p></li><li><p>每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p></li><li><p>lambda表达式的语法定义如下：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture] （parameters） <span class="hljs-keyword">mutable</span> -&gt;<span class="hljs-keyword">return</span>-type &#123;statement&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li>lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : 搞定c++11新特性std::function和lambda表达式 (<a href="https://mp.weixin.qq.com/s/6zzF8GEgpMsNrdoBLi5csA">https://mp.weixin.qq.com/s/6zzF8GEgpMsNrdoBLi5csA</a>)</p><p>[ 2 ] : C++11 std::function和std::bind绑定器 (<a href="https://blog.csdn.net/m_buddy/article/details/74389409">https://blog.csdn.net/m_buddy/article/details/74389409</a>)</p><p>[ 3 ] : 阿秀的校招笔记 (<a href="https://interviewguide.cn/#/">https://interviewguide.cn/#/</a>)</p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer 1-5</title>
    <link href="/2021/06/08/%E5%89%91%E6%8C%87offer%201-5/"/>
    <url>/2021/06/08/%E5%89%91%E6%8C%87offer%201-5/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-1-5"><a href="#剑指offer-1-5" class="headerlink" title="剑指offer    1~5"></a>剑指offer    1~5</h1><h2 id="一、二维数组中的查找"><a href="#一、二维数组中的查找" class="headerlink" title="一、二维数组中的查找"></a>一、<a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二维数组中的查找</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>[</p><p> [1,2,8,9],<br> [2,4,9,12],<br> [4,7,10,13],<br> [6,8,11,15]</p><p>]</p><p>给定 target = 7，返回 true。</p><p>给定 target = 3，返回 false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> m = array.<span class="hljs-built_in">size</span>(), n = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span> (target &gt; array[i][j]) i++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[i][j]) j--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>右上角逐渐逼近左下角</p><ul><li>如果当前位置元素比target小，则 i++</li><li>如果当前位置元素比target大，则 j–</li><li>如果相等，返回 true</li><li>如果越界了还没找到，说明不存在，返回 false</li></ul><h2 id="二、替换空格"><a href="#二、替换空格" class="headerlink" title="二、替换空格"></a>二、<a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">替换空格</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;We Are Happy&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;We%20Are%20Happy&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> spaceNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> oldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>)spaceNum++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> newSize = s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * spaceNum;<br>        s.<span class="hljs-built_in">resize</span>(newSize);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = newSize - <span class="hljs-number">1</span>, j = oldSize - <span class="hljs-number">1</span>; j &lt; i; i--, j--)&#123;<br>            <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                s[i] = s[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ol><li>先计算出字符串s中空格数量spaceNum</li><li>重新定义字符串s长度newSize</li><li>从后往前遍历字符串s（这里注意用两个变量，分别指向newSize和oldSize）遇到空格就倒着插入’%20’</li></ol><h2 id="三、从尾到头打印链表"><a href="#三、从尾到头打印链表" class="headerlink" title="三、从尾到头打印链表"></a>三、<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">从尾到头打印链表</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">24</span>,<span class="hljs-number">58</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">58</span>,<span class="hljs-number">24</span>,<span class="hljs-number">0</span>,<span class="hljs-number">67</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;<br>            ret.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ret.<span class="hljs-built_in">begin</span>(), ret.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ol><li>先从头到尾遍历链表</li><li>对vector里的value反转一下</li></ol><h2 id="☆四、重建二叉树"><a href="#☆四、重建二叉树" class="headerlink" title="☆四、重建二叉树"></a>☆四、<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">重建二叉树</a></h2><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">3,2,4,1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;hash;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;preorder, inorder;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pre,vector&lt;<span class="hljs-keyword">int</span>&gt; vin)</span> </span>&#123;<br>        preorder = pre, inorder = vin;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            hash[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pl, <span class="hljs-keyword">int</span> pr, <span class="hljs-keyword">int</span> il, <span class="hljs-keyword">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pl &gt; pr)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pl]);<br>        <span class="hljs-keyword">int</span> k = hash[root-&gt;val];<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(pl + <span class="hljs-number">1</span>, pl + k - il, il, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(pl + k - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><ol><li><p>先用哈希表存储中序遍历的索引</p></li><li><p>前序遍历第一个数必是根节点root</p></li><li><p>dfs中参数 pl、pr分别为前序遍历中的左右指针；il、ir分别为中序遍历中的左右指针</p></li><li><p>k为根节点在中序遍历中的索引（因为根节点在前序遍历中必是索引0）</p></li><li><p>左子树：前序遍历左指针索引为 pl + 1；右指针索引为 pl + k - il </p><p>​             中序遍历左指针索引为 il ；右指针索引为 k - 1</p></li><li><p>右子树:  前序遍历左指针索引为 pl + k - il +1；右指针索引为 pr </p><p>​             中序遍历左指针索引为 k + 1 ；右指针索引为 ir</p></li></ol><h2 id="五、用两个栈来实现一个队列"><a href="#五、用两个栈来实现一个队列" class="headerlink" title="五、用两个栈来实现一个队列"></a>五、<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">用两个栈来实现一个队列</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(stack1.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)&#123;<br>            stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>            stack1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">int</span> ret = stack1.<span class="hljs-built_in">top</span>();<br>        stack1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">while</span>(!stack2.<span class="hljs-built_in">empty</span>())&#123;<br>            stack1.<span class="hljs-built_in">push</span>(stack2.<span class="hljs-built_in">top</span>());<br>            stack2.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack1;<span class="hljs-comment">//保存元素</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack2;<span class="hljs-comment">//辅助栈</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>分别用一个保存元素的栈stack1和一个辅助栈stack2来实现队列</p><p>push：直接push到stack1</p><p>pop：</p><ol><li>先把stack1里的元素都放到stack2中，只留最后一个栈底的元素；</li><li>把栈底元素pop；</li><li>最后把stack2中的元素放回stack1中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 列表初始化</title>
    <link href="/2021/06/07/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2021/06/07/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="四、列表初始化"><a href="#四、列表初始化" class="headerlink" title="四、列表初始化"></a>四、列表初始化</h1><h2 id="统一的初始化方法"><a href="#统一的初始化方法" class="headerlink" title="统一的初始化方法"></a>统一的初始化方法</h2><p>在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化。</p><p>在C++98/03中我们只能对普通数组和POD(plain old data，简单来说就是可以用memcpy复制的对象)类型可以使用列表初始化，如下：</p><p>数组的初始化列表： int arr[3] = {1,2,3}</p><p>POD类型的初始化列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><p>在C++11中初始化列表被适用性被放大，可以作用于<code>任何类型对象</code>的初始化。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">int</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Foo <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>; <span class="hljs-comment">//调用Foo(int)构造函数初始化</span><br>Foo a2 = <span class="hljs-number">123</span>; <span class="hljs-comment">//error Foo的拷贝构造函数声明为私有的，该处的初始化方式是隐式调用Foo(int)构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化</span><br><br>Foo a3 = &#123; <span class="hljs-number">123</span> &#125;; <span class="hljs-comment">//列表初始化</span><br>Foo a4&#123; <span class="hljs-number">123</span> &#125;; <span class="hljs-comment">//列表初始化</span><br><br><span class="hljs-keyword">int</span> a5 = &#123; <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">int</span> a6&#123; <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的示例代码可以看出，在C++11中，列表初始化不仅能完成对普通类型的初始化，还能完成对类的列表初始化，需要注意的是a3 a4都是列表初始化，私有的拷贝并不影响它，仅调用类的构造函数而不需要拷贝构造函数，a4,a6的写法是C++98/03所不具备的，是C++11新增的写法。</p><h2 id="列表初始化的一些规则"><a href="#列表初始化的一些规则" class="headerlink" title="列表初始化的一些规则"></a>列表初始化的一些规则</h2><h3 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h3><p>聚合类型可以进行直接列表初始化</p><ol><li>类型是一个普通数组，如int[5]，char[]，double[]等；</li><li>类型是一个类，且满足以下条件：<ul><li>没有用户声明的构造函数</li><li>没有用户提供的构造函数(允许显示预置或弃置的构造函数)</li><li>没有私有或保护的非静态数据成员</li><li>没有基类</li><li>没有虚函数</li><li>没有{}和=直接初始化的非静态数据成员</li><li>没有默认成员初始化器</li></ul></li></ol><blockquote><p>（1）存在用户自定义的构造函数的情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">int</span> c;<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>A a&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<span class="hljs-comment">// error，A有自定义的构造函数，不能列表初始化</span><br>cout &lt;&lt; a.a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：-858993460 -858993460 -858993460</p><p>可以看出对于有用户自定义构造函数的类使用初始化列表其成员初始化后变量值是一个随机值，因此用户必须以用户自定义构造函数来构造对象。</p><blockquote><p>（2）类包含有私有的或者受保护的非静态数据成员的情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-comment">//A(int, int, double)&#123;&#125;</span><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">double</span> z;<br>    <span class="hljs-comment">//static double z;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a&#123; <span class="hljs-number">123</span>,<span class="hljs-number">456</span> &#125;;<br>cout &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例中z是一个受保护的成员变量，该程序直接在VS2019下编译出错，error C2440: ‘initializing’ : cannot convert from ‘initializer-list’ to ‘A’，而如果将z变量声明为static则，可以用列表初始化来。</p><p>程序输出：123 456，因此可知静态数据成员的初始化是不能通过初始化列表来完成初始化的，它的初始化还是遵循以往的静态成员的初始化方式。</p><blockquote><p>（3）类含有基类或者虚函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;;  <span class="hljs-comment">// 含有虚函数，不是聚合类</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a&#123; <span class="hljs-number">123</span>,<span class="hljs-number">456</span> &#125;;<br>cout &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中类A中包含了一个虚函数，该程序也是非法的，编译不过的，错误信息和上述一样cannot convert from ‘initializer-list’ to ‘A’。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">base</span> &#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> :</span>base<br>&#123;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a&#123; <span class="hljs-number">123</span>,<span class="hljs-number">456</span> &#125;;<br>cout &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中则是有基类的情况，类A从base中继承，然后对A使用列表初始化，该程序也一样无法通过编译，错误信息仍然为cannot convert from ‘initializer-list’ to ‘A’。</p><blockquote><p>（4）类中不能有{}或者=直接初始化的费静态数据成员</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y = <span class="hljs-number">5</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a&#123; <span class="hljs-number">123</span>,<span class="hljs-number">456</span> &#125;;<br>cout &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a.y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在结构体A 中变量y 直接用 = 进行初始化了，因此上述例子也不能使用列表初始化方法，需要注意的是在C++98/03中，类似于变量y 这种直接用 = 进行初始化的方法是不允许的，但是在C++11中放宽了，是可以直接进行初始化的，对于一个类来说如果它的非静态数据成员使用了 = 或者 {}在声明同时进行了初始化，那么它就不再是聚合类型了，不适合使用列表初始化方法了。</p><blockquote><p>注意</p></blockquote><p>一个类声明了自己的构造函数的情形（如上情况1），在这种情况下使用初始化列表是编译器是不会给你报错的，操作系统会给变量一个随机的值，这种问题在代码出BUG后是很难查找到的，因此这种情况不适合使用列表初始化。</p><h2 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h2><p>STL容器跟数组一样可以填入任何需要的任何长度的同类型的数据，而我们自定义的A类型却不具备这种能力，只能按照构造函数的初始化列表顺序进行依次赋值。实际上之所以STL容器拥有这种可以用任意长度的同类型数据进行初始化能力是因为STL中的容器使用了std::initialzer_list这个轻量级的类模板，std::initialzer_list可以接受任意长度的同类型的数据也就是接受可变长参数{…}，那么我们是否可以利用这个来改写我们的A类，是的A类也具有这种能力呢？看下面例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">int</span> z;<br><span class="hljs-built_in">A</span>(std::initializer_list&lt;<span class="hljs-keyword">int</span>&gt; list)<br>&#123;<br><span class="hljs-keyword">auto</span> it = list.<span class="hljs-built_in">begin</span>();<br>x = *it++;<br>y = *it++;<br>z = *it++;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A foo1&#123; <span class="hljs-number">123</span>,<span class="hljs-number">456</span>,<span class="hljs-number">789</span> &#125;;<br>A foo2&#123; <span class="hljs-number">123</span>, <span class="hljs-number">456</span> &#125;;<br>A foo3&#123; <span class="hljs-number">123</span> &#125;;<br>A foo4&#123; <span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">258</span> &#125;;<br>cout &lt;&lt; foo1.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo1.y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo1.z &lt;&lt; endl;<br>cout &lt;&lt; foo2.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo2.y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo2.z &lt;&lt; endl;<br>cout &lt;&lt; foo3.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo3.y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo3.z &lt;&lt; endl;<br>cout &lt;&lt; foo4.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo4.y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; foo4.z &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">123</span> <span class="hljs-number">456</span> <span class="hljs-number">789</span><br><span class="hljs-number">123</span> <span class="hljs-number">456</span> <span class="hljs-number">-858993460</span><br><span class="hljs-number">123</span> <span class="hljs-number">-858993460</span> <span class="hljs-number">-858993460</span><br><span class="hljs-number">123</span> <span class="hljs-number">456</span> <span class="hljs-number">789</span><br></code></pre></td></tr></table></figure><p>在上面的例子中我们用 std::initialzer_list 将类改写，是的类A也具有了接受可变长参数的能力，在A类中定义了三个变量，分别在main函数中使用1个、2个、3个、4个参数的列表初始化方法来初始化foo变量，可见，由程序的输出结果可知，对于这种拥有固定数目的数据成员来说使用 std::initialzer_list 来改写后，如果列表初始化的参数刚好是3个，则数据成员完全初始化，如果列表初始化的个数小于3个，则未给予的值是一个随机值，而大于3个的话超出的列表初始化参数将被抛弃。虽然std::initialzer_list可以改写我们自定义的类，但是对于用于固定的数据成员的类来说这种改写意义不大，若列表初始化个数少于数据成员个数则会导致某些数据成员未被初始化，容易引起程序出BUG。</p><h3 id="std-initialzer-list的使用细节"><a href="#std-initialzer-list的使用细节" class="headerlink" title="std::initialzer_list的使用细节"></a>std::initialzer_list的使用细节</h3><ol><li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的一些概念。</li><li>对于initialzer-list<T>来说，它可以接受任意长度的初始化列表，但是元素必须是要相同的或者可以转换为T类型的。</T></li><li>它只有三个成员接口，begin(),end(),size(),其中size()返回initialzer-list的长度。</li><li>它只能被整体的初始化和赋值，遍历只能通过begin和end迭代器来，遍历取得的数据是可读的，是不能对单个进行修改的。</li></ol><h2 id="列表初始化的好处"><a href="#列表初始化的好处" class="headerlink" title="列表初始化的好处"></a>列表初始化的好处</h2><ol><li>方便，且基本上可以替代括号初始化</li><li>可以使用初始化列表接受任意长度</li><li>可以防止类型窄化，避免精度丢失的隐式类型转换</li></ol><h3 id="列表初始化防止类型收窄"><a href="#列表初始化防止类型收窄" class="headerlink" title="列表初始化防止类型收窄"></a>列表初始化防止类型收窄</h3><p>C++11的列表初始化还有一个额外的功能就是可以防止类型收窄，也就是C++98/03中的隐式类型转换，将范围大的转换为范围小的表示，在C++98/03中类型收窄并不会编译出错，而在C++11中，使用列表初始化的类型收窄编译将会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1.1</span>; <span class="hljs-comment">//OK</span><br><span class="hljs-keyword">int</span> b&#123; <span class="hljs-number">1.1</span> &#125;; <span class="hljs-comment">//error</span><br> <br><span class="hljs-keyword">float</span> f1 = <span class="hljs-number">1e40</span>; <span class="hljs-comment">//OK</span><br><span class="hljs-keyword">float</span> f2&#123; <span class="hljs-number">1e40</span> &#125;; <span class="hljs-comment">//error</span><br> <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">1024</span>, y = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> c = x; <span class="hljs-comment">//OK</span><br><span class="hljs-keyword">char</span> d&#123; x &#125;;<span class="hljs-comment">//error</span><br><span class="hljs-keyword">char</span> e = y;<span class="hljs-comment">//error</span><br><span class="hljs-keyword">char</span> f&#123; y &#125;;<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><p>上面例子看出，用C++98/03的方式类型收窄并不会编译报错，但是将会导致一些隐藏的错误，导致出错的时候很难定位，而利用C++11的列表初始化方法定义变量从源头了遏制了类型收窄，使得不恰当的用法就不会用在程序中，避免了某些位置类型的错误，因此建议以后再实际编程中尽可能的使用列表初始化方法定义变量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ]学会C++11列表初始化(<a href="https://mp.weixin.qq.com/s/wpV4K0aJS9l3ilk4nuurQA">https://mp.weixin.qq.com/s/wpV4K0aJS9l3ilk4nuurQA</a>)</p><p>[ 2 ]C++11新特性之列表初始化(<a href="https://blog.csdn.net/hailong0715/article/details/54018002">https://blog.csdn.net/hailong0715/article/details/54018002</a>)</p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 模板改进</title>
    <link href="/2021/06/04/c++11%E6%A8%A1%E6%9D%BF%E6%94%B9%E8%BF%9B/"/>
    <url>/2021/06/04/c++11%E6%A8%A1%E6%9D%BF%E6%94%B9%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="三、模板改进"><a href="#三、模板改进" class="headerlink" title="三、模板改进"></a>三、模板改进</h1><h2 id="模板的右尖括号"><a href="#模板的右尖括号" class="headerlink" title="模板的右尖括号"></a>模板的右尖括号</h2><p>C++11 之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个<strong>空格</strong>进行分割，避免发生编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; a; <span class="hljs-comment">// error</span><br>   std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; b; <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h2><p>C++11引入了using，可以轻松的定义别名，而不是使用繁琐的typedef。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; vvi; <span class="hljs-comment">// before c++11</span><br><span class="hljs-keyword">using</span> vvi = std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;; <span class="hljs-comment">// c++11</span><br></code></pre></td></tr></table></figure><h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><p>C++11之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11后都支持。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//1、普通函数带默认参数，c++98 编译通过，c++11 编译通过</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DefParm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m = <span class="hljs-number">3</span>)</span> </span>&#123;&#125;<br><br><span class="hljs-comment">//2、类模板是支持默认的模板参数，c++98 编译通过，c++11 编译通过</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt;<br>class A &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T=<span class="hljs-keyword">int</span>, <span class="hljs-keyword">typename</span> U&gt; <span class="hljs-comment">// error，类模板的默认模板参数必须从右往左定义</span><br>class A &#123;<br>    T value;  <br>&#125;;<br><br><span class="hljs-comment">//3、函数模板的默认模板参数， c++98 - 编译失败，c++11 - 编译通过</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-built_in">DefTempParm</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于函数模板，参数的填充顺序是从左到右的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> U = <span class="hljs-keyword">int</span>&gt;<br>R <span class="hljs-built_in">func1</span>(U val) &#123;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> R = <span class="hljs-keyword">int</span>, <span class="hljs-keyword">typename</span> U&gt;<br>R <span class="hljs-built_in">func2</span>(U val) &#123;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//默认 U-&gt;int</span><br>cout &lt;&lt; func1&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99</span><br>cout &lt;&lt; func1&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99.9</span><br>cout &lt;&lt; func1&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99.9</span><br>cout &lt;&lt; func1&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99</span><br><br><span class="hljs-comment">//默认 R-&gt;int</span><br>cout &lt;&lt; func2&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99</span><br>cout &lt;&lt; func2&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99.9</span><br>cout &lt;&lt; func2&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99.9</span><br>cout &lt;&lt; func2&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">99.9</span>) &lt;&lt; endl;<span class="hljs-comment">// 99</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : C++11的模板改进<a href="https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484785&amp;idx=1&amp;sn=194f240fa984970397e38a989c112aa2&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484785&amp;idx=1&amp;sn=194f240fa984970397e38a989c112aa2&amp;source=41#wechat_redirect</a></p><p>[ 2 ] : C++11：模板的改进<a href="https://blog.csdn.net/tennysonsky/article/details/77817027">https://blog.csdn.net/tennysonsky/article/details/77817027</a></p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 左值引用、右值引用、移动语义、完美转发</title>
    <link href="/2021/06/03/c++11%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"/>
    <url>/2021/06/03/c++11%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="二、左值引用、右值引用、移动语义、完美转发"><a href="#二、左值引用、右值引用、移动语义、完美转发" class="headerlink" title="二、左值引用、右值引用、移动语义、完美转发"></a>二、左值引用、右值引用、移动语义、完美转发</h1><h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><p><code>左值</code>：可以放到等号左边，可以取地址并且有名字的东西</p><p><code>右值</code>：不可以放到等号左边，不能取地址的没有名字的东西</p><blockquote><p>举例</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = b + c;<br></code></pre></td></tr></table></figure><p>a是左值，a有变量名，也可以取地址，可以放到等号左边, 表达式 b + c 的返回值是右值，没有名字且不能取地址，&amp;(b+c)不能通过编译，而且也不能放到等号左边。</p><p><code>左值</code>一般有：</p><ul><li>函数名和变量名</li><li>返回左值引用的函数调用</li><li>前置自增自减表达式 ++i、–i</li><li>由赋值表达式或赋值运算符连接的表达式(a=b, a += b 等)</li><li>解引用表达式 *p</li><li>字符串字面值”abcd”</li></ul><h2 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h2><p>运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda 表达式等都是<code>纯右值</code></p><p><code>纯右值</code>指的是临时变量值、不跟对象关联的字面量值</p><p><code>临时变量</code>指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；</p><p><code>不跟对象关联的字面量值</code>，例如true，2，”C”等。</p><blockquote><p>举例</p></blockquote><ul><li>除字符串字面值外的字面值</li><li>返回非引用类型的函数调用</li><li>后置自增自减表达式i++、i–</li><li>算术表达式(a+b, a*b, a&amp;&amp;b, a==b 等)</li><li>取地址表达式等(&amp;a)</li></ul><h2 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h2><p><code>将亡值</code>则是C++11新增的跟右值引用相关的表达式，这样表达式通常是<strong>将要被移动的对象（移为他用）</strong>，比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p><p><code>将亡值</code>可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;b = a; <span class="hljs-comment">// b 是左值引用</span><br>b = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">// error，10 无法取地址，无法进行引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;d = <span class="hljs-number">10</span>; <span class="hljs-comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span><br></code></pre></td></tr></table></figure><p><code>常量左值引用</code>是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-comment">// error, 左值引用绑定到右值，编译失败</span><br><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-comment">// 非常量左值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;c = b; <span class="hljs-comment">// 常量左值引用绑定到非常量左值，编译通过</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;e = c; <span class="hljs-comment">// 常量左值引用绑定到常量左值，编译通过</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;b = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 常量左值引用绑定到右值，编程通过</span><br></code></pre></td></tr></table></figure><blockquote><p>结论</p></blockquote><p>对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const 引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>使用 <code>std::move</code> 函数强制把左值转换为右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> &amp;&amp;b = a; <span class="hljs-comment">// error, a 是左值</span><br><span class="hljs-keyword">int</span> &amp;&amp;c = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>右值引用不能初始化为左值</p><p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br>cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// a = 100</span><br></code></pre></td></tr></table></figure><p><img src="/2021/06/03/c++11%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8.png"></p><h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>&#125;<br><span class="hljs-built_in">A</span>()&#123;&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp; a) &#123;<br>size_ = a.size_;<br>data_ = a.data_;<br>cout &lt;&lt; <span class="hljs-string">&quot;copy &quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>() &#123;<br><span class="hljs-keyword">delete</span>[] data_;<br>&#125;<br><span class="hljs-keyword">int</span> *data_;<br><span class="hljs-keyword">int</span> size_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>A b = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;b &quot;</span> &lt;&lt; b.data_ &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;a &quot;</span> &lt;&lt; a.data_ &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，两个输出的是相同的地址，a 和b 的data指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data内存会被释放两次，导致程序出问题。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>    &#125;<br>    <span class="hljs-built_in">A</span>()&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp; a) &#123;<br>        size_ = a.size_;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br>    <span class="hljs-keyword">int</span> *data_;<br>    <span class="hljs-keyword">int</span> size_;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    A b = a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b &quot;</span> &lt;&lt; b.data_ &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a &quot;</span> &lt;&lt; a.data_ &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p><code>移动语义</code>，可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。</p><p>C++11最重要的一个改进之一就是引入了move语义，这样在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能。例如有些右值即将消亡析构，这个时候我们用移动构造函数可以接管他们的资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>    &#125;<br>    <span class="hljs-built_in">A</span>()&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp; a) &#123;<br>        size_ = a.size_;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(A&amp;&amp; a) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;data_ = a.data_;<br>        a.data_ = <span class="hljs-literal">nullptr</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move &quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">if</span> (data_ != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] data_;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> *data_;<br>    <span class="hljs-keyword">int</span> size_;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    A b = a;<br>    A c = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// 调用移动构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便我们使用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;string&gt; vecs;<br>...<br>std::vector&lt;string&gt; vecm = std::<span class="hljs-built_in">move</span>(vecs); <span class="hljs-comment">// 免去很多拷贝</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><p>移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们没有实现对应的移动构造函数。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p><code>完美转发</code>指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用 std::forward()</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintV</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;t)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;lvalue&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintV</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;&amp;t)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;rvalue&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(T &amp;&amp;t)</span> </span>&#123;<br>    <span class="hljs-built_in">PrintV</span>(t);<br>    <span class="hljs-built_in">PrintV</span>(std::forward&lt;T&gt;(t));<br><br>    <span class="hljs-built_in">PrintV</span>(std::<span class="hljs-built_in">move</span>(t));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// lvalue rvalue rvalue</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">Test</span>(a); <span class="hljs-comment">// lvalue lvalue rvalue</span><br>    <span class="hljs-built_in">Test</span>(std::forward&lt;<span class="hljs-keyword">int</span>&gt;(a)); <span class="hljs-comment">// lvalue rvalue rvalue</span><br>    <span class="hljs-built_in">Test</span>(std::forward&lt;<span class="hljs-keyword">int</span>&amp;&gt;(a)); <span class="hljs-comment">// lvalue lvalue rvalue</span><br>    <span class="hljs-built_in">Test</span>(std::forward&lt;<span class="hljs-keyword">int</span>&amp;&amp;&gt;(a)); <span class="hljs-comment">// lvalue rvalue rvalue</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Test(1)：1是右值，模板中T &amp;&amp;t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。</p></li><li><p>Test(a)：a是左值，模板中T &amp;&amp;这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。</p></li><li><p>Test(std::forward(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] :左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里<a href="https://zhuanlan.zhihu.com/p/137662465">https://zhuanlan.zhihu.com/p/137662465</a></p><p>[ 2 ] :C++11 左值、右值、右值引用详解<a href="https://blog.csdn.net/hyman_yx/article/details/52044632">https://blog.csdn.net/hyman_yx/article/details/52044632</a></p><p>[ 3 ] :C++11右值引用（一看即懂）<a href="http://c.biancheng.net/view/7829.html">http://c.biancheng.net/view/7829.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 类型推导</title>
    <link href="/2021/06/03/c++11%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <url>/2021/06/03/c++11%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、类型推导auto-amp-decltype"><a href="#一、类型推导auto-amp-decltype" class="headerlink" title="一、类型推导auto &amp; decltype"></a>一、类型推导auto &amp; decltype</h1><p>C++11引入了<code>auto</code>和<code>decltype</code>关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto：让编译器在编译时就推导出变量的类型，可以通过=右边的类型推导出变量的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 10是int型，可以自动推导出a是int</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">auto</span> b = i; <span class="hljs-comment">// b 是int 型</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// d 是double 型</span><br></code></pre></td></tr></table></figure><p>可以通过 = 右边的类型推导出变量的类型</p><h3 id="auto-推导规则"><a href="#auto-推导规则" class="headerlink" title="auto 推导规则"></a>auto 推导规则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123;&#125; <span class="hljs-comment">// error，auto 不能用作函数参数</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，在类中auto 不能用作非静态成员变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，这里与auto 无关，正常static int b = 1 也不可以</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">auto</span> c[<span class="hljs-number">10</span>] = a; <span class="hljs-comment">// error，auto 不能定义数组，可以定义指针</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; d;<br>vector&lt;<span class="hljs-keyword">auto</span>&gt; f = d; <span class="hljs-comment">// error，auto 无法推导出模板参数</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下auto 的限制：</p></blockquote><ul><li>auto 的使用必须马上<code>初始化</code>，否则无法推导出类型</li><li>auto 在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败</li><li>auto 不能用作函数参数</li><li>在类中 auto 不能用作非静态成员变量</li><li>auto 不能定义数组，可以定义指针</li><li>auto 无法推导出模板参数</li></ul><blockquote><p>注意：</p></blockquote><ul><li><p>在不声明为引用或指针时，auto 会忽略等号右边的引用类型和 const 、volatile 限定</p></li><li><p>在声明为引用或者指针时，auto 会保留等号右边的引用和const 、volatile 属性</p></li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> *a = &amp;i; <span class="hljs-comment">// a 是int*</span><br><span class="hljs-keyword">auto</span> &amp;b = i; <span class="hljs-comment">// b 是int&amp;</span><br><span class="hljs-keyword">auto</span> c = b; <span class="hljs-comment">// c 是int，忽略了引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> d = i; <span class="hljs-comment">// d 是const int</span><br><span class="hljs-keyword">auto</span> e = d; <span class="hljs-comment">// e 是int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; f = e; <span class="hljs-comment">// f 是const int&amp;</span><br><span class="hljs-keyword">auto</span> &amp;g = f; <span class="hljs-comment">// g 是const int&amp;</span><br></code></pre></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func</span>()) i; <span class="hljs-comment">// i为int类型</span><br><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(x) y; <span class="hljs-comment">// y是int类型</span><br><span class="hljs-keyword">decltype</span>(x + y) z; <span class="hljs-comment">// z是int类型</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><p>decltype 不会像 auto 一样忽略引用和const 、volatile属性，decltype会保留表达式的引用和const 、volatile属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cont <span class="hljs-keyword">int</span> &amp;i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">decltype</span>(i) b = <span class="hljs-number">2</span>; <span class="hljs-comment">// b是const int&amp;</span><br></code></pre></td></tr></table></figure><h3 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h3><p>对于decltype(exp)有：</p><ul><li>exp 是表达式，decltype(exp)和exp 类型相同</li><li>exp 是函数调用，decltype(exp)和函数返回值类型相同</li><li>其它情况，若exp 是左值，decltype(exp)是exp 类型的左值引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(a + b) c = <span class="hljs-number">0</span>; <span class="hljs-comment">// c 是int，因为(a+b)返回一个右值</span><br><span class="hljs-keyword">decltype</span>(a += b) d = c;<span class="hljs-comment">// d 是int&amp;，因为(a+=b)返回一个左值</span><br>d = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">// 输出c = 20</span><br></code></pre></td></tr></table></figure><h2 id="auto-和decltype-的配合使用"><a href="#auto-和decltype-的配合使用" class="headerlink" title="auto 和decltype 的配合使用"></a>auto 和decltype 的配合使用</h2><p>你可能会思考，auto 能不能用于推导函数的返回类型。考虑这样一个例子加法函数的例子，在传统 C++ 中我们必须这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">R <span class="hljs-title">add</span><span class="hljs-params">(T x, U y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，获得一个什么样的返回类型。</p><p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(x+y) <span class="hljs-built_in">add</span>(T x, U y);<br></code></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做<strong>拖尾返回类型（trailing return type）</strong>，利用 auto 关键字将返回类型后置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br>auto add(T x, U y) -&gt; decltype(x+y) &#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[  1  ] : C++11的类型推导详解 <a href="https://zhuanlan.zhihu.com/p/137662774">https://zhuanlan.zhihu.com/p/137662774</a> </p><p>[  2  ] : C++11常用新特性快速一览 <a href="https://blog.csdn.net/jiange_zh/article/details/79356417">https://blog.csdn.net/jiange_zh/article/details/79356417</a> </p>]]></content>
    
    
    <categories>
      
      <category>C++11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B树</title>
    <link href="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/"/>
    <url>/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p><code>B树</code>和<code>B+树</code>的出现是为了查询数据时减少磁盘的IO次数，我们知道平衡二叉查找树是一种查询速度很快的数据结构。它的时间复杂度为 $logN$，但是它由于是一个二叉树，所以树的高度相对于多叉树来讲是比较高的，所以为了平衡磁盘IO与时间复杂度直接的关系，我们引入了B树和B+树。</p><h2 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h2><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB.png"></p><ol><li>按照有序性，可以分为有序树和无序树：</li></ol><ul><li><code>无序树</code>：树中任意节点的子结点之间没有顺序关系</li><li><code>有序树</code>：树中任意节点的子结点之间有顺序关系</li></ul><ol start="2"><li>按照节点包含子树个数，可以分为B树和二叉树，二叉树可以分为以下几种：</li></ol><ul><li><code>二叉树</code>：每个节点最多含有两个子树的树称为二叉树；</li><li><code>二叉查找树</code>：首先它是一颗二叉树，若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于它的根结点的值；左、右子树也分别为二叉排序树；</li><li><code>满二叉树</code>：叶节点除外的所有节点均含有两个子树的树被称为满二叉树；</li><li><code>完全二叉树</code>：如果一颗二叉树除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li><li><code>霍夫曼树</code>：带权路径最短的二叉树。</li><li><code>红黑树</code>：红黑树是一颗特殊的二叉查找树，每个节点都是黑色或者红色，根节点、叶子节点是黑色。如果一个节点是红色的，则它的子节点必须是黑色的。</li><li><code>平衡二叉树（AVL）</code>：一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</li></ul><h2 id="B树-1"><a href="#B树-1" class="headerlink" title="B树"></a>B树</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>B树</code>，也称为<code>B-树</code>，是一种<code>平衡的多叉树</code>（可以对比一下平衡二叉查找树），它比较适用于对外查找。</p><ul><li><p>阶数：一个节点最多有多少个孩子节点。（一般用字母m表示）</p></li><li><p>关键字：节点上的数值就是关键字。</p></li><li><p>度：一个节点拥有的子节点的数量。</p></li></ul><p>一颗<code>m阶</code>的B树，有以下特征：</p><ul><li>根结点至少有两个子女；</li><li>每个非根节点所包含的关键字个数 j 满足：⌈m/2⌉ - 1 &lt;= j &lt;= m - 1.(⌈⌉表示向上取整)</li><li>有k个关键字(关键字按<code>递增次序</code>排列)的非叶结点恰好有k+1个孩子。</li><li>所有的叶子结点都位于同一层。</li></ul><p>一棵简单的B-树如下：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/bshu.png"></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>B+树是B-树的变体，也是一颗多路搜索树。一棵<code>m阶</code>的B+树主要有这些特点：</p><ul><li>每个结点至多有m个子女；</li><li>非根节点关键值个数范围：m/2 &lt;= k &lt;= m-1；</li><li>相邻叶子节点是通过指针连起来的，并且是关键字大小排序的。</li></ul><p>一颗简单的B+树如下：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91.png"></p><p><strong>B+树和B-树的主要区别如下</strong>：</p><blockquote><ul><li>B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作<code>索引</code>作用，它的叶子节点才保存数据。</li><li>B+树相邻的叶子节点之间是通过<code>链表指针</code>连起来的，B-树却不是。</li><li>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束</li><li>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</li></ul></blockquote><h3 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h3><p>B+树插入要记住这几个步骤：</p><blockquote><ol><li>B+树插入都是在叶子结点进行的，就是插入前，需要先找到要插入的叶子结点。</li><li>如果被插入关键字的叶子节点，当前含有的关键字数量是小于阶数m，则直接插入。</li><li>如果插入关键字后，叶子节点当前含有的关键字数目等于阶数m，则该节点开始<strong>「分裂」</strong>为两个新的节点，一个节点包含⌊m/2⌋ 个关键字，另外一个关键字包含⌈m/2⌉个关键值。（⌊m/2⌋表示向下取整，⌈m/2⌉表示向上取整，如⌈3/2⌉=2）。</li><li>分裂后，需要将第⌈m/2⌉的关键字上移到父结点。如果这时候父结点中包含的关键字个数小于m，则插入操作完成。</li><li>分裂后，需要将⌈m/2⌉的关键字上移到父结点。如果父结点中包含的关键字个数等于m，则继续分裂父结点。</li></ol></blockquote><p>以下面的这颗5阶的B+树（m为5）为例，5阶B+树的节点最多4个元素，最少2个元素：</p><ul><li>插入5，10，15，20</li></ul><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E6%8F%92%E5%85%A51.png"></p><ul><li><p>然后插入25，此时元素个数大于m-1，需要分裂：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E6%8F%92%E5%85%A52.png"></p></li><li><p>接着插入26，30，继续分裂：</p></li></ul><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E6%8F%92%E5%85%A53.png"></p><h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h3><p>B+树删除关键字，分这几种情况</p><ul><li>找到包含关键值的结点，如果关键字个数大于⌈m/2⌉-1，直接删除即可；</li><li>找到包含关键值的结点，如果关键字个数大于⌈m/2⌉-1，并且关键值是当前节点的最大（小）值，并且该关键值存在父子节点中，那么删除该关键字，同时需要相应调整父节点的值。</li><li>找到包含关键值的结点，如果删除该关键字后，关键字个数小于⌈m/2⌉，并且其兄弟结点有多余的关键字，则从其兄弟结点借用关键字</li><li>找到包含关键值的结点，如果删除该关键字后，关键字个数小于⌈m/2⌉，并且其兄弟结点没有多余的关键字，则与兄弟结点合并。</li></ul><h4 id="（1）如果关键字个数大于⌈m-2⌉，直接删除即可；"><a href="#（1）如果关键字个数大于⌈m-2⌉，直接删除即可；" class="headerlink" title="（1）如果关键字个数大于⌈m/2⌉，直接删除即可；"></a>（1）如果关键字个数大于⌈m/2⌉，直接删除即可；</h4><p>假设当前有这么一颗5阶的B+树</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A4.png"></p><p>如果删除22，因为关键字个数为3 &gt; ⌈5/2⌉-1=2， 直接删除（⌈⌉表示向上取整的意思）</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A41.gif"></p><h4 id="（2）如果关键字个数大于⌈m-2⌉-1，并且删除的关键字存在于父子节点中，那么需要相应调整父子节点的值"><a href="#（2）如果关键字个数大于⌈m-2⌉-1，并且删除的关键字存在于父子节点中，那么需要相应调整父子节点的值" class="headerlink" title="（2）如果关键字个数大于⌈m/2⌉-1，并且删除的关键字存在于父子节点中，那么需要相应调整父子节点的值"></a>（2）如果关键字个数大于⌈m/2⌉-1，并且删除的关键字存在于父子节点中，那么需要相应调整父子节点的值</h4><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A4.png"></p><p>如果删除20，因为关键字个数为3 &gt; ⌈5/2⌉-1=2，并且20是当前节点的边界值，且存在父子节点中，所以删除后，其父子节点也要响应调整。</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A42.gif"></p><h4 id="（3）如果删除该关键字后，关键字个数小于⌈m-2⌉-1，兄弟节点可以借用"><a href="#（3）如果删除该关键字后，关键字个数小于⌈m-2⌉-1，兄弟节点可以借用" class="headerlink" title="（3）如果删除该关键字后，关键字个数小于⌈m/2⌉-1，兄弟节点可以借用"></a>（3）如果删除该关键字后，关键字个数小于⌈m/2⌉-1，兄弟节点可以借用</h4><p>以下这颗5阶的B+树：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A42.png"></p><p>如果删除15,删除关键字的结点只剩1个关键字，小于⌈5/2⌉-1=2，不满足B+树特点，但是其兄弟节点拥有3个元素（7,8,9），可以借用9过来，如图：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A43.gif"></p><h4 id="（4）在删除关键字后，如果导致其结点中关键字个数不足，并且兄弟结点没有得借用的话，需要合并兄弟结点"><a href="#（4）在删除关键字后，如果导致其结点中关键字个数不足，并且兄弟结点没有得借用的话，需要合并兄弟结点" class="headerlink" title="（4）在删除关键字后，如果导致其结点中关键字个数不足，并且兄弟结点没有得借用的话，需要合并兄弟结点"></a>（4）在删除关键字后，如果导致其结点中关键字个数不足，并且兄弟结点没有得借用的话，需要合并兄弟结点</h4><p>以下这颗5阶的B+树：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A43.png"></p><p>如果删除关键字7，删除关键字的结点只剩1个关键字，小于⌈5/2⌉-1=2，不满足B+树特点，并且兄弟结点没法借用，因此发生合并，如下：</p><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/B+%E6%A0%91%E5%88%A0%E9%99%A44.gif"></p><h2 id="B树和B-树总结⭐"><a href="#B树和B-树总结⭐" class="headerlink" title="B树和B+树总结⭐"></a>B树和B+树总结⭐</h2><p>B+树相对于B树有一些自己的优势，可以归结为下面几点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合作为数据库MySQL的底层数据结构；</li><li>所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定；</li><li>所有的叶子节点形成了一个有序链表，更加便于查找；</li></ul><h2 id="B-树经典面试题"><a href="#B-树经典面试题" class="headerlink" title="B+树经典面试题"></a>B+树经典面试题</h2><ul><li>InnoDB一棵B+树可以存放多少行数据？</li><li>为什么索引结构默认使用B+树，而不是hash，二叉树，红黑树，B-树？</li><li>B-树和B+树的区别？</li></ul><h4 id="InnoDB一棵B-树可以存放多少行数据？"><a href="#InnoDB一棵B-树可以存放多少行数据？" class="headerlink" title="InnoDB一棵B+树可以存放多少行数据？"></a>InnoDB一棵B+树可以存放多少行数据？</h4><p>这个问题的简单回答是：约2千万行。</p><ul><li>在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。</li><li>文件系统中，最小单位是块，一个块大小就是4k；</li><li>InnoDB存储引擎最小储存单元是页，一页大小就是16k。</li></ul><p><img src="/2021/04/23/B%E6%A0%91%E4%B8%8EB+%E6%A0%91/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png"></p><p>因为B+树叶子存的是数据，内部节点存的是键值+指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而再去数据页中找到需要的数据；</p><p>假设B+树的高度为2的话，即有一个根结点和若干个叶子结点。这棵B+树的存放总记录数为=根结点指针数*单个叶子节点记录行数。</p><ul><li>如果一行记录的数据大小为1k，那么单个叶子节点可以存的记录数 =16k/1k =16.</li><li>非叶子节点内存放多少指针呢？我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170</li></ul><p>因此，一棵高度为2的B+树，能存放1170 * 16=18720条这样的数据记录。同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400，也就是说，可以存放<code>两千万左右</code>的记录。B+树高度一般为1-3层，已经满足千万级别的数据存储。</p><h4 id="为什么索引结构默认使用B-树，而不是B-Tree，Hash哈希，二叉树，红黑树？"><a href="#为什么索引结构默认使用B-树，而不是B-Tree，Hash哈希，二叉树，红黑树？" class="headerlink" title="为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树？"></a>为什么索引结构默认使用B+树，而不是B-Tree，Hash哈希，二叉树，红黑树？</h4><p>简单版回答如下：</p><ul><li>Hash哈希，只适合等值查询，不适合范围查询。</li><li>一般二叉树，可能会特殊化为一个链表，相当于全表扫描。</li><li>红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。</li><li>B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。</li></ul><h4 id="B-树和B-树的区别？"><a href="#B-树和B-树的区别？" class="headerlink" title="B-树和B+树的区别？"></a>B-树和B+树的区别？</h4><ul><li>B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</li><li>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</li><li>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束</li><li>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/HQe8g1M5ytZYLx5vvaAYoQ">[1] MySQL索引底层：B+树详解</a></p><p><a href="https://mp.weixin.qq.com/s/HQe8g1M5ytZYLx5vvaAYoQ">https://mp.weixin.qq.com/s/HQe8g1M5ytZYLx5vvaAYoQ</a></p><p><a href="https://blog.csdn.net/eternal_yangyun/article/details/102775550">[2] B树和B+树画图详解</a></p><p><a href="https://blog.csdn.net/eternal_yangyun/article/details/102775550">https://blog.csdn.net/eternal_yangyun/article/details/102775550</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2021/04/20/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/20/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP有什么用"><a href="#KMP有什么用" class="headerlink" title="KMP有什么用"></a>KMP有什么用</h2><p>KMP主要应用在<strong>字符串匹配</strong>上。</p><p>KMP的主要思想是<strong>「当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。」</strong></p><p>所以如何记录已经匹配的文本内容，是KMP的重点，也是<code>next数组</code>肩负的重任。</p><h2 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h2><p><code>next数组</code>就是一个前缀表（prefix table）。</p><p>前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，在重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p><p>那么什么是前缀表：<strong>「下表i之前（包括i）的字符串中，有多大长度的相同前缀后缀。」</strong></p><h2 id="为什么一定要用前缀表"><a href="#为什么一定要用前缀表" class="headerlink" title="为什么一定要用前缀表"></a>为什么一定要用前缀表</h2><blockquote><p><strong>找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了</strong></p></blockquote><p>所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p><h2 id="如何计算前缀表"><a href="#如何计算前缀表" class="headerlink" title="如何计算前缀表"></a>如何计算前缀表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构建next数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* next, <span class="hljs-keyword">const</span> string&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>;<span class="hljs-comment">//前缀表要统一减一的操作，所以j初始化为-1</span><br>next[<span class="hljs-number">0</span>] = j;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">// 前后缀不相同了</span><br>j = next[j];<span class="hljs-comment">// 向前回溯</span><br>&#125;<br><span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>])j++;<span class="hljs-comment">// 找到相同的前后缀</span><br>next[i] = j;<span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前缀表统一减一操作：避免进入死循环</p><p>不过后续取前缀表里的数值的时候，要记得再+1，才是我们想要的值</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>假设文本串长度为 $ n $，模式串长度为 $m$</p><p>其中 $ n $ 为文本串长度， $m$ 为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是 $O(n)$ ，但之前还要单独生成<code>next数组</code>，时间复杂度是 $O(m)$ ，所以整个KMP算法的时间复杂度是 $O(n+m)$ 的。</p><p>暴力的解法显而易见是 $O(n * m)$ ，所以<strong>「KMP在字符串匹配中极大的提高的搜索的效率。」</strong></p><h2 id="实现-strStr（）"><a href="#实现-strStr（）" class="headerlink" title="实现  strStr（）"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">实现  strStr（）</a></h2><h3 id="实现-strStr-函数。"><a href="#实现-strStr-函数。" class="headerlink" title="实现 strStr() 函数。"></a>实现 strStr() 函数。</h3><blockquote><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p></blockquote><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><blockquote><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。</p></blockquote><p>示例 1：</p><blockquote><p>输入：haystack = “hello”, needle = “ll”<br>输出：2</p></blockquote><p>示例 2：</p><blockquote><p>输入：haystack = “aaaaa”, needle = “bba”<br>输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：haystack = “”, needle = “”<br>输出：0</p></blockquote><h3 id="使用next数组来做匹配"><a href="#使用next数组来做匹配" class="headerlink" title="使用next数组来做匹配"></a>使用next数组来做匹配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 因为next数组里记录的起始位置为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>        j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>        j++; <span class="hljs-comment">// i的增加在for循环里</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>        <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构建next数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* next, <span class="hljs-keyword">const</span> string&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>;<span class="hljs-comment">//前缀表要统一减一的操作，所以j初始化为-1</span><br>next[<span class="hljs-number">0</span>] = j;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">// 前后缀不相同了</span><br>j = next[j];<span class="hljs-comment">// 向前回溯</span><br>&#125;<br><span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>])j++;<span class="hljs-comment">// 找到相同的前后缀</span><br>next[i] = j;<span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>&#125;<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span>* next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[needle.<span class="hljs-built_in">size</span>()];  <span class="hljs-comment">//使用动态数组分配</span><br><span class="hljs-built_in">getNext</span>(next, needle);<span class="hljs-comment">//前缀表</span><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 因为next数组里记录的起始位置为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">// 不匹配</span><br>j = next[j];<span class="hljs-comment">// j 寻找之前匹配的位置</span><br>&#125;<br><span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>])j++;    <span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">delete</span>[]next;<span class="hljs-comment">//释放</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&amp;mid=2247484428&amp;idx=1&amp;sn=c0e5573f5fe3b438dbe75f93f3f164fa&amp;scene=21#wechat_redirect">字符串： KMP是时候上场了（一文读懂系列）</a></p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列化二叉树</title>
    <link href="/2021/04/19/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/04/19/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">题目描述</a></h2><p>实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>你可以将以下二叉树：</p><p><img src="/2021/04/19/%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/erchashu.PNG"></p><p>序列化为 “[1,2,3,null,null,4,5]”</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>序列化</strong> 使用层序遍历实现。<strong>反序列化</strong> 通过以上递推公式反推各节点在序列中的索引，进而实现。</p><p><strong>序列化 Serialize ：</strong><br>借助队列，对二叉树做层序遍历，并将越过叶节点的 <code>null</code> 也打印出来。</p><p>算法流程：</p><ol><li><p><strong>特例处理</strong>： 若 <code>root</code> 为空，则直接返回空列表 <code>&quot;[]&quot;</code> ；</p></li><li><p><strong>初始化</strong>： 队列 <code>q</code> （包含根节点 <code>root</code> ）；序列化列表 ret ；</p></li><li><p><strong>层序遍历</strong>： 当 <code>q</code> 为空时跳出；</p><ol><li><p>节点出队，记为 <code>node</code> ；</p></li><li><p>若 <code>node</code> 不为空：① 打印字符串 <code>node-&gt;val</code> ，② 将左、右子节点加入 <code>q</code> ；</p></li><li><p>否则（若 <code>node</code> 为空）：打印字符串 <code>&quot;null&quot;</code> ；</p></li></ol></li><li><p>返回值： 拼接列表，用 <code>&#39;,&#39;</code> 隔开，首尾添加中括号；</p></li></ol><p>复杂度分析：</p><ul><li><strong>时间复杂度</strong> $ O(N) $： $ N $ 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 $ N+1 $ 个 <code>null</code> ，总体复杂度为 $ O(2N+1)=O(N) $ 。</li><li><strong>空间复杂度</strong> $ O(N) $： 最差情况下，队列 <code>q</code> 同时存储 $\frac{N+1}{2} $个节点（或 $ N+1 $ 个 <code>null</code> ），使用 $ O(N) $ ；列表 <code>ret</code> 使用 $ O(N) $ 。</li></ul><p><strong>反序列化 Deserialize ：</strong><br>基于本文开始推出的 <code>node</code> , <code>node-&gt;left</code> , <code>node-&gt;right</code> 在序列化列表中的位置关系，可实现反序列化。</p><p>利用队列按层构建二叉树，借助一个字符串 <code>str</code> 指向节点 <code>node</code> 的左、右子节点，每构建一个 <code>node</code> 的左、右子节点，字符串<code>str</code> 就更新。</p><p>算法流程：</p><ol><li><p><strong>特例处理</strong>： 若 <code>data</code> 为空，直接返回 <code>null</code> ；</p></li><li><p><strong>初始化</strong>： 序列化列表 <code>iss</code>（先去掉首尾中括号），使用函数<code>getline</code>分解<code>iss</code>为<code>str</code> ，根节点 <code>root</code> （值为 <code>atoi(str.c_str()</code>) ），队列 <code>q</code>（包含 <code>root</code> ）；</p></li><li><p><strong>按层构建</strong>： 当 <code>q</code> 为空时跳出；</p><ol><li>节点出队，记为 <code>node</code> ；</li><li>分解<code>iss</code>：<code>getline(iss, str, &#39;,&#39;)</code> ;</li><li>构建 <code>node</code> 的左子节点：<code>node-&gt;left</code> 的值为 <code>atoi(str.c_str()</code> ，并将 <code>node-&gt;left</code> 入队 ；</li><li>分解<code>iss</code>：<code>getline(iss, str, &#39;,&#39;)</code> ;</li><li>构建 <code>node</code> 的右子节点：<code>node-&gt;right</code> 的值为 <code>atoi(str.c_str()</code> ，并将 <code>node-&gt;right</code>入队 ；</li></ol></li><li><p><strong>返回值</strong>： 返回根节点 <code>root</code> 即可；<br>   复杂度分析：<br>   时间复杂度 $ O(N) $ ： $ N $ 为二叉树的节点数，按层构建二叉树需要遍历整个 $ iss $ ，其长度最大为 $ 2N+1 $ 。<br>   空间复杂度 $ O(N) $ ： 最差情况下，队列 <code>q</code> 同时存储 $ \frac{N + 1}{2} $个节点，因此使用 $ O(N) $ 额外空间。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br>        string ret = <span class="hljs-string">&quot;[&quot;</span>;<br>        queue&lt;TreeNode*&gt;q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                ret+=<span class="hljs-built_in">to_string</span>(node-&gt;val);<br>                ret += <span class="hljs-string">&quot;,&quot;</span>;<br>                q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ret += <span class="hljs-string">&quot;null,&quot;</span>;<br>            &#125;<br>        &#125;<br>        ret.<span class="hljs-built_in">pop_back</span>();<br>        ret += <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-string">&quot;[]&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-function">stringstream <span class="hljs-title">iss</span><span class="hljs-params">(data.substr(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">2</span>))</span></span>;   <span class="hljs-comment">//iss为去掉[ ]的输入流</span><br>        string str;<br>        <span class="hljs-built_in">getline</span>(iss, str, <span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">//从输入流iss读入的字符存入str中，遇到&#x27;,&#x27;停止读入</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">c_str</span>()));<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">getline</span>(iss, str, <span class="hljs-string">&#x27;,&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;null&quot;</span>)<br>            &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">c_str</span>()));<br>                q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-built_in">getline</span>(iss, str, <span class="hljs-string">&#x27;,&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (str != <span class="hljs-string">&quot;null&quot;</span>)<br>            &#123;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(str.<span class="hljs-built_in">c_str</span>()));<br>                q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树 Tree</title>
    <link href="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
    <url>/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h1><p>树形结构相比数组、链表、堆栈这些数据结构来说，稍微复杂一点点，但树形结构可以用于解决很多实际问题，因为现实世界事物之间的关系往往不是线性关联的，而「树」恰好适合描述这种非线性关系。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>线性结构中节点是首位相接一对一关系，在树结构中节点之间不再是简单的一对一关系，而是较为复杂的一对多的关系，一个节点可以与多个节点发生关联，树是一种层次化的数据组织形式，树在现实中是可以找到例子的，比如现实中的族谱，亲戚之间的关系是层次关联的树形关系。</p><p>数据结构中的「树」的名字由来，是因为如果把节点之间的关系直观展示出来，由于长得和现实世界中的树很像，由此得名。如图：</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/link.png"></p><h3 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h3><p>树形数据结构，具有以下的结构特点：</p><ul><li>每个节点都只有有限个子节点或无子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路，意思就是从一个节点出发，除非往返，否则不能回到起点。</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树中每个节点的度不大于 2 ，即它的每个节点最多只有两个分支，通常称二叉树节点的左右两个分支为左右子树。</p><p>二叉树是很多其他树型结构的基础结构，比如下面要讲的 <code>AVL 树</code>、<code>二叉查找树</code>，他们都是由二叉树增加一些约束条件进化而来。</p><h3 id="三种遍历方式"><a href="#三种遍历方式" class="headerlink" title="三种遍历方式"></a>三种遍历方式</h3><p>二叉树的遍历就是逐个访问二叉树节点的数据，常见的二叉树遍历方式有三种，分别是前中后序遍历，初学者分不清这几个顺序的差别。</p><p><strong>「有个简单的记忆方式，这里的「前中后」都是对于根节点而言」</strong>。</p><p>先访问根节点后访问左右子树的遍历方式是前序遍历，先访问左右子树最后访问根节点的遍历方式是后序遍历，先访问左子树再访问根节点最后访问右子树的遍历方式是中序遍历，下面详细说明：</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/erchashu.png"></p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>遍历顺序是根节点-&gt;左子树-&gt;右子树</p><p>遍历的得到的序列是：<code>1 2 4 5 3 6 7</code></p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>遍历顺序是左子树-&gt;根节点-&gt;右子树</p><p>遍历的得到的序列是：<code>4 2 5 1 6 3 7</code></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>遍历顺序是左子树-&gt;右子树-&gt;根节点</p><p>遍历的得到的序列是：<code>4 5 2 6 7 3 1</code></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>由于最基础的二叉树节点是无序的，想象一下如果在二叉树中查找一个数据，最坏情况可能要要遍历整个二叉树，这样的查找效率是非常低下的。</p><p>由于基础二叉树不利于数据的查找和插入，因此我们有必要对二叉树中的数据进行排序，所以就有了「二叉查找树」，可以说这种树是为了查找而生的二叉树，有时也称它为「二叉排序树」，都是同一种结构，只是换了个叫法。</p><p>二叉查找树理解了也不难，简单来说就是二叉树上所有节点的，<strong>左子树上的节点都小于根节点，右子树上所有节点的值都大于根节点</strong>。</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/erchachazhaoshu.png"></p><p>这样的结构设计，使得查找目标节点非常方便，可以通过关键字和当前节点的对比，很快就能知道目标节点在该节点的左子树还是右子树上，方便在树中搜索目标节点。</p><p>如果对<strong>排序二叉树执行中序遍历</strong>，因为<strong>中序遍历的顺序是：左子树-&gt;根节点-&gt;右子树</strong>，最终可以得到一个节点值的有序列表。</p><p>举个栗子：对上图的排序二叉树执行中序遍历，我们可以得到一个有序序列：<code>1 2 3 4 5 6 7</code></p><h3 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h3><p>二叉查找树的查询复杂度取决于目标节点的深度，因此当节点的深度比较大时，最坏的查询效率是<code>O(n)</code>，其中n是树中的节点个数。</p><p>实际应用中有很多改进版的二叉查找树，目的是尽可能使得每个节点的深度不要过深，从而提高查询效率。比如AVL树和红黑树，可以将最坏效率降低至<code>O(log n)</code>，下面我们就来看下这两种改进的二叉树。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>AVL 也叫<strong>平衡二叉查找树</strong>。AVL 这个名字的由来，是它的两个发明者G. M. Adelson-Velsky 和 Evgenii Landis 的缩写，AVL最初是他们两人在1962 年的论文「An algorithm for the organization of information」中提出来一种数据结构。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AVL树有更严格的定义：在二叉查找树中，任一节点对应的两棵子树的最大高度差为 1，这样的二叉查找树称为平衡二叉树。其中左右子树的高度差也有个专业的叫法：平衡因子。</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/AVLshu.png"></p><h3 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h3><p>一旦由于插入或删除导致左右子树的高度差大于1，此时就需要旋转某些节点调整树高度，使其再次达到平衡状态，这个过程称为旋转再平衡。</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/AVLxuanzhuan.png"></p><p>保持树平衡的目的是可以控制查找、插入和删除在平均和最坏情况下的时间复杂度都是<code>O(log n)</code>，相比普通二叉树最坏情况的时间复杂度是 <code>O(n)</code> ，AVL树把最坏情况的复杂度控制在可接受范围，非常合适对算法执行时间敏感类的应用。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是鲁道夫·拜尔（Rudolf Bayer）1972年在波音研究实验室（Boeing Research Labs）工作时发明的，关于B树名字的由来至今是个未解之谜，有人猜是Bayer的首字母，也有人说是波音实验室（Boeing Research Labs）的Boeing首字母缩写，虽然B树这个名字来源扑朔迷离，我们心里也没点 B 树，但不影响今天我们来学习它。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个 m 阶的 B树 是一个有以下属性的树</p><ol><li>每一个节点最多有 m 个子节点</li><li>每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点，⌈m/2⌉ 表示向上取整。</li><li>如果根节点不是叶子节点，那么它至少有两个子节点</li><li>有 k 个子节点的非叶子节点拥有 k − 1 个键</li><li>所有的叶子节点都在同一层</li></ol><p>如果之前不了解，相信第一眼看完定义肯定是蒙圈，不过多看几遍好好理解一下就好了，画个图例，对照着看看：</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/bshu.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>B树是所有节点的平衡因子均等于0的多路查找树（ AVL树 是平衡因子不大于 1 的二叉查找树）。</li><li>B 树节点可以保存多个数据，使得 B 树可以不用像 AVL 树那样为了保持平衡频繁的旋转节点。</li><li>B树的多路的特性，降低了树的高度，所以B树相比于平衡二叉树显得矮胖很多。</li><li>B树非常适合保存在磁盘中的数据读取，因为每次读取都会有一次磁盘IO，高度降低减少了磁盘IO的次数。</li></ul><p>B树常用于实现<strong>数据库索引</strong>，典型的实现，<strong>MongoDB索引</strong>用<code>B树</code>实现，<strong>MySQL的Innodb 存储引擎</strong>用 <code>B+树</code> 存放索引。</p><p>说到B树不得不提起它的好兄弟B+树，不过这里不展开细说，只需知道，B+树是对B树的改进，数据都放在叶子节点，非叶子节点只存数据索引。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树也是一种特殊的「二叉查找树」。</p><p>到目前为止我们学习的 AVL 树和即将学习的红黑树都是二叉查找树的变体，可见二叉查找树真的是非常重要基础二叉树，如果忘了它的定义可以先回头看看。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>红黑树中每个结点都被标记了红黑属性，红黑树除了有普通的「二叉查找树」特性之外，还有以下的特征：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>这些性质有兴趣可以自行研究，不过，现在你只需要知道，这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/hongheishu.png"></p><p>而节点的路径长度决定着对节点的查询效率，这样我们确保了，最坏情况下的查找、插入、删除操作的时间复杂度不超过<code>O(log n)</code>，并且有较高的插入和删除效率。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>红黑树在实际应用中比较广泛，有很多已经落地的实践，比如学习C++的同学都知道会接触到 STL 标准库，而STL容器中的<code>map</code>、<code>set</code>、<code>multiset</code>、<code>multimap</code> 底层实现都是基于红黑树。</p><p>再比如，Linux内核中也有红黑树的实现，Linux系统在实现<code>EXT3文件系统</code>、<code>虚拟内存管理系统</code>，都有使用到红黑树这种数据结构。</p><h2 id="红黑树-VS-平衡二叉树（AVL树）"><a href="#红黑树-VS-平衡二叉树（AVL树）" class="headerlink" title="红黑树  VS  平衡二叉树（AVL树）"></a>红黑树  VS  平衡二叉树（AVL树）</h2><ul><li>插入和删除操作，一般认为红黑树的删除和插入会比 AVL 树更快。因为，红黑树不像 AVL 树那样严格的要求平衡因子小于等于1，这就减少了为了达到平衡而进行的旋转操作次数，可以说是牺牲严格平衡性来换取更快的插入和删除时间。</li><li>红黑树不要求有不严格的平衡性控制，但是红黑树的特点，使得任何不平衡都会在<strong>三次旋转</strong>之内解决。而 AVL 树如果不平衡，并不会控制旋转操作次数，旋转直到平衡为止。</li><li>查找操作，AVL树的效率更高。因为 AVL 树设计比红黑树更加平衡，不会出现平衡因子超过 1 的情况，减少了树的平均搜索长度。</li></ul><h2 id="Trie树（前缀树或字典树）"><a href="#Trie树（前缀树或字典树）" class="headerlink" title="Trie树（前缀树或字典树）"></a>Trie树（前缀树或字典树）</h2><p>Trie来源于单词 retrieve（检索），Trie树也称为前缀树或字典树。利用字符串前缀来查找指定的字符串，缩短查找时间提高查询效率，主要用于字符串的快速查找和匹配。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>Trie的核心思想是空间换时间，有 3 个基本性质：</p><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ol><p>比如对单词序列<code>lru, lua, mem, mcu</code> 建立Trie树如下：</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/Tire.png"></p><p>Trie树建立和查询是可以同步进行的，可以在还没建立出完成的 Trie 树之前就找到目标数据，而如果用 Hash 表等结构存储是需要先建立完成表才能开始查询，这也是 Trie 树查询速度快的原因。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Trie树还用于搜索引擎的关键词提示功能。比如当你在搜索框中输入检索单词的开头几个字，搜索引擎就可以自动联想匹配到可能的词组出来，这正是Trie树的最直接应用。</p><p><img src="/2021/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/sousuo.png"></p><p>这种结构在海量数据查询上很有优势，因为不必为了找到目标数据遍历整个数据集合，只需按前缀遍历匹配的路径即可找到目标数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>树形数据结构有许多变种，这篇文章我们从树开始，把几种常见树形数据结构学习了一遍，包括二叉树、二叉查找树（二叉搜索树）、AVL树、红黑树、B树、Trie树。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序</title>
    <link href="/2021/04/15/7_%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/04/15/7_%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p><strong>桶排序 (Bucket sort)<strong>或所谓的</strong>箱排序</strong>，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><p>桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间<code>O(n)</code>。但桶排序并不是 比较排序，他不受到 <code>O(n log n)</code> 下限的影响。</p><h2 id="存在重复的元素III"><a href="#存在重复的元素III" class="headerlink" title="存在重复的元素III"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">存在重复的元素III</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        std::unordered_map&lt;<span class="hljs-keyword">int64_t</span>, <span class="hljs-keyword">int64_t</span>&gt; bucket; <span class="hljs-comment">// id - 元素</span><br><br>        <span class="hljs-keyword">int64_t</span> width = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int64_t</span>&gt;(t) +<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">int64_t</span> num = nums[i];<br>            <span class="hljs-keyword">int64_t</span> id = <span class="hljs-built_in">getId</span>(num, width);<br><br>            <span class="hljs-keyword">if</span>(bucket.<span class="hljs-built_in">count</span>(id)                                          ||<br>               bucket.<span class="hljs-built_in">count</span>(id<span class="hljs-number">-1</span>) &amp;&amp; std::<span class="hljs-built_in">abs</span>(num - bucket[id<span class="hljs-number">-1</span>]) &lt;width || <br>               bucket.<span class="hljs-built_in">count</span>(id+<span class="hljs-number">1</span>) &amp;&amp; std::<span class="hljs-built_in">abs</span>(num - bucket[id+<span class="hljs-number">1</span>]) &lt;width )<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 桶的编号 - 数</span><br>            bucket.<span class="hljs-built_in">emplace</span>(id, num);<br>            <br>            <span class="hljs-comment">// 让bucket中只有k个桶，i==k时说明，已经有k+1个桶</span><br>            <span class="hljs-keyword">if</span>(i &gt;=k) <br>            &#123;<br>                bucket.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getId</span>(nums[i-k], width));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int64_t</span> <span class="hljs-title">getId</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> x, <span class="hljs-keyword">int64_t</span> width)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> ? (x+<span class="hljs-number">1</span>)/width<span class="hljs-number">-1</span> : x / width;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p><strong>算法思想</strong>：</p><ol><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ol><p><img src="/2021/04/15/7_%E6%A1%B6%E6%8E%92%E5%BA%8F/20190219081232815.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bucketsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-comment">//计算最大值与最小值</span><br><span class="hljs-keyword">int</span> maxi = INT_MIN;<br><span class="hljs-keyword">int</span> mini = INT_MAX;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>maxi = <span class="hljs-built_in">max</span>(maxi, nums[i]);<br>mini = <span class="hljs-built_in">min</span>(mini, nums[i]);<br>&#125;<br><span class="hljs-comment">//计算桶的数量</span><br><span class="hljs-keyword">int</span> bucketnum = ((maxi - mini) / nums.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">bucketArr</span>(bucketnum);<br><span class="hljs-comment">//将每个元素放入桶中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">int</span> j = (nums[i] - mini) / nums.<span class="hljs-built_in">size</span>();<br>bucketArr[j].<span class="hljs-built_in">push_back</span>(nums[i]);<br>&#125;<br><span class="hljs-comment">//对每个桶进行排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketArr.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-built_in">sort</span>(bucketArr[i].<span class="hljs-built_in">begin</span>(), bucketArr[i].<span class="hljs-built_in">end</span>());<br>&#125;<br><span class="hljs-comment">//将桶中的元素赋值到原序列</span><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketArr.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketArr[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>nums[index++] = bucketArr[i][j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bucketSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;nums)</span> </span>&#123;<br><span class="hljs-built_in">bucketsort</span>(nums);<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线编程常见输入输出练习</title>
    <link href="/2021/04/15/OJ%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/04/15/OJ%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="OJ在线编程常见输入输出练习"><a href="#OJ在线编程常见输入输出练习" class="headerlink" title="OJ在线编程常见输入输出练习"></a>OJ在线编程常见输入输出练习</h1><h2 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B    (1)"></a>A+B    (1)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/A">题目描述</a></h3><p>计算a+b</p><p><strong>输入描述</strong></p><blockquote><p>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据包括多组。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出a+b的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>1 5<br>10 20</p></blockquote><p><code>输出</code></p><blockquote><p>6</p><p>30</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)&#123;<br>        cout&lt;&lt;a+b&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B    (2)"></a>A+B    (2)</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/B">题目描述</a></h3><p>计算a+b</p><p><strong>输入描述</strong></p><blockquote><p>输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)<br>接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9)</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出a+b的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>2<br>1 5<br>10 20</p></blockquote><p><code>输出</code></p><blockquote><p>6</p><p>30</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,a,b;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt; a + b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B    (3)"></a>A+B    (3)</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/C">题目描述</a></h3><p>计算a+b</p><p><strong>输入描述</strong></p><blockquote><p>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出a+b的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>1 5<br>10 20<br>0 0</p></blockquote><p><code>输出</code></p><blockquote><p>6</p><p>30</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a &gt;&gt; b &amp;&amp; a != <span class="hljs-number">0</span> &amp;&amp; b != <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; a + b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B    (4)"></a>A+B    (4)</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/D">题目描述</a></h3><p>计算一系列数的和</p><p><strong>输入描述</strong></p><blockquote><p>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>每组数据输出求和的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>4 1 2 3 4<br>5 1 2 3 4 5<br>0</p></blockquote><p><code>输出</code></p><blockquote><p>10<br>15</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-keyword">int</span> n;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       cin &gt;&gt; n;<br>       <span class="hljs-keyword">int</span> x,sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++) &#123;<br>           cin &gt;&gt; x;<br>           sum += x;<br>       &#125;<br>       cout &lt;&lt; sum &lt;&lt; endl;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-5"><a href="#A-B-5" class="headerlink" title="A+B    (5)"></a>A+B    (5)</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/E">题目描述</a></h3><p>计算一系列数的和</p><p><strong>输入描述</strong></p><blockquote><p>输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>每组数据输出求和的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>2<br>4 1 2 3 4<br>5 1 2 3 4 5</p></blockquote><p><code>输出</code></p><blockquote><p>10<br>15</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n,m,sum,a;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; m;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            cin &gt;&gt; a;<br>            sum += a;<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B    (6)"></a>A+B    (6)</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/F">题目描述</a></h3><p>计算一系列数的和</p><p><strong>输入描述</strong></p><blockquote><p>输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>每组数据输出求和的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>4 1 2 3 4<br>5 1 2 3 4 5</p></blockquote><p><code>输出</code></p><blockquote><p>10<br>15</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n)&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>            <span class="hljs-keyword">int</span> a;<br>            cin &gt;&gt; a;<br>            sum += a;<br>        &#125;<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B    (7)"></a>A+B    (7)</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/G">题目描述</a></h3><p>计算一系列数的和</p><p><strong>输入描述</strong></p><blockquote><p>输入数据有多组, 每行表示一组输入数据。</p><p>每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>每组数据输出求和的结果</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>1 2 3<br>4 5<br>0 0 0 0 0</p></blockquote><p><code>输出</code></p><blockquote><p>6<br>9<br>0</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x,sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; x) &#123;<br>        sum += x;<br>        <span class="hljs-keyword">if</span>(cin.<span class="hljs-built_in">get</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            cout &lt;&lt; sum&lt;&lt; endl;<br>            sum = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序    (1)"></a>字符串排序    (1)</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/H">题目描述</a></h3><p>对输入的字符串进行排序后输出</p><p><strong>输入描述</strong></p><blockquote><p>输入有两行，第一行n</p><p>第二行是n个空格隔开的字符串</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>输出一行排序后的字符串，空格隔开，无结尾空格</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>5<br>c d a bb e</p></blockquote><p><code>输出</code></p><blockquote><p>a bb c d e</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>    </span><br><span class="hljs-function">    <span class="hljs-keyword">int</span> n</span>;    <br>    cin &gt;&gt; n;<br>    vector&lt;string&gt; str;<br>    string x;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; x)&#123;<br>        str.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        cout &lt;&lt; str[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序    (2)"></a>字符串排序    (2)</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/I">题目描述</a></h3><p>对输入的字符串进行排序后输出</p><p><strong>输入描述</strong></p><blockquote><p>多个测试用例，每个测试用例一行。</p><p>每行通过空格隔开，有n个字符，n＜100</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>a c bb<br>f dddd<br>nowcoder</p></blockquote><p><code>输出</code></p><blockquote><p>a bb c<br>dddd f<br>nowcoder</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    vector&lt;string&gt; vec;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; a)&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-keyword">if</span>(cin.<span class="hljs-built_in">get</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> s : vec)<br>                cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>            vec.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序    (3)"></a>字符串排序    (3)</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a><a href="https://ac.nowcoder.com/acm/contest/5657/J">题目描述</a></h3><p>对输入的字符串进行排序后输出</p><p><strong>输入描述</strong></p><blockquote><p>多个测试用例，每个测试用例一行。</p><p>每行通过空格隔开，有n个字符，n＜100</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>对于每组用例输出一行排序后的字符串，用’,’隔开，无结尾空格</p></blockquote><p><strong>示例1</strong></p><p><code>输入</code></p><blockquote><p>a,c,bb<br>f,dddd<br>nowcoder</p></blockquote><p><code>输出</code></p><blockquote><p>a,bb,c<br>dddd,f<br>nowcoder</p></blockquote><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        vector&lt;string&gt;str;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                str.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(pos, i - pos));<br>                pos = i + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                str.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(pos, i - pos + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; str[i] &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; str[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2021/04/14/5_selectSort/"/>
    <url>/2021/04/14/5_selectSort/</url>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="selectSort"><a href="#selectSort" class="headerlink" title="selectSort"></a>selectSort</h2><p>相比较vector，更加适用于链表</p><p><img src="/2021/04/14/5_selectSort/selectSort.png"></p><p>思想：</p><ul><li>无序的前缀和有序的后缀</li><li>前缀不大于后缀</li></ul><p>因此每次从前缀中选择出最大值元素，并且作为最小值转移到后缀中，不断地迭代就可以是的整体有序。</p><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。</p><p>那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。</p><p>比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序是一个<strong>不稳定</strong>的排序算法。</p><p><img src="/2021/04/14/5_selectSort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif"></p><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>以此类推，直到所有元素均排序完毕</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span> minIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>minIndex = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; ++j) &#123;<br><span class="hljs-keyword">if</span> (nums[j] &lt; nums[minIndex]) minIndex = j;<br>&#125;<br><span class="hljs-built_in">swap</span>(nums[i], nums[minIndex]);<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">selectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br><span class="hljs-built_in">selectsort</span>(data);<br><span class="hljs-keyword">return</span> data;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>对于链表而言，每次搜索无序序列中的最大值的时间复杂度是<code>O(n)</code>。因此对所有的节点进行排序，时间复杂度是<code>O(n^2)</code>，<strong>注意选择排序的时间复杂度恒定是</strong><code>O(n^2)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2021/04/14/6_%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/04/14/6_%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序，其实也是选择排序，只是利用优先级队列这个特征，能够在<code>O(1)</code>寻找到最大值元素加入有序序列。</p><ul><li>相比归并排序的<code>O(nlogn)</code>时间复杂度，堆排序常系数可以更小</li><li>实现<code>O(1)</code>的空间复杂度</li></ul><p>由于属于选择排序，因此思想一致：分为无序的前缀<code>H</code>和有序的后缀 <code>S</code>,前者不大于后者。不断地从 <code>H</code>中选取最大的元素到 <code>S</code>中。</p><p><img src="/2021/04/14/6_%E5%A0%86%E6%8E%92%E5%BA%8F/heapSort.png"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>交换操作只是需要常量时间，下滤操作不超过<code>O(logn)</code>，因此全部排序完成不超过<code>O(nlogn)</code>。归并排序是恒定的<code>O(nlogn)</code>复杂度，堆排序的常系数更小。加上建堆的<code>O(n)</code>时间，也不超过<code>O(nlogn)</code></p><p><img src="/2021/04/14/6_%E5%A0%86%E6%8E%92%E5%BA%8F/hheapSort_code.png"></p><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p>思想：</p><ol><li>先把数组转化为堆</li><li>把最后一个节点与根节点交换</li><li>对交换后的根节点继续进行heapify</li></ol><p>参考：<a href="https://www.bilibili.com/video/BV1Eb41147dK?from=search&seid=3993837508839965022">堆排序(heapsort)</a></p><p><img src="/2021/04/14/6_%E5%A0%86%E6%8E%92%E5%BA%8F/849589-20171015231308699-356134237.gif"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//对有一定顺序的堆，</span></span><br><span class="hljs-function">    <span class="hljs-comment">//当前第i个结点取根左右的最大值（这个操作称heapfiy）</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> max = i;<br>        <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[max])<br>            max = l;<br>        <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[max])<br>            max = r;<br>        <span class="hljs-keyword">if</span> (max != i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[max], nums[i]);<br>            <span class="hljs-built_in">heapify</span>(nums, n, max);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify_build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//建立大根堆，从树的倒数第二层第一个结点开始，</span></span><br><span class="hljs-function">    <span class="hljs-comment">//对每个结点进行heapify操作，然后向上走</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> last_node = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> parent = (last_node - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = parent; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-built_in">heapify</span>(nums, n, i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//建立大根堆之后，每次交换最后一个结点和根节点（最大值），</span></span><br><span class="hljs-function">    <span class="hljs-comment">//对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">heapify_build</span>(nums, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[<span class="hljs-number">0</span>]);<br>            <span class="hljs-built_in">heapify</span>(nums, i, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">heapifySort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">heapify_sort</span>(nums, n);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2021/04/13/4_insertSort/"/>
    <url>/2021/04/13/4_insertSort/</url>
    
    <content type="html"><![CDATA[<h1 id="insertSort"><a href="#insertSort" class="headerlink" title="insertSort"></a>insertSort</h1><p>插入排序的思想：始终将整个序列视为两个部分，有序的前缀和无序的后缀；通过反复的迭代，反复地将后缀的首元素转移至前缀中。</p><p>更加实用于链表</p><blockquote><p><strong>在任何时刻，相对于当前节点e=s[r], 前缀部分[0, r)总是有序</strong>，那么就可以用有序序列的查找算法，在前缀中查找到小于等于e的最大元素的位置，然后将当前节点e插入找到的位置之后插入。 如果存在重复元素，那么就是插在最后一个重复元素之后。</p></blockquote><p><img src="/2021/04/13/4_insertSort/insertSort.png" alt="insertSort"></p><blockquote><p><strong>以链表为例： 因为链表插入排序方便，vector每次插入一个位置，都得后移</strong></p></blockquote><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>当序列完全有序的时候  <code>O(n)</code>，完全逆序的时候则时  <code>O(n^2)</code>。<strong>时间复杂度平均意义</strong>下还是 <code>O(n^2)</code> 。</p><h2 id="与选择排序的比较"><a href="#与选择排序的比较" class="headerlink" title="与选择排序的比较"></a>与选择排序的比较</h2><p>有最好的情况，而选择排序没有，选择排序的复杂度恒定  <code>O(nlogn)</code>，而插入排序与逆序对数据有关，</p><ul><li>插入排序是输入敏感性的排序，如果数据本身是有序的，那么整个排序就是  <code>O(n)</code>，只是需要扫描一趟即可。</li><li>插入排序是在线排序的，即数据来一点就可以排序一点，而选择排序是需要全部数据后才能排序。插入排序可以数据有一点就排序一点</li></ul><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。</p><p>当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。</p><p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。</p><p>所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以<strong>插入排序是稳定</strong>的。</p><p><img src="/2021/04/13/4_insertSort/insert.gif"></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong>算法实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] &lt; a[i - <span class="hljs-number">1</span>]) &#123;   <span class="hljs-comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><br>                <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> x = a[i];     <span class="hljs-comment">//复制为哨兵，即存储待排序元素</span><br>                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; a[j]) &#123;   <span class="hljs-comment">//查找在有序表的插入位置,还必须要保证j是&gt;=0的 因为a[j]要合法</span><br>                    a[j + <span class="hljs-number">1</span>] = a[j];<br>                    j--;     <span class="hljs-comment">//元素后移</span><br>                &#125;<br>                a[j + <span class="hljs-number">1</span>] = x;     <span class="hljs-comment">//插入到正确位置</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">insertSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-built_in">insertsort</span>(data);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2021/04/12/3_bubbleSort/"/>
    <url>/2021/04/12/3_bubbleSort/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡法-BubbleSort"><a href="#冒泡法-BubbleSort" class="headerlink" title="冒泡法 BubbleSort"></a>冒泡法 BubbleSort</h1><p>冒泡法排序是排序算法中的基本方法，其时间复杂度是<code>O(n^2)</code>。</p><h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>冒泡法，每一趟遍历都会消除一些逆序对，让最大值元素归位。比如第一趟遍历让最大值元素归位，第二趟让第二大元素归位，一直到第n趟让第n大，也就是最小的元素归位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">size_t</span> hi = arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> lo=<span class="hljs-number">0</span>; lo &lt; hi--; ++lo) &#123; <br>        <span class="hljs-comment">// 这其实就相当于在每趟遍历中，都当前未归位的最大值元素归位</span><br>        <span class="hljs-comment">// hi-- 表示从最后一个归位的元素不考虑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> lo=<span class="hljs-number">0</span>; lo &lt; hi; ++lo) &#123; <br>            <span class="hljs-keyword">if</span>(arr[lo] &gt; arr[lo+<span class="hljs-number">1</span>]) <br>                std::<span class="hljs-built_in">swap</span>(arr[lo], arr[lo+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这其实也是一种贪心的思想体现：因为只要将遇到的所有“逆序对”消除，那么就是一个有序的序列，而冒泡排序就是每遇到一个逆序对就修正这个逆序对，消除他，通过n趟的迭代，那么就能消除所有的逆序对，就会变得有序。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>毫无疑问是<code>O(n^2)</code>。即使是一个有序的序列，用冒泡法时间复杂度依然是O(n^2)。因为在每一轮迭代中，只是考虑逆序对，将最大未归位元素归位。可是如果前面的部分元素已经归位，那么是否可以直接跳过而不再迭代？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">size_t</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">size_t</span> hi = arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> lo=<span class="hljs-number">0</span>; lo &lt; hi; ++lo) &#123; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> lo=<span class="hljs-number">0</span>; lo &lt; hi; ++lo) &#123; <br>            <span class="hljs-keyword">if</span>(arr[lo] &gt; arr[lo+<span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[lo], arr[lo+<span class="hljs-number">1</span>]);<br>                last = lo; <span class="hljs-comment">// 记录下最后一次交换元素的位置</span><br>            &#125;<br>        &#125;<br>        hi = last; <span class="hljs-comment">// 下次就从最后一次更新元素位置开始</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此不仅在序列本身有序时时间复杂度仅为<code>O(n)</code>,也为普通情况下进行了改善，不再是每次都遍历，而是直接跳到最后一次交换元素的位置。</p><h2 id="6-18再次理解："><a href="#6-18再次理解：" class="headerlink" title="6.18再次理解："></a>6.18再次理解：</h2><ul><li>冒泡排序就是把<strong>小的元素往前调或者把大的元素往后调</strong>，比较是相邻的两个元素比较，交换也发生在这两个元素之间。</li><li>所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种<strong>稳定排序</strong>算法。</li></ul><p><img src="/2021/04/12/3_bubbleSort/bubblesort.gif"></p><p><strong>步骤</strong>：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最<br>大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubblesort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;   <span class="hljs-comment">//n - 1趟就足够</span><br>flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; ++j) &#123;<br><span class="hljs-keyword">if</span> (nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(nums[j], nums[j + <span class="hljs-number">1</span>]);<br>flag = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!flag) &#123; <br><span class="hljs-keyword">break</span>; <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br><span class="hljs-built_in">bubblesort</span>(data);<br><span class="hljs-keyword">return</span> data;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2021/04/08/2_mergeSort/"/>
    <url>/2021/04/08/2_mergeSort/</url>
    
    <content type="html"><![CDATA[<h1 id="mergeSort"><a href="#mergeSort" class="headerlink" title="mergeSort"></a>mergeSort</h1><p><img src="/2021/04/08/2_mergeSort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="mergeSort"></p><p>归并排序分为连两个部分，先将整个序列化为2个规模一样的序列，然后排序。递归的调用，不断地划分，直到子序列的规模为1，那么这个长度为1的子序列就是有序的，然后再开始归并。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123; <br>    <span class="hljs-keyword">if</span>(hi - lo &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> ; <br><br>    <span class="hljs-keyword">int</span> mid = (lo + mi) &gt;&gt;<span class="hljs-number">1</span>; <span class="hljs-comment">// 取中间点</span><br>    <span class="hljs-built_in">mergeSort</span>(arr, lo,  mid);<br>    <span class="hljs-built_in">mergeSort</span>(arr, mid, hi);<br>    <span class="hljs-built_in">merge</span>(arr, lo, mid, hi);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归基：当hi - lo = 1的时候，就是只有一个元素，本身就是有序，就返回。   </li><li>中点：每次都是取中点，将数据区间划分为2个等规模的区间。</li><li>归并：当划分到单独一个元素的时候，将数据合并起来</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 此时得到的 arr是一个有序的连个子向量</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> hi)</span> </span>&#123; <br>      <span class="hljs-keyword">int</span>* A = arr + lo;<br>      <span class="hljs-keyword">int</span> lb = mid - lo;<br>      <span class="hljs-keyword">int</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[lb];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i &lt; lb; B[i]=A[i++]); <span class="hljs-comment">// 复制前面的向量到 B[]中</span><br><br>      <span class="hljs-keyword">int</span> lc = hi-mid;<br>      <span class="hljs-keyword">int</span>* C = arr + mid;<br>      <span class="hljs-comment">// i 是arr， k是右边的， j是左边的</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span> k=<span class="hljs-number">0</span>; j&lt;lb || k &gt; lc; ) &#123; <br>          <span class="hljs-comment">//              表示后面的空了</span><br>          <span class="hljs-keyword">if</span>(j &lt; lb &amp;&amp; ! (k &lt;lc) || [B[j] &lt;= C[k]) A[i++] = B[j++];<br>          <span class="hljs-keyword">if</span>(k &lt; lc&gt; &amp;&amp; ! (j &lt;lb) || [B[j] &gt; C[k]) A[i++] = C[k++];<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>二路归并排序算法<code>merge</code>的复杂度易知是<code>O(n)</code>，而<code>mergeSort</code>算法以二分划分整个序列到最后变成单个序列的时间复杂度是<code>O(logn)</code>，因此整个算法复杂度是<code>O(nlogn)</code>。但是实际上经过证明，<strong>归并排序算法的复杂度</strong>恒定是<code>O(nlogn)</code>。</p><h2 id="链表的归并排序"><a href="#链表的归并排序" class="headerlink" title="链表的归并排序"></a><a href="https://leetcode-cn.com/problems/sort-list/">链表的归并排序</a></h2><p><a href="https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/">解释</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummyHead</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        dummyHead.next = head;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            ++length;<br>            p = p-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> size = <span class="hljs-number">1</span>; size &lt; length; size &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">auto</span> cur = dummyHead.next;<br>            <span class="hljs-keyword">auto</span> tail = &amp;dummyHead;<br>            <br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                <span class="hljs-keyword">auto</span> left = cur;<br>                <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">cut</span>(left, size); <span class="hljs-comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...</span><br>                cur = <span class="hljs-built_in">cut</span>(right, size); <span class="hljs-comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...</span><br>                <br>                tail-&gt;next = <span class="hljs-built_in">merge</span>(left, right);<br>                <span class="hljs-keyword">while</span> (tail-&gt;next) &#123;<br>                    tail = tail-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">cut</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">while</span> (--n &amp;&amp; p) &#123;<br>            p = p-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <br>        <span class="hljs-keyword">auto</span> next = p-&gt;next;<br>        p-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-function">ListNode <span class="hljs-title">dummyHead</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">auto</span> p = &amp;dummyHead;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                p-&gt;next = l1;<br>                p = l1;<br>                l1 = l1-&gt;next;       <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;next = l2;<br>                p = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>        &#125;<br>        p-&gt;next = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p><img src="/2021/04/08/2_mergeSort/Picture5.png"></p><p><code>归并排序</code>其实与<code>逆序对</code>的联系很大！</p><p>归并排序代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; data)</span> </span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//递归划分</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(data.size())</span></span>;<br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">merge</span>(l, mid, data);<br>        <span class="hljs-built_in">merge</span>(mid + <span class="hljs-number">1</span>, r, data);<br>        <span class="hljs-comment">//合并阶段 i,j分别为左右区间的起点</span><br>        <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++)<br>            tmp[k] = data[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)<br>                data[k] = tmp[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == r + <span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j])<br>                data[k] = tmp[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                data[k] = tmp[j++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-built_in">merge</span>(<span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, data);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2021/04/07/1_quickSort_/"/>
    <url>/2021/04/07/1_quickSort_/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序-quickSort"><a href="#快速排序-quickSort" class="headerlink" title="快速排序 quickSort"></a>快速排序 quickSort</h1><p>排序的本质就是消除逆序对。以升序为例，就是消除”左边大右边小”的逆序对。当逆序对为0，就说明已经满足有序性。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种就地排序，会改变输入数组，同时快速排序是一种<code>不稳定</code>的排序。快速排序的关键点是选择一个合适的轴点(<code>pivot</code>)，这个选取的不确定性也导致了每次数据的分割是不均匀的。</p><p>对于选取的一个轴点，其左边的都不大于轴点，右边的都不小于轴点: <strong>[low, pivot-1] &lt;= pivot &lt;= [pivot+1, high]</strong></p><p><img src="/2021/04/07/1_quickSort_/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F_basic.png" alt="快速排序"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// [left, right)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123; <br>    <span class="hljs-keyword">if</span>(right - left &lt;=<span class="hljs-number">1</span>)  <span class="hljs-comment">// [left, left+1) ，只是剩下一个元素就是有序的</span><br>      <span class="hljs-keyword">return</span>; <br><br>    <span class="hljs-keyword">int</span> pivot = __partation(arr, left, right<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">quickSort</span>(arr, left,    pivot);<br>    <span class="hljs-built_in">quickSort</span>(arr, pivot+<span class="hljs-number">1</span>, right);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>partition</code> 算法，就是在扫描数据的过程中，<strong>将所有大于轴点的数据放到轴点右边，将所有小于轴点的数据放到左边</strong>。而<code>quickSort</code> 算法就是不断的分割，当只有一个数据时，其本身就是有序，再将所有的子问题组合起来，思想是“分而治之”。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>可在线性时间内将原向量排序问题划分为两个相互独立、总体规模保持线性的子向量排序问题。但是分治策略高效的两个必要条件：</p><ul><li>子任务划分的高效性及子任务之间的独立性：满足</li><li>子任务规模的接近：不满足。</li></ul><p>实际上，不仅仅不满足条件 2，还是有可能相差悬殊。这是因为划分所得子序列的长度与划分的具体过程无关，而是取决于轴点。比如轴点 rank = r ,那么子向量的规模是 <code>r</code> 个 <code>n-1-r</code>。当r = 0，左侧子向量规模为空，右侧与原来的向量等长，对称即 <code>r = n - 1</code>。这对于有序向量而言，每次都是简单的选取最左侧元素作为轴点，此时的效率是 **O(n^2)**。</p><h4 id="降低最坏概率情况"><a href="#降低最坏概率情况" class="headerlink" title="降低最坏概率情况"></a>降低最坏概率情况</h4><p>不能每次固定的选取最左端元素，可以每次自由随机选取一个元素，更甚者，从待排序向量中任取三个元素，将数据剧中者作为候选者.</p><h4 id="平均运行时间"><a href="#平均运行时间" class="headerlink" title="平均运行时间"></a>平均运行时间</h4><p>尽管似乎最差的时间复杂度是 <strong>O(n^2)</strong>,但是在平均意义下,时间复杂度还是 <strong>O(1.38logn)</strong></p><h4 id="应对退化情况"><a href="#应对退化情况" class="headerlink" title="应对退化情况"></a>应对退化情况</h4><p>当所有的元素都是重复的时候,此时对应的情况即之前的最坏情况.因为循环中的 <code>pivot &lt;= arr[right]</code>会一直满足,直到 <code>low &lt; high</code>  不满足，最后整个算法退化为线性递归,时间复杂度是<code>o(n^2)</code>。</p><p>改进如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> __partation(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R) &#123; <br>  <span class="hljs-keyword">int</span> pivot = arr[L];<br><br>  <span class="hljs-keyword">while</span>(L &lt; R) &#123; <br>    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; pivot  &lt;= arr[R]) --R; <span class="hljs-keyword">if</span>(L &lt; R) arr[L++] = arr[R];<br>    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; arr[L] &lt;= pivot ) ++L; <span class="hljs-keyword">if</span>(L &lt; R) arr[R--] = arr[L];<br>  &#125;<br><br>  arr[L] = pivot;<br><br>  <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此,每次遇到重复的元素,都是将元素放到的对立的区间,当循环中止的时候,恰好位于中间的位置,此时的时间复杂度最好,是<code>O(nlogn)</code></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h3><p>挑战在于: <strong>如何避免在全排序的前提下,在 <code>O(nlogn)</code>时间复杂度内找出中位数</strong>.</p><h4 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h4><p>如果一个向量存在众数,那么中位数肯定是众数.</p><h4 id="基于快速划分的-k-选取"><a href="#基于快速划分的-k-选取" class="headerlink" title="基于快速划分的 k  选取"></a>基于快速划分的 k  选取</h4><p>选取问题所查找的位序<code>k</code>，这个<code>k</code>就是在有序序列中的<code>rank</code>。</p><p>调用算法<code>partition</code>构造一个轴点<code>A[L] = x</code> 。如果<code>L==k</code>，那么则该轴点就是待选取的元素，直接返回 <code>L</code>。</p><p>如果 <code>L!=k</code>，则无非两种情况：</p><ul><li><code>k &lt; L</code> ：那么带选取的元素肯定不在<code>a[L]</code>的右侧，那么就可以直接进入左侧进行查找。</li><li><code>k &gt; L</code>  ：就可以将左侧分支减除,进入右侧进行查找。</li></ul><p>因此可以得到快速选取问题的解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123; <br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; left &lt; right; ) &#123; <br>        <span class="hljs-keyword">int</span> L = left;<br>        <span class="hljs-keyword">int</span> R = right;<br>        <span class="hljs-keyword">int</span> pivot = A[left];<br><br>        <span class="hljs-keyword">while</span>(L &lt; R) &#123; <br>            <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; pivot &lt;= arr[R]) R--; A[L] = A[R]; <br>            <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; arr[L] &lt;= pivot) ++L; A[R] = A[L]; <br>        &#125; <span class="hljs-comment">// 每次循环结束，l ==R ，此时轴点左侧的元素都不大于它，右侧的都是不小于它</span><br><br>        A[L] = pivot;<br>        <span class="hljs-keyword">if</span>(k &lt;= L)   right = L<span class="hljs-number">-1</span>; <span class="hljs-comment">//  实际上就是比较 A[k] &lt;= pivot ?</span><br>        <span class="hljs-keyword">if</span>(L &lt;= k)   left  = L+<span class="hljs-number">1</span>; <span class="hljs-comment">// 进入右边</span><br>    &#125;<span class="hljs-comment">// A[k]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法在最坏情况下，时间复杂度是<code>O(nlogn)</code>，那么更好的有没有？<code>BFPRT</code>算法。</p><p>延续这个思路：<br>先选取一个中位数，然后递归迭代，这个方法虽然是时间复杂度是<code>O(n)</code>，但是系数很大，在数据量不是很大时，效率并不明显。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">// 伪代码<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selece</span>(<span class="hljs-params">A, k</span>):</span> <br>    <span class="hljs-keyword">if</span> n=|A| &lt;Q:<br>        <span class="hljs-keyword">return</span> trivalSelect(A, k) <span class="hljs-comment"># 数据规模不大时直接用蛮力</span><br><br>    <span class="hljs-number">1</span>) 将A均匀地分为 n/Q个子序列,各自含有Q个元素<br>    <span class="hljs-number">2</span>) 各个子序列分别排序,计算出中位数,并且将这个中位数组成一个序列<br>    <span class="hljs-number">3</span>) 通过递归调用这个select() 计算出中位数序列的中位数,记M<br>    <span class="hljs-number">4</span>) 根据相对M大小,将A中的元素分为三个子集:L(小于), E(等于), G(等于)<br>    <span class="hljs-number">5</span>) 递归如下<br><br>     <span class="hljs-keyword">if</span>(k &lt;= |L|&gt;): <br>        <span class="hljs-keyword">return</span> select(L,k)<br>     <span class="hljs-keyword">elif</span>(k &lt;=|L| + |E|): <br>        <span class="hljs-keyword">return</span> M;<br>     <span class="hljs-keyword">else</span>: <br>        retutn select(G, k-|L|-|E|) <br><br></code></pre></td></tr></table></figure><h2 id="6-18再次理解"><a href="#6-18再次理解" class="headerlink" title="6.18再次理解"></a>6.18再次理解</h2><p>我们从数组中选择一个元素，我们把这个元素称之为中轴元素，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是有序的。也就是说，我们无需再移动中轴元素的位置。</p><p>从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于有序的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以中间数为基准数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j)<br>        &#123; <br>            <span class="hljs-keyword">while</span> (nums[++i] &lt; x);<br>            <span class="hljs-keyword">while</span> (nums[--j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-built_in">quicksort</span>(nums, l, j), <span class="hljs-built_in">quicksort</span>(nums, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-29再再次理解"><a href="#6-29再再次理解" class="headerlink" title="6.29再再次理解"></a>6.29再再次理解</h2><p><img src="/2021/04/07/1_quickSort_/20190604213342876.jpg"></p><p><a href="https://blog.csdn.net/qq_40941722/article/details/94396010?ops_request_misc=%7B%22request_id%22:%22162494666716780255242753%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162494666716780255242753&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-94396010.pc_search_result_cache&utm_term=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">快速排序法（详解）_小白的博客-CSDN博客 快速排序</a></p><p>快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，<strong>将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边</strong>。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是$O(n^2)$，它的平均时间复杂度为 $O(n\log_2n)$。</p><p>实现快速排序的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以第一个数作为基准数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin &gt; end)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> tmp = arr[begin];<br>        <span class="hljs-keyword">int</span> i = begin;<br>        <span class="hljs-keyword">int</span> j = end;<br>        <span class="hljs-keyword">while</span> (i != j) &#123;<br>            <span class="hljs-keyword">while</span> (arr[j] &gt;= tmp &amp;&amp; j &gt; i)<br>                j--;<br>            <span class="hljs-keyword">while</span> (arr[i] &lt;= tmp &amp;&amp; j &gt; i)<br>                i++;<br>            <span class="hljs-keyword">if</span> (j &gt; i) &#123;<br>                <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[i], arr[begin]);   <span class="hljs-comment">//基准点归位</span><br>        <span class="hljs-built_in">quicksort</span>(arr, begin, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quicksort</span>(arr, i + <span class="hljs-number">1</span>, end);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h2><p>用数组来模拟单链表：邻接表（存储图和数）</p><img src="/2021/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/数组模拟单链表.jpeg"><ul><li>空节点下表为<code>-1</code>表示</li><li>head表示头指针，不是节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-keyword">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>head = <span class="hljs-number">-1</span>;<br>idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//将x插入到头结点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_haed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>e[idx] = x;<br>ne[idx] = head;<br>head = idx;<br>idx++;<br>&#125;<br><span class="hljs-comment">//将x插入到下标k以后</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_to_k</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>e[idx] = x;<br>ne[idx] = ne[k];<br>ne[k] = idx;<br>idx++;<br>&#125;<br><span class="hljs-comment">//将下标k的后面节点删除</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_k</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>ne[k] = ne[ne[k]];<br>&#125;<br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_head</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>双链表：优化某些问题</p><p>链表索引不按顺序，按插入顺序idx的值排列！！！<br>第k个插入的数并不是指当前链表的第k个数，而是idx为k+1的数！！！</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">//e[N]表示节点i的value值</span><br><span class="hljs-comment">//idx 存储当前已经用到哪个点</span><br><span class="hljs-keyword">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">//链表索引不按顺序，按插入顺序idx的值排列！！！</span><br><span class="hljs-comment">//第k个插入的数并不是指当前链表的第k个数，而是idx为k+1的数！！！</span><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//0表示左端点，1表示右端点</span><br>r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>idx = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>r[l[k]] = r[k];<br>l[r[k]] = l[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IR</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>e[idx] = x;<br>r[idx] = r[k];<br>l[idx] = k;<br>l[r[k]] = idx;<br>r[k] = idx;<br>idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IL</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">IR</span>(l[k], x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">L</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">IR</span>(<span class="hljs-number">0</span>, x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">R</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-built_in">IR</span>(l[<span class="hljs-number">1</span>], x);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="栈与队列：单调队列、单调栈"><a href="#栈与队列：单调队列、单调栈" class="headerlink" title="栈与队列：单调队列、单调栈"></a>栈与队列：单调队列、单调栈</h2><ul><li>数组模拟栈</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">int</span> stk[N];<br><span class="hljs-keyword">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> x;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; x;<br>stk[++tt] = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>tt--;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; stk[tt] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组模拟队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-keyword">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2021/04/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/2021/04/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpeg" alt="快速排序.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br> <br>   <span class="hljs-keyword">int</span> x = q[l + r &gt;&gt; <span class="hljs-number">1</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>       <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>       <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>       <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>   &#125;<br> <br>   <span class="hljs-built_in">quick_sort</span>(q, l, j);       <span class="hljs-comment">//quick_sort(q,l,i-1); </span><br>      <span class="hljs-comment">//用i要保证不用到q的左边界，x取值那也要调整。</span><br>   <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);   <span class="hljs-comment">//quick_sort(q,i,r);</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="/2021/04/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpeg" alt="归并排序.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> q[], <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (l &gt;= r)<span class="hljs-keyword">return</span>;<br>   <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>   <span class="hljs-built_in">merge_sort</span>(q, l, mid), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>   <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>       <span class="hljs-keyword">if</span> (q[i] &lt;= q[j])tmp[k++] = q[i++];<br>       <span class="hljs-keyword">else</span> tmp[k++] = q[j++];<br>   &#125;<br>   <span class="hljs-keyword">while</span> (i &lt;= mid)tmp[k++] = q[i++];<br>   <span class="hljs-keyword">while</span> (j &lt;= r)tmp[k++] = q[j++];<br>   <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>       q[i] = tmp[j];<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br> <br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-built_in">intbsearch_1</span>(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)<br>&#123;<br>   <span class="hljs-keyword">while</span> (l &lt; r)<br>   &#123;<br>       <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>       <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-built_in">intbsearch_2</span>(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)<br>&#123;<br>   <span class="hljs-keyword">while</span> (l &lt; r)<br>   &#123;<br>       <span class="hljs-keyword">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>       <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br> <br><span class="hljs-built_in">doublebsearch_3</span>(<span class="hljs-keyword">double</span> l, <span class="hljs-keyword">double</span> r)<br>&#123;<br>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>   <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>   &#123;<br>       <span class="hljs-keyword">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>       <span class="hljs-keyword">else</span> l = mid;<br>   &#125;<br>   <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">add</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B) &#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>())t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>())t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t)C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>或者</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p><img src="/2021/04/06/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95.jpeg" alt="高精度减法.jpg"></p><ul><li>分两种请情况：</li></ul><blockquote><ol><li>无借位  $A_{i}+B_{i}-t$</li><li>有借位  $A_{i}+B_{i} + 10-t$</li></ol></blockquote><p><a href="https://www.acwing.com/problem/content/794/">acwing 792. 高精度减法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;A,vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = A.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(A[i] != B[i])<span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;A, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;A,B;<br>    cin &gt;&gt; a &gt;&gt; b;  <span class="hljs-comment">//a=123456</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);  <span class="hljs-comment">//A=[6,5,4,3,2,1]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;C = <span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            cout&lt;&lt;C[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;C = <span class="hljs-built_in">sub</span>(B,A);<br>        cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            cout&lt;&lt;C[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>模板(自己总结)！！！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (A[i] != B[i])<span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(string a, string b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;A, B, C;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(A, B)) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                t = A[i] - t;<br>                <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>                C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; B.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                t = B[i] - t;<br>                <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t -= A[i];<br>                C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>            cout &lt;&lt; <span class="hljs-string">&quot;-&quot;</span>;<br>        &#125;        <br>        <span class="hljs-keyword">return</span> C;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2>]]></content>
    
    
    <categories>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
