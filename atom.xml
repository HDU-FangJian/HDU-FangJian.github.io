<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pakchoi&#39;s blogs</title>
  
  
  <link href="http://pakchoi007.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://pakchoi007.gitee.io/"/>
  <updated>2021-07-07T06:18:51.353Z</updated>
  <id>http://pakchoi007.gitee.io/</id>
  
  <author>
    <name>pakchoi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 56-60</title>
    <link href="http://pakchoi007.gitee.io/2021/07/07/%E5%89%91%E6%8C%87offer56-60/"/>
    <id>http://pakchoi007.gitee.io/2021/07/07/%E5%89%91%E6%8C%87offer56-60/</id>
    <published>2021-07-07T05:03:00.000Z</published>
    <updated>2021-07-07T06:18:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-56-60"><a href="#剑指offer-56-60" class="headerlink" title="剑指offer    56~60"></a>剑指offer    56~60</h1><h2 id="五十六、删除链表中重复的结点"><a href="#五十六、删除链表中重复的结点" class="headerlink" title="五十六、删除链表中重复的结点"></a>五十六、<a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">删除链表中重复的结点</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* dummynode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* pre;<br>        ListNode* cur;<br>        dummynode-&gt;next = pHead;<br>        pre = dummynode;<br>        cur = pHead;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;<br>                <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123;<br>                    cur = cur-&gt;next;<br>                &#125;<br>                pre-&gt;next = cur-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                pre = pre-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummynode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>使用<strong>双指针</strong></p><ol><li>定义两个指针, 分别为遍历的当前节点 cur 和 前节点 pre ;</li><li>每次步进后, 判断 cur 与其后节点(cur.next)是否重复, 如果重复, 则需要向后遍历 cur 直到不重复</li><li>分别将 cur 与 pre 向后步进, 持续进行步骤2的判断;</li><li>直至遍历到链表的尾部结束遍历;</li></ol><h2 id="五十七、二叉树的下一个结点"><a href="#五十七、二叉树的下一个结点" class="headerlink" title="五十七、二叉树的下一个结点"></a>五十七、<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的下一个结点</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示。</p><p><img src="/2021/07/07/%E5%89%91%E6%8C%87offer56-60/D03B8D5BB902D4516BB92CB216E58EC4"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>输入:{8,6,10,5,7,9,11},8</p><p>返回:9</p><p>解析:这个组装传入的子树根节点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根节点8的下一个节点就是9，应该返回{9,10,11}，后台只打印子树的下一个节点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来。</p><p><img src="/2021/07/07/%E5%89%91%E6%8C%87offer56-60/E647707AEF2A4AE2C40F0FCCB549B6A5"></p><h4 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h4><p>输入分为2段，第一段是整体的二叉树，第二段是给定二叉树节点的值，后台会将这2个参数组装为一个二叉树局部的子树传入到函数GetNext里面，用户得到的输入只有一个子树根节点</p><h4 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h4><p>返回传入的子树根节点的下一个节点，后台会打印输出这个节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        TreeLinkNode* node = pNode;<br>        <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = node-&gt;right;<br>            <span class="hljs-keyword">while</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                node = node-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        node = pNode;<br>        <span class="hljs-keyword">while</span> (node-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; node == node-&gt;next-&gt;right) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>这完全可以用中序遍历之后，打印出数组，再找到下一个节点，但是太复杂。</p><p>本题每个节点都含有一个 next 指针，指向父节点，就比较好做了。</p><p>因为中序遍历为 <strong>左中右</strong> ，下一个节点只有两种情况：</p><ol><li>当这个节点有右节点时，下一个节点必为该右节点中的最底层左节点</li><li>若这个节点没有右节点，就返回其父节点，直到父节点不是作为右节点存在时停止，返回这个节点的父节点</li></ol><p>总的思路：</p><ol><li>节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</li><li>右孩子不存在，如果节点不是根节点，如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</li></ol><h2 id="五十八、对称的二叉树"><a href="#五十八、对称的二叉树" class="headerlink" title="五十八、对称的二叉树"></a>五十八、<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">对称的二叉树</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">bool</span> outside = <span class="hljs-built_in">cmp</span>(left-&gt;left, right-&gt;right);<br>        <span class="hljs-keyword">bool</span> inside = <span class="hljs-built_in">cmp</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">bool</span> isSame = outside &amp;&amp; inside;<br>        <span class="hljs-keyword">return</span> isSame;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">cmp</span>(pRoot-&gt;left, pRoot-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>算法流程</strong>：</p><p><code>isSymmetrical(root) </code>：</p><ul><li>特例处理： 若根节点 <code>root</code> 为空，则直接返回 true 。</li><li>返回值： 即 <code>cmp(root.left, root.right)</code> ;</li></ul><p><code>cmp(L, R)</code> ：</p><ul><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 不等于 节点 R 值： 此树不对称，因此返回 false ；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right 是否对称，即 <code>cmp(L.left, R.right)</code> ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 <code>cmp(L.right, R.left)</code> ；</li></ul></li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li></ul><h2 id="五十九、按之字形顺序打印二叉树"><a href="#五十九、按之字形顺序打印二叉树" class="headerlink" title="五十九、按之字形顺序打印二叉树"></a>五十九、<a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">按之字形顺序打印二叉树</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">8</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> cursize = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursize; i++) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) <span class="hljs-built_in">reverse</span>(res[i].<span class="hljs-built_in">begin</span>(), res[i].<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>利用队列对二叉树层序遍历</p><p>再对奇数行反转即可。</p><h2 id="六十、把二叉树打印成多行"><a href="#六十、把二叉树打印成多行" class="headerlink" title="六十、把二叉树打印成多行"></a>六十、<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把二叉树打印成多行</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">8</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        queue&lt;TreeNode*&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> cursize = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cursize; i++) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>就是层序遍历</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-56-60&quot;&gt;&lt;a href=&quot;#剑指offer-56-60&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    56~60&quot;&gt;&lt;/a&gt;剑指offer    56~60&lt;/h1&gt;&lt;h2 id=&quot;五十六、删除链表中重复的结点&quot;</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>类相关</title>
    <link href="http://pakchoi007.gitee.io/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/"/>
    <id>http://pakchoi007.gitee.io/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/</id>
    <published>2021-07-03T09:38:00.000Z</published>
    <updated>2021-07-03T09:38:15.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="什么是虚函数？什么是纯虚函数"><a href="#什么是虚函数？什么是纯虚函数" class="headerlink" title="什么是虚函数？什么是纯虚函数"></a>什么是虚函数？什么是纯虚函数</h2><p>面试高频指数：★★★★★</p><p><strong>虚函数</strong>：被 <code>virtual</code> 关键字修饰的成员函数，就是虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">v_fun</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B::v_fun()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">v_fun</span>(); <span class="hljs-comment">// B::v_fun()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>纯虚函数</strong>：</p><ul><li>纯虚函数在类中声明时，加上 <code>=0</code>；</li><li><code>含有纯虚函数的类称为抽象类</code>（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li><li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li></ul><p>说明：</p><ul><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li><li>可以声明抽象类指针，可以声明抽象类的引用；</li><li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li></ul><h2 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h2><p>面试高频指数：★★★☆☆</p><ul><li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（<strong>含有纯虚函数的类称为抽象基类</strong>）</li><li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li><li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;</li><li><code>虚函数必须实现</code>，否则编译器会报错；</li><li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li><li><code>析构函数最好定义为虚函数</code>，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li></ul><h2 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h2><p>面试高频指数：★★★★★</p><p><strong>实现机制</strong>：虚函数通过<code>虚函数表</code>来实现。<code>虚函数的地址保存在虚函数表中</code>，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p><p><strong>虚函数表相关知识点</strong>：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：<code>编译阶段</code>，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul><p>注：<code>虚函数表和类绑定</code>，<code>虚表指针和对象绑定</code>。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p><p><strong>实例</strong>：</p><p>无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681846-tyqCUP-image.png"></p><p>基类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679161-OtbPhj-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681900-RShiIP-image.png"></p><p>主函数中基类的指针 <code>p</code> 指向了派生类的对象，当调用函数 <code>B_fun1()</code> 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p><h2 id="单继承和多继承的虚函数表结构"><a href="#单继承和多继承的虚函数表结构" class="headerlink" title="单继承和多继承的虚函数表结构"></a>单继承和多继承的虚函数表结构</h2><p>面试高频指数：★★★★☆</p><p><strong>编译器处理虚函数表：</strong></p><ul><li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li><li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li><li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li><li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li></ul><ol><li><p>单继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B_fun1</span>(); <span class="hljs-comment">// Base::B_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681846-tyqCUP-image.png"></p><p>基类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679161-OtbPhj-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681900-RShiIP-image.png"></p></li><li><p>单继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::D_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682073-uNdCTl-image.png"></p></li><li><p>多继承无虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p-&gt;<span class="hljs-built_in">B1_fun1</span>(); <span class="hljs-comment">// Base1::B1_fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612679879-DBSJce-image.png"></p><p>派生类的虚函数表：（基类的顺序和声明的顺序一致）</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682139-oQZazN-image.png"></p></li><li><p>多继承有虚函数覆盖的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B1_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base1::B1_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B2_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base2::B2_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">B3_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base3::B3_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun1()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D_fun3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base1 *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base2 *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    Base3 *p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>    p1-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p2-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    p3-&gt;<span class="hljs-built_in">fun1</span>(); <span class="hljs-comment">// Derive::fun1()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基类和派生类的关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681289-WjDonI-image.png"></p><p>派生类的虚函数表：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612682194-qhLdri-image.png"></p></li></ol><h2 id="如何禁止构造函数的使用？"><a href="#如何禁止构造函数的使用？" class="headerlink" title="如何禁止构造函数的使用？"></a>如何禁止构造函数的使用？</h2><p>面试高频指数：★★☆☆☆</p><p>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp1, <span class="hljs-keyword">int</span> tmp2) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1;    <br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">13</span>)</span></span>; <span class="hljs-comment">// error: use of deleted function &#x27;A::A(int, int)&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：上述代码中，使用了已经删除 <code>delete</code> 的构造函数，程序出现错误。</p><p>用来禁止拷贝/复制构造函数。</p><h2 id="什么是类的默认构造函数？"><a href="#什么是类的默认构造函数？" class="headerlink" title="什么是类的默认构造函数？"></a>什么是类的默认构造函数？</h2><p>面试高频指数：★★★☆☆</p><p>默认构造函数：<code>未提供任何实参</code>，来控制默认初始化过程的构造函数称为默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123; <span class="hljs-comment">// 类的默认构造函数</span><br>        var = <span class="hljs-number">10</span>;<br>        c = <span class="hljs-string">&#x27;q&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> var;<br>    <span class="hljs-keyword">char</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex;<br>    cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">q</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：上述程序中定义变量 <code>ex</code> 时，未提供任何实参，程序运行时会调用默认的构造函数。</p><h2 id="构造函数、析构函数是否需要定义成虚函数？为什么？"><a href="#构造函数、析构函数是否需要定义成虚函数？为什么？" class="headerlink" title="构造函数、析构函数是否需要定义成虚函数？为什么？"></a>构造函数、析构函数是否需要定义成虚函数？为什么？</h2><p>面试高频指数：★★★★☆</p><p><strong>构造函数一般不定义为虚函数</strong>，原因：</p><ul><li>从存储空间的角度考虑：构造函数是在<code>实例化对象的时候进行调用</code>，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，<code>虚函数的指针只有在创建了对象才有</code>），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li><li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li><li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li><li>从类型上考虑：在创建对象时需要明确其类型。</li></ul><p><strong>析构函数一般定义成虚函数</strong>，原因：</p><ul><li>析构函数定义成虚函数是<code>为了防止内存泄漏</code>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li></ul><h2 id="如何避免拷贝？"><a href="#如何避免拷贝？" class="headerlink" title="如何避免拷贝？"></a>如何避免拷贝？</h2><p>面试高频指数：★★☆☆☆</p><p>最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</p><p>解决方法：声明一个基类，具体做法如下。</p><ul><li><p>定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private</p></li><li><p>派生类以私有 private 的方式继承基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncopyable</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-keyword">const</span> Uncopyable &amp;);            <span class="hljs-comment">// 拷贝构造函数</span><br>    Uncopyable &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Uncopyable &amp;); <span class="hljs-comment">// 赋值构造函数</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">private</span> Uncopyable <span class="hljs-comment">// 注意继承方式</span><br>&#123; <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>简单解释：</p><ul><li>能够保证，在派生类 A 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。</li></ul><h2 id="如何减少构造函数开销？"><a href="#如何减少构造函数开销？" class="headerlink" title="如何减少构造函数开销？"></a>如何减少构造函数开销？</h2><p>面试高频指数：★★☆☆☆</p><p>在构造函数中<strong>使用类初始化列表</strong>，会减少调用默认的构造函数产生的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成员初始化列表：在类构造函数中，不在函数体内对变量赋值，而在参数列表后，跟一个冒号和初始化列表。</p><p>对于<code>非内置类型</code>，少了一次调用默认构造函数的过程。</p><h2 id="为什么用成员初始化列表会快一些？"><a href="#为什么用成员初始化列表会快一些？" class="headerlink" title="为什么用成员初始化列表会快一些？"></a>为什么用成员初始化列表会快一些？</h2><p>面试高频指数：★★★☆☆</p><p>说明：数据类型可分为<code>内置类型</code>和<code>用户自定义类型</code>（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p><p>原因：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前<strong>首先调用默认的构造函数</strong>为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，<strong>使用列表初始化会减少调用默认的构造函数的过程</strong>，效率高。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp)<br>    &#123;<br>        val = tmp;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test1</span>() : <span class="hljs-built_in">ex</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员列表初始化方式</span><br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    A ex;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test2</span>() <span class="hljs-comment">// 函数体中赋值的方式</span><br>    &#123;<br>        ex = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test1 ex1;<br>    cout &lt;&lt; endl;<br>    Test2 ex2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int 1)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">A(int 2)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。</p><h2 id="实例化一个对象需要哪几个阶段"><a href="#实例化一个对象需要哪几个阶段" class="headerlink" title="实例化一个对象需要哪几个阶段"></a>实例化一个对象需要哪几个阶段</h2><p>面试高频指数：★★★☆☆</p><ol><li><p>分配空间</p><p>创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</p></li><li><p>初始化</p><p>首先明确一点：<code>初始化不同于赋值</code>。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</p></li><li><p>赋值</p><p>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。）</p></li></ol><p>注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li><li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li></ul><h2 id="多重继承时会出现什么状况？如何解决？"><a href="#多重继承时会出现什么状况？如何解决？" class="headerlink" title="多重继承时会出现什么状况？如何解决？"></a>多重继承时会出现什么状况？如何解决？</h2><p>面试高频指数：★★★★☆</p><p>多重继承（多继承）：是指从多个直接基类中产生派生类。</p><p>多重继承容易出现的问题：<code>命名冲突</code>和<code>数据冗余</code>问题。</p><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <span class="hljs-comment">// error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序的继承关系如下：（菱形继承）</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681677-Jgekej-image.png"></p><p><strong>上述代码中存的问题：</strong></p><p>对于派生类 Derive 上述代码中存在<code>直接继承关系</code>和<code>间接继承关系</code>。</p><ul><li>直接继承：Base2 、Base3</li><li>间接继承：Base1</li></ul><p>对于派生类中继承的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了<code>命名冲突</code>。</p><p><strong>解决方法 1</strong>： 声明出现冲突的成员变量来源于哪个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; Base2::var1 = tmp; &#125; <span class="hljs-comment">// 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方法 2</strong>： 虚继承</p><p>使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。</p><p>实现方式：在继承方式前面加上 virtual 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 间接基类，即虚基类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var2;<br>&#125;;<br><br><span class="hljs-comment">// 直接基类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base3</span> :</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base1 <span class="hljs-comment">// 虚继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var3;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var1 = tmp; &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var2 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var3 = tmp; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_var4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tmp)</span> </span>&#123; var4 = tmp; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类之间的继承关系：</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F2%E7%B1%BB%E7%9B%B8%E5%85%B3/1612681729-IhAKvb-image.png"></p><h2 id="空类占多少字节？C-编译器会给一个空类自动生成哪些函数？"><a href="#空类占多少字节？C-编译器会给一个空类自动生成哪些函数？" class="headerlink" title="空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？"></a>空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？</h2><p>面试高频指数：★★★☆☆</p><p><strong>空类声明时编译器不会生成任何成员函数：</strong></p><p>对于空类，<strong>声明</strong>编译器不会生成任何的成员函数，只会生成 <strong>1</strong> 个字节的占位符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空类定义时编译器会生成 6 个成员函数</strong>：</p><p>当空类 A <strong>定义对象</strong>时，sizeof(A) 仍是为 1，但编译器会生成 6 个成员函数：<code>缺省的构造函数</code>、<code>拷贝构造函数</code>、<code>析构函数</code>、<code>赋值运算符</code>、<code>两个取址运算符</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class A</span><br><span class="hljs-comment">&#123;&#125;; 该空类的等价写法如下：</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()&#123;&#125;;                                       <span class="hljs-comment">// 缺省构造函数</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                           <span class="hljs-comment">// 拷贝构造函数</span><br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;;                                      <span class="hljs-comment">// 析构函数</span><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp)&#123;&#125;;                <span class="hljs-comment">// 赋值运算符</span><br>    A *<span class="hljs-keyword">operator</span>&amp;() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;;             <span class="hljs-comment">// 取址运算符</span><br>    <span class="hljs-keyword">const</span> A *<span class="hljs-keyword">operator</span>&amp;() <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;; <span class="hljs-comment">// 取址运算符（const 版本）</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl; <span class="hljs-comment">// sizeof(A):1</span><br>    <span class="hljs-keyword">delete</span> p;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么拷贝构造函数必须为引用？"><a href="#为什么拷贝构造函数必须为引用？" class="headerlink" title="为什么拷贝构造函数必须为引用？"></a>为什么拷贝构造函数必须为引用？</h2><p>面试高频指数：★★☆☆☆</p><p>原因：避免拷贝构造函数<code>无限制的递归</code>，最终导致<code>栈溢出</code>。</p><p>举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> val;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">val</span>(tmp) <span class="hljs-comment">// 带参数构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(int tmp)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 拷贝构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>    &#125;<br><br>    A &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A &amp;tmp) <span class="hljs-comment">// 赋值函数（赋值运算符重载）</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A &amp;operator=(const A &amp;tmp)&quot;</span> &lt;&lt; endl;<br>        val = tmp.val;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(A tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">A <span class="hljs-title">ex2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    A ex3 = ex1;<br>    ex2 = ex1;<br>    ex2.<span class="hljs-built_in">fun</span>(ex1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(int tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">A &amp;operator=(const A &amp;tmp)</span><br><span class="hljs-comment">A(const A &amp;tmp)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>说明 1：ex2 = ex1; 和 A ex3 = ex1; 为什么调用的函数不一样？<br>对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值函数；但是 ex3 还没有实例化，因此调用的是拷贝构造函数，构造出 ex3，而不是赋值函数，这里涉及到构造函数的<code>隐式调用</code>。</li><li>说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 = ex1;会出现什么问题？<br>构造 ex3，实质上是 ex3.A(ex1);，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp)的形参，在参数传递时相当于 A tmp = ex1，因为 tmp 没有被初始化，所以在 A tmp = ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1) ，必然又会有 ex1 作为函数 A(const A tmp); 的形参，在参数传递时相当于即 A tmp = ex1，那么又会触发拷贝构造函数，就这下永远的递归下去。</li><li>说明 3：为什么 ex2.fun(ex1); 会调用拷贝构造函数？<br>ex1 作为参数传递给 fun 函数， 即 A tmp = ex1;，这个过程会调用拷贝构造函数进行初始化。</li></ul><h2 id="C-类对象的初始化顺序"><a href="#C-类对象的初始化顺序" class="headerlink" title="C++ 类对象的初始化顺序"></a>C++ 类对象的初始化顺序</h2><p>面试高频指数：★★★☆☆</p><p>构造函数调用顺序：</p><ul><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数；</li><li>按照派生类中成员变量的声名顺序，依次调用派生类中成员变量所属类的构造函数；</li><li>执行派生类自身的构造函数。</li></ul><p>综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数</p><p>注：</p><ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关；</li><li>成员变量的初始化顺序与声明顺序有关；</li><li>析构顺序和构造顺序相反。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> :</span> <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B <span class="hljs-comment">// 派生列表</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    B ex1;<br>    A ex2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">A()</span><br><span class="hljs-comment">B()</span><br><span class="hljs-comment">B()   --&gt; B ex1</span><br><span class="hljs-comment">A()   --&gt; A ex2</span><br><span class="hljs-comment">Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~B()</span><br><span class="hljs-comment">~A()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序运行结果分析：</p><ul><li>首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造；</li><li>然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造；</li><li>最后调用派生类的构造函数；</li><li>接下来调用析构函数，和构造函数调用的顺序相反。</li></ul><h2 id="如何禁止一个类被实例化？"><a href="#如何禁止一个类被实例化？" class="headerlink" title="如何禁止一个类被实例化？"></a>如何禁止一个类被实例化？</h2><p>面试高频指数：★★☆☆☆</p><p>方法一：</p><ul><li>在类中定义一个纯虚函数，使该类成为<code>抽象基类</code>，因为不能创建抽象基类的实例化对象；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()&#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1; <span class="hljs-comment">// error: cannot declare variable &#x27;ex1&#x27; to be of abstract type &#x27;A&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：</p><ul><li>将类的构造函数声明为私有 <code>private</code></li></ul><h2 id="友元函数的作用及使用场景"><a href="#友元函数的作用及使用场景" class="headerlink" title="友元函数的作用及使用场景"></a>友元函数的作用及使用场景</h2><p>面试高频指数：★★☆☆☆</p><p>作用：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p><p>使用场景：</p><ol><li><p>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp); <span class="hljs-comment">// 声明为类的友元函数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp)<br>    &#123;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;_cout, <span class="hljs-keyword">const</span> A &amp;tmp)<br>&#123;<br>    _cout &lt;&lt; tmp.var;<br>    <span class="hljs-keyword">return</span> _cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    cout &lt;&lt; ex &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>友元类：类之间共享数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">var</span>(<span class="hljs-number">10</span>)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> tmp) : <span class="hljs-built_in">var</span>(tmp) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; var &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> var;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;fun():&quot;</span> &lt;&lt; ex.var &lt;&lt; endl; <span class="hljs-comment">// 访问类 A 中的私有成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    A ex;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B ex;<br>    ex.<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun():10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="静态绑定和动态绑定是怎么实现的？"><a href="#静态绑定和动态绑定是怎么实现的？" class="headerlink" title="静态绑定和动态绑定是怎么实现的？"></a>静态绑定和动态绑定是怎么实现的？</h2><p>面试高频指数：★★★☆☆</p><p>静态类型和动态类型：</p><ul><li>静态类型：<code>变量在声明时的类型</code>，是在编译阶段确定的。静态类型不能更改。</li><li>动态类型：<code>目前所指对象的类型</code>，是在运行阶段确定的。动态类型可以更改。</li></ul><p>静态绑定和动态绑定：</p><ul><li>静态绑定是指程序在 <code>编译阶段</code> 确定对象的类型（静态类型）。</li><li>动态绑定是指程序在 <code>运行阶段</code> 确定对象的类型（动态类型）。</li></ul><p>静态绑定和动态绑定的区别：</p><ul><li>发生的时期不同：如上。</li><li><strong>对象的静态类型不能更改，动态类型可以更改。</strong></li></ul><p>注：对于类的成员函数，只有<strong>虚函数是动态绑定</strong>，其他都是静态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;<br>     &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span> :</span> <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive::fun()&quot;</span>; <br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(); <span class="hljs-comment">// p 的静态类型是 Base*，动态类型是 Derive*</span><br>    p-&gt;<span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// fun 是虚函数，运行阶段进行动态绑定</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Derive::fun()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p>面试高频指数：★★★★★</p><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。</p><ul><li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</li><li>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</li></ul><p>当类的成员变量中<strong>有指针变量时，最好使用深拷贝</strong>。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。</p><p><strong>浅拷贝实例</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果：</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。</p><p><strong>深拷贝实例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> *p;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(tmp);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(int tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;tmp) <span class="hljs-comment">// 定义拷贝构造函数</span><br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*tmp.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test &amp;tmp)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>Test ex2 = ex1; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test(int tmp)</span><br><span class="hljs-comment">Test(const Test &amp;tmp)</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">~Test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="编译时多态和运行时多态的区别"><a href="#编译时多态和运行时多态的区别" class="headerlink" title="编译时多态和运行时多态的区别"></a>编译时多态和运行时多态的区别</h2><p>面试高频指数：★★★☆☆</p><p>编译时多态：在程序<code>编译过程中</code>出现，发生在模板和函数<strong>重载</strong>中（泛型编程）。</p><p>运行时多态：在程序<code>运行过程中</code>出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的<strong>虚函数</strong>。</p><p>编译时多态和运行时多态的区别：</p><ul><li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li><li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。</li></ul><h2 id="实现一个类成员函数，要求不允许修改类的成员变量？"><a href="#实现一个类成员函数，要求不允许修改类的成员变量？" class="headerlink" title="实现一个类成员函数，要求不允许修改类的成员变量？"></a>实现一个类成员函数，要求不允许修改类的成员变量？</h2><p>如果想达到一个类的成员函数不能修改类的成员变量，只需用 <code>const 关键字</code>来修饰该函数即可。</p><p>考察 const 关键字修饰成员函数的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> var1, var2;<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        var1 = <span class="hljs-number">10</span>;<br>        var2 = <span class="hljs-number">20</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-comment">// 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰</span></span><br><span class="hljs-function">    </span>&#123;<br>        var1 = <span class="hljs-number">100</span>; <span class="hljs-comment">// error: assignment of member &#x27;A::var1&#x27; in read-only object</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A ex1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何让类不能被继承？"><a href="#如何让类不能被继承？" class="headerlink" title="如何让类不能被继承？"></a>如何让类不能被继承？</h2><p>面试高频指数：★★★☆☆</p><p>解决方法一：借助 <code>final</code> 关键字，用该关键字修饰的类不能被继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derive</span>:</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive ex;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法二：借助友元、虚继承和私有构造函数来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span><br>    <span class="hljs-keyword">friend</span> T;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base&lt;B&gt;&#123;   <span class="hljs-comment">//一定注意 必须是虚继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span><span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>()&#123;&#125;     <span class="hljs-comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    B b;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：在上述代码中 B 类是不能被继承的类。</p><p>具体原因：</p><ul><li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的<code>友元</code>，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li><li>B 类继承 Base 类采用<code>虚继承</code>的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li></ul><p>注意：在继承体系中，<code>友元关系不能被继承</code>，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;类相关&quot;&gt;&lt;a href=&quot;#类相关&quot; class=&quot;headerlink&quot; title=&quot;类相关&quot;&gt;&lt;/a&gt;类相关&lt;/h1&gt;&lt;h2 id=&quot;什么是虚函数？什么是纯虚函数&quot;&gt;&lt;a href=&quot;#什么是虚函数？什么是纯虚函数&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="面试突击" scheme="http://pakchoi007.gitee.io/categories/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/"/>
    
    
    <category term="面经" scheme="http://pakchoi007.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>编译内存相关</title>
    <link href="http://pakchoi007.gitee.io/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <id>http://pakchoi007.gitee.io/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/</id>
    <published>2021-07-03T06:26:00.000Z</published>
    <updated>2021-07-03T06:39:26.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译内存相关"><a href="#编译内存相关" class="headerlink" title="编译内存相关"></a>编译内存相关</h1><h2 id="C-程序编译过程"><a href="#C-程序编译过程" class="headerlink" title="C++ 程序编译过程"></a>C++ 程序编译过程</h2><p>面试高频指数：★★★★☆</p><p>编译过程分为四个过程：编译预处理，编译，汇编，链接。</p><ul><li>编译预处理：处理以 # 开头的指令；</li><li>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码；</li><li>汇编：将汇编代码 .s 翻译成机器指令 .o 文件；</li><li>链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。</li></ul><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/1612676946-HVvkdR-image.png"></p><p>链接分为两种：</p><ul><li>静态链接：代码从其所在的<strong>静态链接库</strong>中<code>拷贝</code>到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到<strong>动态链接库</strong>或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被<code>映射</code>到运行时相应进行的虚拟地址的空间。</li></ul><p>二者的优缺点：</p><ul><li>静态链接：<code>浪费空间</code>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：<code>节省内存、更新方便</code>，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li></ul><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h2><p>面试高频指数：★★★★★</p><p>C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p><ul><li>栈：存放函数的<code>局部变量、函数参数、返回地址</code>等，由<code>编译器自动分配和释放</code>。</li><li>堆：<code>动态申请的内存空间</code>，就是由 malloc 或 new 分配的内存块，由<code>程序员控制它的分配和释放</code>，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>全局区/静态存储区（.bss 段和 .data 段）：存放<code>全局变量和静态变量</code>，程序运行结束<code>操作系统自动释放</code>，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li><li>常量存储区（.data 段）：存放的是<code>常量</code>，不允许修改，程序运行结束自动释放。</li><li>代码区（.text 段）：存放<code>代码</code>，不允许修改，但可以执行。<code>编译后的二进制文件</code>存放在这里。</li></ul><p>说明：</p><ul><li><p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/7618933_1.jpg"></p></li></ul><p>程序实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> g_var = <span class="hljs-number">0</span>; <span class="hljs-comment">// g_var 在全局区（.data 段）已初始化</span><br><span class="hljs-keyword">char</span> *gp_var;  <span class="hljs-comment">// gp_var 在全局区（.bss 段）未初始化</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> var;                    <span class="hljs-comment">// var 在栈区</span><br>    <span class="hljs-keyword">char</span> *p_var;                <span class="hljs-comment">// p_var 在栈区</span><br>    <span class="hljs-keyword">char</span> arr[] = <span class="hljs-string">&quot;abc&quot;</span>;         <span class="hljs-comment">// arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">char</span> *p_var1 = <span class="hljs-string">&quot;123456&quot;</span>;    <span class="hljs-comment">// p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var = <span class="hljs-number">0</span>;       <span class="hljs-comment">// s_var 为静态变量，存在静态存储区（.data 段）</span><br>    p_var = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 分配得来的 10 个字节的区域在堆区</span><br>    <span class="hljs-built_in">free</span>(p_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h2><p>面试高频指数：★★★★★</p><ul><li>申请方式：栈是系统自动分配，堆是程序员主动申请。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于<code>链表</code>（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li><li><code>栈在内存中是连续的一块空间（向低地址扩展）</code>最大容量是系统预定好的，<code>堆在内存中的空间（向高地址扩展）是不连续的</code>。</li><li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li><li>存放的内容：<code>栈中存放的是局部变量，函数的参数</code>；<code>堆中存放的内容由程序员控制</code>。</li></ul><h2 id="变量的区别"><a href="#变量的区别" class="headerlink" title="变量的区别"></a>变量的区别</h2><p>面试高频指数：★★★☆☆</p><p>全局变量、局部变量、静态全局变量、静态局部变量的区别</p><p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：<code>全局作用域</code>，<code>局部作用域</code>，<code>语句作用域</code>，<code>类作用域</code>，<code>命名空间作用域</code>和<code>文件作用域</code>。</p><p>从作用域看：</p><ul><li><p><code>全局变量</code>：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p></li><li><p><code>静态全局变量</code>：具有<strong>文件作用域</strong>。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样<strong>即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</strong>。</p></li><li><p><code>局部变量</code>：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</p></li><li><p><code>静态局部变量</code>：具有局部作用域。它<strong>只被初始化一次</strong>，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而<strong>静态局部变量只对定义自己的函数体始终可见</strong>。</p></li></ul><p>从分配内存空间看：</p><ul><li>静态存储区：全局变量，静态局部变量，静态全局变量。</li><li>栈：局部变量。</li></ul><p>说明：</p><ul><li>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（<strong>静态变量会自动初始化</strong>），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</li><li>静态变量和全局变量的区别：静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见。</li></ul><h2 id="全局变量定义在头文件中有什么问题？"><a href="#全局变量定义在头文件中有什么问题？" class="headerlink" title="全局变量定义在头文件中有什么问题？"></a>全局变量定义在头文件中有什么问题？</h2><p>面试高频指数：★☆☆☆☆</p><p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此<strong>不能</strong>在头文件中定义全局变量。</p><h2 id="对象创建限制在堆或栈"><a href="#对象创建限制在堆或栈" class="headerlink" title="对象创建限制在堆或栈"></a>对象创建限制在堆或栈</h2><p>面试高频指数：★★★☆☆</p><p><strong>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</strong></p><p>说明：C++ 中的类的对象的建立分为两种：<code>静态建立</code>、<code>动态建立</code>。</p><ul><li>静态建立：由编译器为对象在<code>栈空间上分配内存</code>，直接<code>调用类的构造函数创建对象</code>。例如：<code>A a;</code></li><li>动态建立：使用 <code>new 关键字在堆空间上创建对象</code>，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：<code>A *p = new A();</code></li></ul><p>限制对象<strong>只能建立在堆上</strong>：</p><ul><li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p></li><li><p>解决方法 1：</p><ul><li><p><strong>将析构函数设置为私有</strong>。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即<code>编译器会检查析构函数的访问性</code>。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该方法存在的问题：</p></li><li><p>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此<code>类内必须定义一个 destory() 函数</code>，用来释放 new 创建的对象（用来替代析构函数）。</p></li><li><p><code>无法解决继承问题</code>，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p></li></ul></li><li><p>解决方法 2：</p><ul><li><p>构造函数设置为 protected，并提供一个 <code>public 的静态函数来完成构造</code>，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> A *<span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>限制对象<strong>只能建立在栈上</strong>：</p><ul><li><p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> t)</span> </span>&#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>面试高频指数：★★☆☆☆</p><p><strong>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</strong></p><p>内存对齐：编译器将程序中的每个“数据单元”安排在<code>字的整数倍的地址指向的内存</code>之中</p><p>内存对齐的原则：</p><ol><li>结构体变量的<code>首地址</code>能够被其<code>最宽基本类型成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>所<code>整除</code>；</li><li>结构体<code>每个成员</code>相对于结构体<code>首地址的偏移量</code> （offset） 都是该<code>成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>的<code>整数倍</code>，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的<code>总大小</code>为<code>结构体最宽基本类型成员大小</code>与<code>对齐基数</code>中的<code>较小者</code>的<code>整数倍</code>，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">short</span> var; <span class="hljs-comment">// 2 字节</span><br>    <span class="hljs-keyword">int</span> var1;  <span class="hljs-comment">// 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8</span><br>    <span class="hljs-keyword">long</span> var2; <span class="hljs-comment">// 12 字节 8 + 4 (long) = 12</span><br>    <span class="hljs-keyword">char</span> var3; <span class="hljs-comment">// 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16</span><br>    string s;  <span class="hljs-comment">// 48 字节 16 + 32 (string) = 48</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">short</span> var;<br>    <span class="hljs-keyword">int</span> var1;<br>    <span class="hljs-keyword">long</span> var2;<br>    <span class="hljs-keyword">char</span> var3;<br>    string s;<br>    A ex1;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var) &lt;&lt; endl;  <span class="hljs-comment">// 2 short</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var1) &lt;&lt; endl; <span class="hljs-comment">// 4 int</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var2) &lt;&lt; endl; <span class="hljs-comment">// 4 long</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(var3) &lt;&lt; endl; <span class="hljs-comment">// 1 char</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(s) &lt;&lt; endl;    <span class="hljs-comment">// 32 string</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl;  <span class="hljs-comment">// 48 struct</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行内存对齐的原因：（主要是硬件设备方面的问题）</p><ol><li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li><li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li><li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li><li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li><li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li></ol><p>内存对齐的优点：</p><ol><li><code>便于在不同的平台之间进行移植</code>，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li><li><code>提高内存的访问效率</code>，因为 CPU 在读取内存时，是一块一块的读取。</li></ol><h2 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h2><p>面试高频指数：★★☆☆☆</p><p><strong>类大小的计算</strong></p><p>说明：类的大小是指<code>类的实例化对象的大小</code>，用 sizeof 对类型名操作时，结果是该类型的对象的大小。</p><p>计算原则：</p><ul><li><code>遵循结构体的对齐原则</code>。</li><li>与<code>普通成员变量有关</code>，与成员函数和静态成员无关。即<code>普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响</code>。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li><li>虚函数对类的大小有影响，是因为<code>虚函数表指针</code>的影响。</li><li>虚继承对类的大小有影响，是因为<code>虚基表指针</code>带来的影响。</li><li>空类的大小是一个特殊情况，<code>空类的大小为 1</code>，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。</li></ul><p>实例：</p><ol><li><p>简单情况和空类情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                    <span class="hljs-comment">// 不影响类的大小</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    B ex2;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 12 字节</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex2) &lt;&lt; endl; <span class="hljs-comment">// 1 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明：程序是在 64 位编译器下测试的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> s_var; <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> c_var;  <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-keyword">int</span> var;          <span class="hljs-comment">// 8 字节 4 + 4 (int) = 8</span><br>    <span class="hljs-keyword">char</span> var1;        <span class="hljs-comment">// 12 字节 8 + 1 (char) + 3 (填充) = 12</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> temp) : <span class="hljs-built_in">c_var</span>(temp) &#123;&#125; <span class="hljs-comment">// 不影响类的大小</span><br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;                      <span class="hljs-comment">// 不影响类的大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::f&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::g&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::h&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    A *p;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) &lt;&lt; endl;   <span class="hljs-comment">// 8 字节 注意：指针所占的空间和指针指向的数据类型无关</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ex1) &lt;&lt; endl; <span class="hljs-comment">// 24 字节</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针，指针8字节。</p><p>当到char var1，类已经有12字节了，但是接下来虚函数指针在64位下，是8字节，需要是8字节的整数倍，因此在char var1处添加4个字节来保障。</p></li></ol><h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>面试高频指数：★★★★☆</p><p>内存泄漏：由于疏忽或错误导致的程序<code>未能释放已经不再使用的内存</code>。</p><p>进一步解释：</p><ul><li><p>并非指内存从物理上消失，而是指程序在运行过程中，<code>由于疏忽或错误而失去了对该内存的控制</code>，从而造成了内存的浪费。</p></li><li><p>常指<code>堆内存泄漏</code>，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p></li><li><p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</p></li><li><p>指针重新赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">char</span> *p1 = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>p = np;<br></code></pre></td></tr></table></figure><p>开始时，指针 <code>p</code> 和 <code>p1</code> 分别指向一块内存空间，但指针 <code>p</code> 被重新赋值，导致 <code>p</code> 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p></li></ul><h2 id="怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>怎么防止内存泄漏？内存泄漏检测工具的原理？</h2><p>面试高频指数：★★★☆☆</p><p><strong>防止内存泄漏的方法：</strong></p><ol><li><p>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 构造函数中分配内存空间</span><br>    &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        p_size = n;<br>    &#125;;<br>    ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 析构函数中释放内存空间</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>            p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况，请看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    A ex1 = ex; <br>    <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>    <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单解释：对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间，但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况，看如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"> &#123;</span><br> <span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">char</span> *p;<br>     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> p_size;<br>     <span class="hljs-keyword">int</span> *p_count; <span class="hljs-comment">// 计数变量</span><br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>) <span class="hljs-comment">// 在构造函数中申请内存</span><br>     &#123;<br>         p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>         p_size = n;<br>         p_count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;<br>         *p_count = <span class="hljs-number">1</span>;<br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>     &#125;;<br>     <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A &amp;temp)<br>     &#123;<br>         p = temp.p;<br>         p_size = temp.p_size;<br>         p_count = temp.p_count;<br>         (*p_count)++; <span class="hljs-comment">// 复制时，计数变量 +1</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl;<br>     &#125;<br>     ~<span class="hljs-built_in">A</span>()<br>     &#123;<br>         (*p_count)--; <span class="hljs-comment">// 析构时，计数变量 -1</span><br>         cout &lt;&lt; <span class="hljs-string">&quot;count is : &quot;</span> &lt;&lt; *p_count &lt;&lt; endl; <br><br>         <span class="hljs-keyword">if</span> (*p_count == <span class="hljs-number">0</span>) <span class="hljs-comment">// 只有当计数变量为 0 的时候才会释放该块内存空间</span><br>         &#123;<br>             cout &lt;&lt; <span class="hljs-string">&quot;buf is deleted&quot;</span> &lt;&lt; endl;<br>             <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <br>             &#123;<br>                 <span class="hljs-keyword">delete</span>[] p; <span class="hljs-comment">// 删除字符数组</span><br>                 p = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 防止出现野指针</span><br>                 <span class="hljs-keyword">if</span> (p_count != <span class="hljs-literal">NULL</span>)<br>                 &#123;<br>                     <span class="hljs-keyword">delete</span> p_count;<br>                     p_count = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>             &#125;<br>         &#125;<br>     &#125;;<br>     <span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">GetPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>         <span class="hljs-keyword">return</span> p;<br>     &#125;;<br> &#125;;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-function">A <span class="hljs-title">ex</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>     <span class="hljs-keyword">char</span> *p = ex.<span class="hljs-built_in">GetPointer</span>();<br>     <span class="hljs-built_in">strcpy</span>(p, <span class="hljs-string">&quot;Test&quot;</span>);<br>     cout &lt;&lt; p &lt;&lt; endl;<br><br>     A ex1 = ex; <span class="hljs-comment">// 此时计数变量会 +1</span><br>     cout &lt;&lt; <span class="hljs-string">&quot;ex1.p = &quot;</span> &lt;&lt; ex1.<span class="hljs-built_in">GetPointer</span>() &lt;&lt; endl;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">fun</span>();<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">count is : <span class="hljs-number">1</span><br>Test<br>count is : <span class="hljs-number">2</span><br>ex1.p = Test<br>count is : <span class="hljs-number">1</span><br>count is : <span class="hljs-number">0</span><br>buf is deleted<br></code></pre></td></tr></table></figure><p>解释下：程序运行结果的倒数 2、3 行是调用两次析构函数时进行的操作，在第二次调用析构函数时，进行内存空间的释放，从而会有倒数第 1 行的输出结果。</p></li><li><p>智能指针</p><p>智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</p></li></ol><p><strong>内存泄漏检测工具的实现原理：</strong></p><p>内存检测工具有很多，这里重点介绍下 valgrind 。</p><p><img src="/2021/07/03/%E9%9D%A2%E7%BB%8F1%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/1612687346-kyLXKn-image.png"></p><p>valgrind 是一套 Linux 下，开放源代码（GPL V2）的仿真调试工具的集合，包括以下工具：</p><ul><li>Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。</li><li>Callgrind：检查程序中函数调用过程中出现的问题。</li><li>Cachegrind：检查程序中缓存使用出现的问题。</li><li>Helgrind：检查多线程程序中出现的竞争问题。</li><li>Massif：检查程序中堆栈使用中出现的问题。</li><li>Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具。</li></ul><p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：</p><ul><li>Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li><li>Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li></ul><p>检测原理：</p><ul><li>当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。</li><li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li></ul><h2 id="智能指针有哪几种？智能指针的实现原理？"><a href="#智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="智能指针有哪几种？智能指针的实现原理？"></a>智能指针有哪几种？智能指针的实现原理？</h2><p>面试高频指数：★★★★★</p><p>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 <memory> 头文件中。</memory></p><p>C++11 中智能指针包括以下三种：</p><ul><li>共享指针（shared_ptr）：<code>资源可以被多个指针共享</code>，使用<code>计数机制</code>表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</li><li>独占指针（unique_ptr）：<code>独享所有权</code>的智能指针，资源只能被一个指针占有，<code>该指针不能拷贝构造和赋值</code>。但可以进行移动构造和移动赋值构造（<code>调用 move() 函数</code>），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</li><li>弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够<code>解决由shared_ptr带来的循环引用问题</code>。</li></ul><p>智能指针的实现原理： 计数原理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span> : <br>T *_ptr;<br><span class="hljs-keyword">size_t</span> *_count;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SmartPtr</span>(T *ptr = <span class="hljs-literal">nullptr</span>) : _ptr(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (_ptr)<br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>_count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">size_t</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">SmartPtr</span>()<br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (*<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">SmartPtr</span>(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 拷贝构造：计数 +1</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;ptr)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>&#125;<br>&#125;<br><br>SmartPtr &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SmartPtr &amp;ptr) <span class="hljs-comment">// 赋值运算符重载 </span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr == ptr._ptr)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr) <span class="hljs-comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span><br>&#123;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)--;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>&#125;<br>&#125;<br><span class="hljs-keyword">this</span>-&gt;_ptr = ptr._ptr;<br><span class="hljs-keyword">this</span>-&gt;_count = ptr._count;<br>(*<span class="hljs-keyword">this</span>-&gt;_count)++; <span class="hljs-comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>T &amp;<span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>&#125;<br><br>T *<span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br><span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;_ptr == <span class="hljs-literal">nullptr</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>-&gt;count;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？"><a href="#一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？" class="headerlink" title="一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？"></a>一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h2><p>面试高频指数：★★☆☆☆</p><p>借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A 作为一个类 </span><br><span class="hljs-function">std::unique_ptr&lt;A&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>std::unique_ptr&lt;A&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br></code></pre></td></tr></table></figure><h2 id="使用智能指针会出现什么问题？怎么解决？"><a href="#使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="使用智能指针会出现什么问题？怎么解决？"></a>使用智能指针会出现什么问题？怎么解决？</h2><p>面试高频指数：★★★★★</p><p>智能指针可能出现的问题：<code>循环引用</code></p><p>在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环引用的解决方法： <code>weak_ptr</code></p><p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p><ul><li>weak_ptr 对被 shared_ptr 管理的对象存在 <code>非拥有性（弱）引用</code>，在访问所引用的对象前必须先转化为 shared_ptr；</li><li>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</li><li>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//shared_ptr&lt;Child&gt; ChildPtr;</span><br>    weak_ptr&lt;Child&gt; ChildPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setChild</span><span class="hljs-params">(shared_ptr&lt;Child&gt; child)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ChildPtr = child;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//new shared_ptr</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ChildPtr.<span class="hljs-built_in">lock</span>()) &#123;<br><br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Parent</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;Parent&gt; ParentPtr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPartent</span><span class="hljs-params">(shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;ParentPtr = parent;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;ParentPtr.<span class="hljs-built_in">use_count</span>()) &#123;<br><br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    weak_ptr&lt;Parent&gt; wpp;<br>    weak_ptr&lt;Child&gt; wpc;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;Parent&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent)</span></span>;<br>        <span class="hljs-function">shared_ptr&lt;Child&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child)</span></span>;<br>        p-&gt;<span class="hljs-built_in">setChild</span>(c);<br>        c-&gt;<span class="hljs-built_in">setPartent</span>(p);<br>        wpp = p;<br>        wpc = c;<br>        cout &lt;&lt; p.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>        cout &lt;&lt; c.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    &#125;<br>    cout &lt;&lt; wpp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    cout &lt;&lt; wpc.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">// 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译内存相关&quot;&gt;&lt;a href=&quot;#编译内存相关&quot; class=&quot;headerlink&quot; title=&quot;编译内存相关&quot;&gt;&lt;/a&gt;编译内存相关&lt;/h1&gt;&lt;h2 id=&quot;C-程序编译过程&quot;&gt;&lt;a href=&quot;#C-程序编译过程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="面试突击" scheme="http://pakchoi007.gitee.io/categories/%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB/"/>
    
    
    <category term="面经" scheme="http://pakchoi007.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 51-55</title>
    <link href="http://pakchoi007.gitee.io/2021/06/25/%E5%89%91%E6%8C%87offer51-55/"/>
    <id>http://pakchoi007.gitee.io/2021/06/25/%E5%89%91%E6%8C%87offer51-55/</id>
    <published>2021-06-25T06:03:00.000Z</published>
    <updated>2021-06-25T07:46:38.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-51-55"><a href="#剑指offer-51-55" class="headerlink" title="剑指offer    51~55"></a>剑指offer    51~55</h1><h2 id="五十一、构建乘积数组"><a href="#五十一、构建乘积数组" class="headerlink" title="五十一、构建乘积数组"></a>五十一、<a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&&tqId=11204&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">构建乘积数组</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。<strong>不能使用除法</strong>。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p><p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">120</span>,<span class="hljs-number">60</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(A.size())</span></span>;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] * A[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            tmp *= A[i + <span class="hljs-number">1</span>];<br>            res[i] *= tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>本题的难点在于 <strong>不能使用除法</strong> ，即需要 <strong>只用乘法</strong> 生成数组 B 。根据题目对 B[i] 的定义，可列表格，如下图所示。</p><p>根据表格的主对角线（全为 1 ），可将表格分为 <strong>上三角</strong> 和 <strong>下三角</strong> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <strong>不使用除法</strong> 就获得结果。</p><p><img src="/2021/06/25/%E5%89%91%E6%8C%87offer51-55/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png"></p><p><strong>算法流程</strong>：</p><ol><li>初始化：数组 B ，其中 B[0] = 1 ；辅助变量 tmp = 1 ；</li><li>计算 B[i] 的 <strong>下三角</strong> 各元素的乘积，直接乘入B[i] ；</li><li>计算 B[i] 的 <strong>上三角</strong> 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li><li>返回 B 。</li></ol><h2 id="☆☆☆五十二、正则表达式匹配（困难）"><a href="#☆☆☆五十二、正则表达式匹配（困难）" class="headerlink" title="☆☆☆五十二、正则表达式匹配（困难）"></a>☆☆☆五十二、<a href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">正则表达式匹配（困难）</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来匹配包括’ . ‘和’ * ‘的正则表达式。模式中的字符’ . ‘表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab * ac * a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-comment">&quot;aaa&quot;</span>,<span class="hljs-comment">&quot;a*a&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span> n = p.<span class="hljs-built_in">size</span>();<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j = j + <span class="hljs-number">2</span>) &#123;<br>dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>dp[i][j] = p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> ?<br>dp[i][j - <span class="hljs-number">2</span>] || dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; (p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>]) :<br>dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>动态规划解析：</strong></p><ul><li><p><strong>状态定义</strong>： 设动态规划矩阵 <code>dp</code> ， <code>dp[i][j]</code> 代表字符串 <code>s</code> 的前 <code>i</code> 个字符和 <code>p</code> 的前 <code>j</code> 个字符能否匹配。</p></li><li><p><strong>转移方程</strong>： 需要注意，由于 <code>dp[0][0]</code> 代表的是空字符的状态， 因此 <code>dp[i][j]</code> 对应的添加字符是 <code>s[i - 1]</code> 和 <code>p[j - 1]</code> 。</p><ul><li><p>当 <code>p[j - 1] = &#39;*&#39;</code> 时， <code>dp[i][j]</code> 在当以下任一情况为 $true$ 时等于 $true$ ：</p><ol><li><p><code>dp[i][j - 2]</code>： 即将字符组合 <code>p[j - 2] *</code> 看作出现 0 次时，能否匹配；</p></li><li><p><code>dp[i - 1][j]</code> 且 <code>s[i - 1] = p[j - 2]</code>: 即让字符 <code>p[j - 2]</code> 多出现 1 次时，能否匹配；</p></li><li><p><code>dp[i - 1][j]</code> 且 <code>p[j - 2] = &#39;.&#39;</code>: 即让字符 <code>&#39;.&#39;</code> 多出现 1 次时，能否匹配；</p></li></ol></li><li><p>当 <code>p[j - 1] != &#39;*&#39;</code> 时， <code>dp[i][j]</code> 在当以下任一情况为 $true$ 时等于 $true$ ：</p><ol><li><p><code>dp[i - 1][j - 1]</code> 且 <code>s[i - 1] = p[j - 1]</code>： 即让字符 <code>p[j - 1]</code> 多出现一次时，能否匹配；</p></li><li><p><code>dp[i - 1][j - 1]</code> 且 <code>p[j - 1] = &#39;.&#39;</code>： 即将字符 . 看作字符 <code>s[i - 1]</code> 时，能否匹配；</p></li></ol></li></ul></li><li><p><strong>初始化</strong>： 需要先初始化 <code>dp</code> 矩阵首行，以避免状态转移时索引越界。</p><ul><li><p><code>dp[0][0] = true</code>： 代表两个空字符串能够匹配。</p></li><li><p><code>dp[0][j] = dp[0][j - 2]</code> 且 <code>p[j - 1] = &#39;*&#39;</code>： 首行 <code>s</code> 为空字符串，因此当 <code>p</code> 的偶数位为 <code>*</code> 时才能够匹配（即让 p 的奇数位出现 0 次，保持 <code>p</code> 是空字符串）。因此，循环遍历字符串 <code>p</code> ，步长为 2（即只看偶数位）。</p></li></ul></li><li><p><strong>返回值</strong>： <code>dp</code> 矩阵右下角字符，代表字符串 <code>s</code> 和 <code>p</code> 能否匹配。</p></li></ul><p>参考：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/jian-zhi-offer-19-zheng-ze-biao-da-shi-pi-pei-dong/">剑指 Offer 19. 正则表达式匹配（动态规划，清晰图解） - 正则表达式匹配 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="五十三、表示数值的字符串"><a href="#五十三、表示数值的字符串" class="headerlink" title="五十三、表示数值的字符串"></a>五十三、<a href="https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">表示数值的字符串</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;123.45e+6&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;1.2.3&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt;<span class="hljs-built_in">states</span>(<span class="hljs-number">9</span>);<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">1</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>));<br>states[<span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">4</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">2</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>));<br>states[<span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>));<br>states[<span class="hljs-number">3</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">4</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">3</span>));<br>states[<span class="hljs-number">5</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-number">6</span>));<br>states[<span class="hljs-number">5</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">6</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">7</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">7</span>));<br>states[<span class="hljs-number">7</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br>states[<span class="hljs-number">8</span>].<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">8</span>));<br><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> t;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str) &#123;<br><span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)t = <span class="hljs-string">&#x27;d&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>)t = <span class="hljs-string">&#x27;s&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span>)t = <span class="hljs-string">&#x27;e&#x27;</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;.&#x27;</span> || c == <span class="hljs-string">&#x27; &#x27;</span>)t = c;<br><span class="hljs-keyword">else</span> t = <span class="hljs-string">&#x27;?&#x27;</span>;<br><span class="hljs-keyword">if</span> (!states[p].<span class="hljs-built_in">count</span>(t))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>p = states[p][t];<br>&#125;<br><span class="hljs-keyword">return</span> p == <span class="hljs-number">2</span> || p == <span class="hljs-number">3</span> || p == <span class="hljs-number">7</span> || p == <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>有限状态自动机</strong></p><p><strong>状态定义：</strong></p><p>按照字符串从左到右的顺序，定义以下 9 种状态。</p><ol><li><p>开始的空格</p></li><li><p>幂符号前的正负号</p></li><li><p>小数点前的数字</p></li><li><p>小数点、小数点后的数字</p></li><li><p>当小数点前为空格时，小数点、小数点后的数字</p></li><li><p>幂符号</p></li><li><p>幂符号后的正负号</p></li><li><p>幂符号后的数字</p></li><li><p>结尾的空格</p></li></ol><p><strong>结束状态：</strong></p><p>合法的结束状态有 2, 3, 7, 8 。</p><p><img src="/2021/06/25/%E5%89%91%E6%8C%87offer51-55/6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1.png"></p><p><strong>算法流程：</strong></p><ol><li><p><strong>初始化</strong>：</p><ol><li>状态转移表 $states$ ： 设 $states[i]$ ，其中 $i$ 为所处状态， $states[i]$ 使用哈希表存储可转移至的状态。键值对 $(key, value)$ 含义：若输入 $key$ ，则可从状态 $i$ 转移至状态 $value$ 。</li><li>当前状态 $p$ ： 起始状态初始化为 $p = 0$ 。</li></ol></li><li><p><strong>状态转移循环</strong>： 遍历字符串 $s$ 的每个字符 $c$ 。</p><ol><li><p>记录字符类型 $t$ ： 分为四种情况。</p><ul><li><p>当 $c$ 为正负号时，执行 <code>t = &#39;s&#39;</code> ;</p></li><li><p>当 $c$ 为数字时，执行 <code>t = &#39;d&#39;</code> ;</p></li><li><p>当 $c$ 为 <code>e , E</code> 时，执行 <code>t = &#39;e&#39; </code>;</p></li><li><p>当 $c$ 为 <code>.</code> , <code>空格</code> 时，执行 <code>t = c</code> （即用字符本身表示字符类型）;</p></li><li><p>否则，执行 <code>t = &#39;?&#39;</code> ，代表为不属于判断范围的非法字符，后续直接返回 $ false $ 。</p></li></ul></li><li><p>终止条件： 若字符类型 $t$ 不在哈希表 $states[p]$ 中，说明无法转移至下一状态，因此直接返回 $ false$ 。</p></li><li><p>状态转移： 状态 $p$ 转移至 $ states[p][t] $ 。</p></li></ol></li><li><p><strong>返回值</strong>： 跳出循环后，若状态 $p \in {2, 3, 7, 8}$，说明结尾合法，返回 $ true $ ，否则返回 $ false $ 。</p></li></ol><p><strong>另一种方法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* string)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> sign = <span class="hljs-literal">false</span>, decimal = <span class="hljs-literal">false</span>,hasE = <span class="hljs-literal">false</span>;<span class="hljs-comment">//正负号 小数点 e</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(string);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>        <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;e&#x27;</span> || string[i] == <span class="hljs-string">&#x27;E&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>( i == len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//e 的后面必须要出现数字 对应 12e</span><br>            <span class="hljs-keyword">if</span>(hasE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//只能有一个e</span><br>            hasE = <span class="hljs-literal">true</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;+&#x27;</span> || string[i] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;                <br>            <span class="hljs-keyword">if</span>(!sign &amp;&amp; i&gt;<span class="hljs-number">0</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-comment">// 12e+5 如果第一次出现，且不是在开头，那么也要紧跟在e/E之后</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(sign &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; string[i<span class="hljs-number">-1</span>] !=<span class="hljs-string">&#x27;E&#x27;</span>)<span class="hljs-comment">// +5e-6  第二次出现，那也要跟在 e/E之后</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            sign = <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(decimal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">if</span>(hasE) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// E后面不能跟小数点  12e+4.3</span><br><br>            decimal = <span class="hljs-literal">true</span>;<br><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || string[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<span class="hljs-comment">//不合法字符</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五十四、字符流中第一个不重复的字符"><a href="#五十四、字符流中第一个不重复的字符" class="headerlink" title="五十四、字符流中第一个不重复的字符"></a>五十四、<a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">字符流中第一个不重复的字符</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>后台会用以下方式调用Insert 和 FirstAppearingOnce 函数</p><blockquote><p>string caseout = “”;</p><p>1.读入测试用例字符串casein</p><p>2.如果对应语言有Init()函数的话，执行Init() 函数</p><p>3.循环遍历字符串里的每一个字符ch {</p><p>Insert(ch);</p><p>caseout += FirstAppearingOnce()</p><p>}</p><p>2.输出caseout，进行比较。</p></blockquote><p><strong>返回值描述：</strong></p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;google&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;ggg<span class="hljs-subst">#ll</span>&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">char</span>&gt; vec;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; res;<br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(ch);<br>        res[ch]++;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : vec) &#123;<br>            <span class="hljs-keyword">if</span>(res[ch] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ch;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>vector 读取字符流中的字符</p><p>map 存每个字符出现的次数</p><p>遍历 vector ，判断当字符次数为 1 时，返回当前字符</p><p>若遍历结束还没有符合的字符，返回 #</p><h2 id="五十五、链表中环的入口结点"><a href="#五十五、链表中环的入口结点" class="headerlink" title="五十五、链表中环的入口结点"></a>五十五、<a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">链表中环的入口结点</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p><p><strong>输入描述</strong>：</p><p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台将这2个会组装成一个有环或者无环单链表</p><p><strong>返回值描述</strong>：</p><p>返回链表的环的入口结点即可。而我们后台程序会打印这个节点</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,2&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;3,4,5&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">返回环形链表入口节点，我们后台会打印该环形链表入口节点，即3    <br></code></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;null&quot;</span><br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">没有环，返回<span class="hljs-keyword">null</span>，后台打印<span class="hljs-string">&quot;null&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">只有环形链表节点2，返回节点2，后台打印2   <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        unordered_map&lt;ListNode*, <span class="hljs-keyword">int</span>&gt;m;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            m[pHead]++;<br>            <span class="hljs-keyword">if</span>(m[pHead] == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> pHead;<br>            pHead = pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>方法一：哈希表</strong></p><p>通过map函数判断是否存在环路，此时将value值设置为出现的次数</p><p><strong>方法二：快慢指针</strong></p><p>两个指针一个fast、一个slow同时从一个链表的头部出发 fast一次走2步，slow一次走一步，如果该链表有环，两个指针必然在环内相遇 此时只需要把其中的一个指针重新指向链表头部，另一个不变（还在环内）， 这次两个指针一次走一步，相遇的地方就是入口节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode*fast = pHead,*low = pHead;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            low = low-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast == low)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast || !fast-&gt;next)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        low = pHead;<span class="hljs-comment">//low从链表头出发</span><br>        <span class="hljs-keyword">while</span>(fast != low) &#123;<span class="hljs-comment">//fast从相遇点出发</span><br>            fast = fast-&gt;next;<br>            low = low-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>算法流程：</strong></p><ol><li><p>双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p><ol><li><p>第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；</p><ul><li>TIPS: 若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；</li></ul></li><li><p>第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：</p><ul><li><p>设链表共有 a+b 个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数）；设两指针分别走了 f，s 步，则有：</p></li><li><p>fast 走的步数是slow步数的 2 倍，即 f=2s；（解析： fast 每轮走 2 步）</p></li><li><p>fast 比 slow多走了 n 个环的长度，即 f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；</p></li><li><p>以上两式相减得：f=2nb，s=nb，即 fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。</p></li></ul></li></ol></li><li><p>目前情况分析：</p><ul><li>如果让指针从链表头部一直向前走并统计步数k，那么所有 走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。</li><li>而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。</li><li>但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。</li></ul></li><li><p>双指针第二次相遇：</p><ul><li><p>slow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 1 步；</p><ul><li>TIPS：此时 f=0，s=nb ；</li></ul></li><li><p>当 fast 指针走到 f=a 步时，slow 指针走到步 s=a+nb，此时 两指针重合，并同时指向链表环入口 。</p></li></ul></li><li><p>返回slow指针指向的节点。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-51-55&quot;&gt;&lt;a href=&quot;#剑指offer-51-55&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    51~55&quot;&gt;&lt;/a&gt;剑指offer    51~55&lt;/h1&gt;&lt;h2 id=&quot;五十一、构建乘积数组&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 46-50</title>
    <link href="http://pakchoi007.gitee.io/2021/06/24/%E5%89%91%E6%8C%87offer46-50/"/>
    <id>http://pakchoi007.gitee.io/2021/06/24/%E5%89%91%E6%8C%87offer46-50/</id>
    <published>2021-06-24T05:36:00.000Z</published>
    <updated>2021-06-24T06:43:25.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-46-50"><a href="#剑指offer-46-50" class="headerlink" title="剑指offer    46~50"></a>剑指offer    46~50</h1><h2 id="四十六、孩子们的游戏-圆圈中最后剩下的数"><a href="#四十六、孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="四十六、孩子们的游戏(圆圈中最后剩下的数)"></a>四十六、<a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏(圆圈中最后剩下的数)</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            pos = (pos + m) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pos;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>约瑟夫问题</strong></p><p>下面这个例子是<code>N=8 m=3</code>的例子</p><p>我们定义<code>F(n,m)</code>表示最后剩下那个人的<code>索引号</code>，因此我们只关系最后剩下来这个人的索引号的变化情况即可</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF1.png"></p><p>从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号</p><ul><li><p>第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）</p></li><li><p>第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）</p></li><li><p>第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）</p></li><li><p>以此类推，当只剩一个人时，他的编号必定为0！（重点！）</p></li></ul><p><strong>最终活着的人编号的反推</strong></p><p>现在我们知道了G的索引号的变化过程，那么我们反推一下</p><p>从<code>N = 7</code> 到<code>N = 8</code> 的过程</p><p>如何才能将<code>N = 7</code> 的排列变回到<code>N = 8</code> 呢？</p><p>我们先把被杀掉的<code>C</code>补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面</p><p>经过这个操作就恢复了N = 8 的排列了！</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/68509352d82d4a19678ed67a5bde338f86c7d0da730e3a69546f6fa61fb0063c-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF2.png"></p><p>因此我们可以推出递推公式 f(8,3) = [f(7, 3) + 3] % 8​</p><p>进行推广泛化，即 <code>f(n,m) = [f(n-1, m) + m] % n​</code></p><h2 id="四十七、求1-2-3-…-n"><a href="#四十七、求1-2-3-…-n" class="headerlink" title="四十七、求1+2+3+…+n"></a>四十七、<a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">求1+2+3+…+n</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">5<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">15<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">bool</span> x = n &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">Sum_Solution</span>(n - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>;<br>        res += n;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>1+2+…+(n−1)+n 的计算方法主要有三种：平均计算、迭代、递归。</p><p>本题只能使用递归</p><p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：</p><p>if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</p><p>if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</p><p>本题需要实现 “当 n = 1 时终止递归” 的需求，可通过短路效应实现。</p><p>n &gt; 1 &amp;&amp; sumNums(n - 1)   // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</p><h2 id="四十八、不用加减乘除做加法"><a href="#四十八、不用加减乘除做加法" class="headerlink" title="四十八、不用加减乘除做加法"></a>四十八、<a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">不用加减乘除做加法</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(num2 != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> x = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>            num1 ^= num2;<br>            num2 = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第二版便于理解</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(num2 != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> sum = num1 ^ num2;<br>        <span class="hljs-keyword">int</span> carray = (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>        num1 = sum;<br>        num2 = carray;<br>    &#125; <br>    <span class="hljs-keyword">return</span> num1;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>设两数字的二进制形式 $a$, $b$，其求和 $s = a + b$ ， $a(i)$ 代表 $a$ 的二进制第 $i$ 位，则分为以下四种情况：</p><table><thead><tr><th align="center">$a(i)$</th><th align="center">$b(i)$</th><th align="center"><strong>无进位和</strong> $n(i)$</th><th align="center"><strong>进位</strong> $c(i+1)$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>观察发现，<code>无进位和</code> 与 <code>异或运算</code> 规律相同，进位 和 与运算 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；<br>n=a⊕b           非进位和：异或运算</p><p>c=a&amp;b&lt;&lt;1      进位：与运算+左移一位</p><p>（和 s ）=（非进位和 n ）+（进位 c ）。即可将 s = a + b 转化为：$s = a + b \Rightarrow s = n + c$</p><p>循环求 n 和 c，直至进位 c = 0；此时 s = n ，返回 n 即可。</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/56d56524d8d2b1318f78e209fffe0e266f97631178f6bfd627db85fcd2503205-Picture1.png"></p><h2 id="四十九、把字符串转换成整数"><a href="#四十九、把字符串转换成整数" class="headerlink" title="四十九、把字符串转换成整数"></a>四十九、<a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把字符串转换成整数</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p><strong>输入描述：</strong></p><p>输入一个字符串,包括数字字母符号,可以为空</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>如果是合法的数值表达则返回该数字，否则返回0</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;+2147483647&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">2147483647</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;1a33&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">0<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">StrToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//为空，直接返回即可</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, flag = <span class="hljs-number">1</span>,isSingal = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 索引 正负号标志位  正负号出现次数</span><br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//默认flag = 1，正数</span><br>        <span class="hljs-keyword">while</span> (i&lt;len &amp;&amp; str[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++; <span class="hljs-comment">//若str全为空格，str[i] = &#x27;\0&#x27;(最后一个i)</span><br>        <span class="hljs-keyword">if</span> (i &gt;= len) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//全部都是空格，直接返回</span><br>        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; <br>            flag = <span class="hljs-number">-1</span>; <br>            i++; <br>            isSingal++; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; str[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123; <br>            i++; <br>            isSingal++; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (isSingal &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (  ; i &lt; len ; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span> || str[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            res = res * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (res &gt;= INT_MAX &amp;&amp; flag == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  INT_MAX;<br>            <span class="hljs-keyword">if</span> (res &gt; INT_MAX &amp;&amp; flag == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>  INT_MIN;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag * res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>直接看代码解析</p><p>需要有正负号标志位  正负号出现次数</p><h2 id="五十、数组中重复的数字"><a href="#五十、数组中重复的数字" class="headerlink" title="五十、数组中重复的数字"></a>五十、<a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中重复的数字</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>或<span class="hljs-number">3</span>都是对的 <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(numbers.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s[numbers[i]]++;<br>            <span class="hljs-keyword">if</span>(s[numbers[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析：</p><p>类似于<strong>哈希表</strong>做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span>(map[num]) <span class="hljs-keyword">return</span> num;<br>            map[num] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者</p><p><strong>原地交换</strong>，空间复杂度 $O(1)$</p><p><img src="/2021/06/24/%E5%89%91%E6%8C%87offer46-50/1618146573-bOieFQ-Picture0.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i])<br>                <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[nums[i]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-46-50&quot;&gt;&lt;a href=&quot;#剑指offer-46-50&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    46~50&quot;&gt;&lt;/a&gt;剑指offer    46~50&lt;/h1&gt;&lt;h2 id=&quot;四十六、孩子们的游戏-圆圈中最</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>C++11 其他知识点</title>
    <link href="http://pakchoi007.gitee.io/2021/06/24/C++11%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://pakchoi007.gitee.io/2021/06/24/C++11%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-06-24T03:44:19.000Z</published>
    <updated>2021-06-24T03:44:17.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、C-11-其他知识点"><a href="#八、C-11-其他知识点" class="headerlink" title="八、C++11 其他知识点"></a>八、C++11 其他知识点</h1><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p>直接看代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = vec.<span class="hljs-built_in">begin</span>(); iter != vec.<span class="hljs-built_in">end</span>(); iter++) &#123; <span class="hljs-comment">// before c++11</span><br>   cout &lt;&lt; *iter &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : vec) &#123; <span class="hljs-comment">// c++11基于范围的for循环</span><br>cout &lt;&lt; <span class="hljs-string">&quot;i&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p><p><strong>不使用委托构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>()&#123;&#125;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-comment">// 好麻烦</span><br>       a_ = a;<br>       b_ = b;<br>  &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) &#123; <span class="hljs-comment">// 好麻烦</span><br>       a_ = a;<br>       b_ = b;<br>       c_ = c;<br>  &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>使用委托构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>()&#123;&#125;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">A</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">A</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：</p><p><strong>不使用继承构造函数：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-built_in">Base</span>() &#123;&#125;<br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br>   <span class="hljs-built_in">Derived</span>() &#123;&#125;<br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a) : <span class="hljs-built_in">Base</span>(a) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a, b) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>   <span class="hljs-built_in">Derived</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b, c) &#123;&#125; <span class="hljs-comment">// 好麻烦</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Derived <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用继承构造函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-built_in">Base</span>() &#123;&#125;<br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a) &#123; a_ = a; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) : <span class="hljs-built_in">Base</span>(a) &#123; b_ = b; &#125;<br><br>   <span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">Base</span>(a, b) &#123; c_ = c; &#125;<br><br>   <span class="hljs-keyword">int</span> a_;<br>   <span class="hljs-keyword">int</span> b_;<br>   <span class="hljs-keyword">int</span> c_;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base &#123;<br>   <span class="hljs-keyword">using</span> Base::Base;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">Derived <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要使用using Base::Base继承构造函数，就免去了很多重写代码的麻烦。</p><h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>nullptr是c++11用来表示空指针新引入的常量值，在c++中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;func ptr&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;func i&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 编译失败，会产生二义性</span><br>   <span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 输出func ptr</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="final-amp-override"><a href="#final-amp-override" class="headerlink" title="final &amp; override"></a>final &amp; override</h2><p>c++11关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><p>示例代码1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 确保func被重写</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fu</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// error，基类没有fu()，不可以被重写</span><br>       <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> <span class="hljs-keyword">final</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// 编译失败，final修饰的类不可以被继承</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>c++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a; <span class="hljs-comment">// 编译出错</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“<code>=default;</code>”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a1;<br>   A a2 = a1;  <span class="hljs-comment">// 正确，调用编译器隐式生成的默认拷贝构造函数</span><br>   A a3;<br>   a3 = a1;  <span class="hljs-comment">// 正确，调用编译器隐式生成的默认拷贝赋值操作符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">const</span> A&amp;) = <span class="hljs-keyword">delete</span>;<br>   A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> A&amp;) = <span class="hljs-keyword">delete</span>;<br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> i) &#123; a = i; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a1;<br>   A a2 = a1;  <span class="hljs-comment">// 错误，拷贝构造函数被禁用</span><br>   A a3;<br>   a3 = a1;  <span class="hljs-comment">// 错误，拷贝赋值操作符被禁用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>delele函数在c++11中很常用，<code>std::unique_ptr</code>就是通过delete修饰来禁止对象的拷贝的。</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看explicit的作用：</p><p>不用explicit：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> value) &#123; <span class="hljs-comment">// 没有explicit关键字</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;value&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以隐式转换</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用explicit:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;value&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，不可以隐式转换</span><br>   <span class="hljs-function">A <span class="hljs-title">aa</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// ok</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>因为要讲后面的constexpr，所以这里简单介绍下const。</p><p>const字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p><p>主要用法如下：</p><ol><li><p>用于定义常量，const的修饰的变量不可更改。</p></li><li><p>指针也可以使用const，这里有个小技巧，从右向左读，即可知道const究竟修饰的是指针,还是指针所指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> ptr; <span class="hljs-comment">// 指针本身是常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ptr; <span class="hljs-comment">// 指针指向的变量为常量</span><br></code></pre></td></tr></table></figure></li><li><p>在函数参数中使用const，一般会传递类对象时会传递一个const的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> A&amp; a)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>const修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">5</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> value;<br><span class="hljs-built_in">B</span>(<span class="hljs-keyword">int</span> v) : <span class="hljs-built_in">value</span>(v)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>修饰类对象，类对象只能调用该对象的const成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">const</span> A a;<br>a.<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure></li></ol><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，<strong>这个函数的返回值会尽可能在编译期间被计算出来当作一个常量</strong>，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>   <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>   <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h2><p>c++11新增有作用域的枚举类型，看代码</p><p><strong>不带作用域的枚举代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AColor</span> &#123;</span><br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">BColor</span> &#123;</span><br>   kWhite,<br>   kBlack,<br>   kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (kRed == kWhite) &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。</p><p><strong>有作用域的枚举代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AColor</span> &#123;</span><br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BColor</span> &#123;</span><br>   kWhite,<br>   kBlack,<br>   kYellow<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (AColor::kRed == BColor::kWhite) &#123; <span class="hljs-comment">// 编译失败</span><br>       cout &lt;&lt; <span class="hljs-string">&quot;red == white&quot;</span> &lt;&lt; endl;<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在bug，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AColor</span> :</span> <span class="hljs-keyword">char</span> &#123;<br>   kRed,<br>   kGreen,<br>   kBlue<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</p><h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>c++11之前union中数据成员的类型不允许有非POD类型，而这个限制在c++11被取消，允许数据成员类型有非POD类型，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> a;<br>   <span class="hljs-keyword">int</span> *b;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span> &#123;</span><br>   A a; <span class="hljs-comment">// 非POD类型 c++11之前不可以这样定义联合体</span><br>   <span class="hljs-keyword">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于什么是POD类型，大家可以自行查下资料，大体上可以理解为对象可以直接memcpy的类型。</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>c++11中sizeof可以用的类的数据成员上，看代码：</p><p><strong>c++11前：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> data[<span class="hljs-number">10</span>];<br>   <span class="hljs-keyword">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   A a;<br>   cout &lt;&lt; <span class="hljs-string">&quot;size &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a.data) &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>c++11</strong>后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   <span class="hljs-keyword">int</span> data[<span class="hljs-number">10</span>];<br>   <span class="hljs-keyword">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   cout &lt;&lt; <span class="hljs-string">&quot;size &quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A::data) &lt;&lt; endl;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>想知道类中数据成员的大小在c++11中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p><h2 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h2><p>c++11引入static_assert声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>, message);<br></code></pre></td></tr></table></figure><h2 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h2><p>c++11可以自定义字面量，我们平时c++中都或多或少使用过chrono中的时间，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 100ms</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 100s</span><br></code></pre></td></tr></table></figure><p>其实没必要这么麻烦，也可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">100</span>ms); <span class="hljs-comment">// c++14里可以这么使用，这里只是举个自定义字面量使用的例子</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">100</span>s);<br></code></pre></td></tr></table></figure><p>这就是自定义字面量的使用，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mytype</span> &#123;</span><br>   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> value;<br>&#125;;<br><span class="hljs-keyword">constexpr</span> mytype <span class="hljs-keyword">operator</span><span class="hljs-string">&quot;&quot;</span> _mytype ( <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n ) &#123;<br>   <span class="hljs-keyword">return</span> mytype&#123;n&#125;;<br>&#125;<br>mytype mm = <span class="hljs-number">123</span>_mytype;<br>cout &lt;&lt; mm.value &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><strong>什么是内存对齐</strong></p><p>理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数<strong>N的倍数</strong>，这就是内存对齐。</p><p><strong>为什么要内存对齐</strong></p><ol><li>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。</li><li>提高CPU内存访问速度，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</li></ol><p>在c++11之前如果想创建内存对齐需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">align_cpp11_before</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> data[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) + <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A)];<br>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uintptr_t</span> kAlign = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *) - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">char</span> *align_ptr =<br>       <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char</span> *&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span>&gt;(data + kAlign) &amp; ~kAlign);<br>   A *attr = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (align_ptr) A;<br>&#125;<br></code></pre></td></tr></table></figure><p>c++11关于内存对齐新增了一些函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">align_cpp11_after</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">static</span> std::aligned_storage&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A),<br>                               <span class="hljs-built_in"><span class="hljs-keyword">alignof</span></span>(A)&gt;::type data;<br>   A *attr = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (&amp;data) A;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><p>c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name)</span> </span>&#123;<br>        <span class="hljs-keyword">thread_local</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        ++count;<br>        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name)</span> </span>&#123;<br>    A a1;<br>    a1.<span class="hljs-built_in">test</span>(name);<br>    a1.<span class="hljs-built_in">test</span>(name);<br>    A a2;<br>    a2.<span class="hljs-built_in">test</span>(name);<br>    a2.<span class="hljs-built_in">test</span>(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">thread</span>(func, <span class="hljs-string">&quot;thread1&quot;</span>).<span class="hljs-built_in">join</span>();<br>    std::<span class="hljs-built_in">thread</span>(func, <span class="hljs-string">&quot;thread2&quot;</span>).<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">thread1</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">thread1</span>: <span class="hljs-number">4</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">1</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">2</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">3</span><br><span class="hljs-attribute">thread2</span>: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。</p><h2 id="基础数值类型"><a href="#基础数值类型" class="headerlink" title="基础数值类型"></a>基础数值类型</h2><p>c++11新增了几种数据类型：long long、char16_t、char32_t等</p><h2 id="随机数功能"><a href="#随机数功能" class="headerlink" title="随机数功能"></a>随机数功能</h2><p>c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">std::default_random_engine <span class="hljs-title">random</span><span class="hljs-params">(time(<span class="hljs-literal">nullptr</span>))</span></span>;<br><br>   <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">int_dis</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">// 整数均匀分布</span><br>   <span class="hljs-function">std::uniform_real_distribution&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">real_dis</span><span class="hljs-params">(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">// 浮点数均匀分布</span><br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>       cout &lt;&lt; <span class="hljs-built_in">int_dis</span>(random) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>   cout &lt;&lt; endl;<br><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>       cout &lt;&lt; <span class="hljs-built_in">real_dis</span>(random) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>   cout &lt;&lt; endl;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">38</span> <span class="hljs-number">100</span> <span class="hljs-number">93</span> <span class="hljs-number">7</span> <span class="hljs-number">66</span> <span class="hljs-number">0</span> <span class="hljs-number">68</span> <span class="hljs-number">99</span> <span class="hljs-number">41</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">232202</span> <span class="hljs-number">0</span>.<span class="hljs-number">617716</span> <span class="hljs-number">0</span>.<span class="hljs-number">959241</span> <span class="hljs-number">0</span>.<span class="hljs-number">970859</span> <span class="hljs-number">0</span>.<span class="hljs-number">230406</span> <span class="hljs-number">0</span>.<span class="hljs-number">430682</span> <span class="hljs-number">0</span>.<span class="hljs-number">477359</span> <span class="hljs-number">0</span>.<span class="hljs-number">971858</span> <span class="hljs-number">0</span>.<span class="hljs-number">0171148</span> <span class="hljs-number">0</span>.<span class="hljs-number">64863</span><br></code></pre></td></tr></table></figure><p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>c++11引入了regex库更好的支持正则表达式，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::string s = <span class="hljs-string">&quot;I know, I&#x27;ll use2 regular expressions.&quot;</span>;<br><span class="hljs-comment">// 忽略大小写</span><br>   <span class="hljs-function">std::regex <span class="hljs-title">self_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;REGULAR EXPRESSIONS&quot;</span>, std::regex_constants::icase)</span></span>;<br>   <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(s, self_regex)) &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;Text contains the phrase &#x27;regular expressions&#x27;\n&quot;</span>;<br>  &#125;<br><br>   <span class="hljs-function">std::regex <span class="hljs-title">word_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;(\\w+)&quot;</span>)</span></span>;  <span class="hljs-comment">// 匹配字母数字等字符</span><br>   <span class="hljs-keyword">auto</span> words_begin = std::<span class="hljs-built_in">sregex_iterator</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), word_regex);<br>   <span class="hljs-keyword">auto</span> words_end = std::<span class="hljs-built_in">sregex_iterator</span>();<br><br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; std::<span class="hljs-built_in">distance</span>(words_begin, words_end) &lt;&lt; <span class="hljs-string">&quot; words\n&quot;</span>;<br><br>   <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">6</span>;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;Words longer than &quot;</span> &lt;&lt; N &lt;&lt; <span class="hljs-string">&quot; characters:\n&quot;</span>;<br>   <span class="hljs-keyword">for</span> (std::sregex_iterator i = words_begin; i != words_end; ++i) &#123;<br>       std::smatch match = *i;<br>       std::string match_str = match.<span class="hljs-built_in">str</span>();<br>       <span class="hljs-keyword">if</span> (match_str.<span class="hljs-built_in">size</span>() &gt; N) &#123;<br>           std::cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; match_str &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>      &#125;<br>  &#125;<br><br>   <span class="hljs-function">std::regex <span class="hljs-title">long_word_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;(\\w&#123;7,&#125;)&quot;</span>)</span></span>;<br>   <span class="hljs-comment">// 超过7个字符的单词用[]包围</span><br>   std::string new_s = std::<span class="hljs-built_in">regex_replace</span>(s, long_word_regex, <span class="hljs-string">&quot;[$&amp;]&quot;</span>);<br>   std::cout &lt;&lt; new_s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h2><p>c++11关于时间引入了chrono库，源于boost，功能强大，chrono主要有三个点：</p><ul><li>duration</li><li>time_point</li><li>clocks</li></ul><p><strong>duration</strong></p><p>std::chrono::duration 表示一段时间，常见的单位有s、ms等，示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拿休眠一段时间举例，这里表示休眠100ms</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><p>sleep_for里面其实就是std::chrono::duration，表示一段时间，实际是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> duration&lt;<span class="hljs-keyword">int64_t</span>, milli&gt; milliseconds;<br><span class="hljs-keyword">typedef</span> duration&lt;<span class="hljs-keyword">int64_t</span>&gt; seconds;<br></code></pre></td></tr></table></figure><p>duration具体模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rep</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Period</span> =</span> ratio&lt;<span class="hljs-number">1</span>&gt; &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">duration</span>;</span><br></code></pre></td></tr></table></figure><p>Rep表示一种数值类型，用来表示Period的数量，比如int、float、double，Period是ratio类型，用来表示【用秒表示的时间单位】比如second，常用的duration&lt;Rep, Period&gt;已经定义好了，在std::chrono::duration下：</p><ul><li>ratio&lt;3600, 1&gt;：hours</li><li>ratio&lt;60, 1&gt;：minutes</li><li>ratio&lt;1, 1&gt;：seconds</li><li>ratio&lt;1, 1000&gt;：microseconds</li><li>ratio&lt;1, 1000000&gt;：microseconds</li><li>ratio&lt;1, 1000000000&gt;：nanosecons</li></ul><p>ratio的具体模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">intmax_t</span> N, <span class="hljs-keyword">intmax_t</span> D = <span class="hljs-number">1</span>&gt; class ratio;<br></code></pre></td></tr></table></figure><p>N代表分子，D代表分母，所以ratio表示一个分数，我们可以自定义Period，比如ratio&lt;2, 1&gt;表示单位时间是2秒。</p><p><strong>time_point</strong></p><p>表示一个具体时间点，如2020年5月10日10点10分10秒，拿获取当前时间举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">chrono::time_point&lt;std::chrono::high_resolution_clock&gt; <span class="hljs-title">Now</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>&#125;<br><span class="hljs-comment">// std::chrono::high_resolution_clock为高精度时钟，下面会提到</span><br></code></pre></td></tr></table></figure><p><strong>clocks</strong></p><p>时钟，chrono里面提供了三种时钟：</p><ul><li>steady_clock</li><li>system_clock</li><li>high_resolution_clock</li></ul><ol><li><p><strong>steady_clock</strong></p><p>稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用now()肯定比前一次调用now()的数值大，可用于计时。</p></li><li><p><strong>system_clock</strong></p><p>表示当前的系统时钟，可以用于获取当前时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">using</span> std::chrono::system_clock;<br>   system_clock::time_point today = system_clock::<span class="hljs-built_in">now</span>();<br><br>   std::<span class="hljs-keyword">time_t</span> tt = system_clock::<span class="hljs-built_in">to_time_t</span>(today);<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;today is: &quot;</span> &lt;&lt; <span class="hljs-built_in">ctime</span>(&amp;tt);<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// today is: Sun May 10 09:48:36 2020</span><br></code></pre></td></tr></table></figure></li><li><p><strong>high_resolution_clock</strong></p><p>high_resolution_clock表示系统可用的最高精度的时钟，实际上就是system_clock或者steady_clock其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，我之前看gcc chrono源码中high_resolution_clock是steady_clock的typedef。</p></li></ol><h2 id="新增数据结构"><a href="#新增数据结构" class="headerlink" title="新增数据结构"></a>新增数据结构</h2><ul><li><p>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于std::list节省了内存，提高了性能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::forward_list&lt;<span class="hljs-keyword">int</span>&gt; fl = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;elem : fl) &#123;<br>   cout &lt;&lt; elem;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似</p></li><li><p>std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似</p></li><li><p>std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组</p></li><li><p>std::tuple：元组类型，类似pair，但比pair扩展性好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt; Mytuple;<br><span class="hljs-function">Mytuple <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;0 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">0</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;1 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">1</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">2</span>&gt;(t);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;3 &quot;</span> &lt;&lt; std::get&lt;<span class="hljs-number">3</span>&gt;(t);<br></code></pre></td></tr></table></figure></li></ul><h2 id="新增算法"><a href="#新增算法" class="headerlink" title="新增算法"></a>新增算法</h2><ul><li><p>all_of：检测表达式是否对范围[first, last)中所有元素都返回true，如果都满足，则返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">all_of</span>(v.<span class="hljs-built_in">cbegin</span>(), v.<span class="hljs-built_in">cend</span>(), [](<span class="hljs-keyword">int</span> i) &#123; <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;)) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;All numbers are even\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>any_of：检测表达式是否对范围[first, last)中至少一个元素返回true，如果满足，则返回true，否则返回false，用法和上面一样</p></li><li><p>none_of：检测表达式是否对范围[first, last)中所有元素都不返回true，如果都不满足，则返回true，否则返回false，用法和上面一样</p></li><li><p>find_if_not：找到第一个不符合要求的元素迭代器，和find_if相反</p></li><li><p>copy_if：复制满足条件的元素</p></li><li><p>itoa：对容器内的元素按序递增</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>std::<span class="hljs-built_in">iota</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), <span class="hljs-number">19</span>); <span class="hljs-comment">// 19为初始值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : l) std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">// 19 20 21 22 23 24 25 26 27 28</span><br></code></pre></td></tr></table></figure></li><li><p>minmax_element：返回容器内最大元素和最小元素位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;<br><br>   <span class="hljs-keyword">auto</span> result = std::<span class="hljs-built_in">minmax_element</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;min element at: &quot;</span> &lt;&lt; *(result.first) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>   std::cout &lt;&lt; <span class="hljs-string">&quot;max element at: &quot;</span> &lt;&lt; *(result.second) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// min element at: 1</span><br><span class="hljs-comment">// max element at: 9</span><br></code></pre></td></tr></table></figure></li><li><p>is_sorted、is_sorted_until：返回容器内元素是否已经排好序。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;八、C-11-其他知识点&quot;&gt;&lt;a href=&quot;#八、C-11-其他知识点&quot; class=&quot;headerlink&quot; title=&quot;八、C++11 其他知识点&quot;&gt;&lt;/a&gt;八、C++11 其他知识点&lt;/h1&gt;&lt;h2 id=&quot;基于范围的for循环&quot;&gt;&lt;a href=&quot;#基</summary>
      
    
    
    
    <category term="C++11 新特性" scheme="http://pakchoi007.gitee.io/categories/C-11-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="C++11" scheme="http://pakchoi007.gitee.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11 线程相关所有知识点</title>
    <link href="http://pakchoi007.gitee.io/2021/06/23/C++11%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://pakchoi007.gitee.io/2021/06/23/C++11%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-06-23T06:04:19.000Z</published>
    <updated>2021-06-25T08:25:52.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、线程相关所有知识点"><a href="#七、线程相关所有知识点" class="headerlink" title="七、线程相关所有知识点"></a>七、线程相关所有知识点</h1><p>c++11关于并发引入了好多好东西，这里按照如下顺序介绍：</p><ul><li>std::thread相关</li><li>std::mutex相关</li><li>std::lock相关</li><li>std::atomic相关</li><li>std::call_once相关</li><li>volatile相关</li><li>std::condition_variable相关</li><li>std::future相关</li><li>async相关</li></ul><h2 id="std-thread相关"><a href="#std-thread相关" class="headerlink" title="std::thread相关"></a>std::thread相关</h2><p>c++11之前你可能使用pthread_xxx来创建线程，繁琐且不易读，c++11引入了std::thread来创建线程，支持对线程 join 或者 detach 。直接看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> func = []() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>()) &#123;<br>        t.<span class="hljs-built_in">detach</span>();    <span class="hljs-comment">//线程分离</span><br>    &#125;<br>    <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-function">std::thread <span class="hljs-title">tt</span><span class="hljs-params">(func1, <span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (tt.<span class="hljs-built_in">joinable</span>()) &#123; <span class="hljs-comment">// 检查线程可否被join</span><br>        tt.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>上述代码中，函数 func 和 func1 运行在线程对象 t 和 tt 中，从刚创建对象开始就会新建一个线程用于执行函数，调用 join 函数将会阻塞主线程，直到线程函数执行结束，线程函数的返回值将会被忽略。如果不希望线程被阻塞执行，可以调用线程对象的 detach 函数，表示将线程和线程对象分离。</p><p>如果没有调用 join 或者 detach 函数，假如线程函数执行时间较长，此时线程对象的生命周期结束调用析构函数清理资源，这时可能会发生错误，这里有两种解决办法，一个是调用 join() ，保证线程函数的生命周期和线程对象的生命周期相同，另一个是调用 detach() ，将线程和线程对象分离，这里需要注意，如果线程已经和对象分离，那我们就再也无法控制线程什么时候结束了，不能再通过 join 来等待线程执行完。</p><p>这里可以对 thread 进行封装，避免没有调用 join 或者 detach 可导致程序出错的情况出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGuard</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DesAction</span> &#123;</span> join, detach &#125;;<br><br>   <span class="hljs-built_in">ThreadGuard</span>(std::thread&amp;&amp; t, DesAction a) : <span class="hljs-built_in">t_</span>(std::<span class="hljs-built_in">move</span>(t)), <span class="hljs-built_in">action_</span>(a)&#123;&#125;;<br><br>   ~<span class="hljs-built_in">ThreadGuard</span>() &#123;<br>       <span class="hljs-keyword">if</span> (t_.<span class="hljs-built_in">joinable</span>()) &#123;<br>           <span class="hljs-keyword">if</span> (action_ == DesAction::join) &#123;<br>               t_.<span class="hljs-built_in">join</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>               t_.<span class="hljs-built_in">detach</span>();<br>          &#125;<br>  &#125;<br>  &#125;<br><br>   <span class="hljs-built_in">ThreadGuard</span>(ThreadGuard&amp;&amp;) = <span class="hljs-keyword">default</span>;<br>   ThreadGuard&amp; <span class="hljs-keyword">operator</span>=(ThreadGuard&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>   <span class="hljs-function">std::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t_; &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>   std::thread t_;<br>   DesAction action_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-function">ThreadGuard <span class="hljs-title">t</span><span class="hljs-params">(std::thread([]() &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">           std::cout &lt;&lt; <span class="hljs-string">&quot;thread guard &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">      &#125;</span></span><br><span class="hljs-function"><span class="hljs-params">       std::cout &lt;&lt; std::endl;&#125;), ThreadGuard::DesAction::join)</span></span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">thread</span> guard <span class="hljs-number">0</span> thread guard <span class="hljs-number">1</span> thread guard <span class="hljs-number">2</span> thread guard <span class="hljs-number">3</span> thread guard <span class="hljs-number">4</span> thread guard <span class="hljs-number">5</span> thread guard <span class="hljs-number">6</span> thread guard <span class="hljs-number">7</span> thread guard <span class="hljs-number">8</span> thread guard <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>c++11还提供了获取线程id，或者系统cpu个数，获取thread native_handle，使得线程休眠等功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前线程ID &quot;</span> &lt;&lt; t.<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前cpu个数 &quot;</span> &lt;&lt; std::thread::<span class="hljs-built_in">hardware_concurrency</span>() &lt;&lt; endl;<br><span class="hljs-keyword">auto</span> handle = t.<span class="hljs-built_in">native_handle</span>();<span class="hljs-comment">// handle可用于pthread相关操作</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h2 id="std-mutex相关"><a href="#std-mutex相关" class="headerlink" title="std::mutex相关"></a>std::mutex相关</h2><p>std::mutex是一种线程同步的手段，用于保存多线程同时操作的共享数据。</p><p>mutex分为四种：</p><ul><li>std::mutex：独占的互斥量，不能递归使用，不带超时功能</li><li>std::recursive_mutex：递归互斥量，可重入，不带超时功能</li><li>std::timed_mutex：带超时的互斥量，不能递归</li><li>std::recursive_timed_mutex：带超时的互斥量，可以递归使用</li></ul><p>拿一个std::mutex和std::timed_mutex举例吧，别的都是类似的使用方式：</p><p><strong>std::mutex:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::mutex mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       mutex_.<span class="hljs-built_in">lock</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>       mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">20</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p><strong>std::timed_mutex:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::timed_mutex timed_mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       timed_mutex_.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>       timed_mutex_.<span class="hljs-built_in">unlock</span>();<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">200</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-lock相关"><a href="#std-lock相关" class="headerlink" title="std::lock相关"></a>std::lock相关</h2><p>这里主要介绍两种RAII方式的锁封装，可以动态的释放锁资源，防止线程由于编码失误导致一直持有锁。</p><p>c++11主要有 std::lock_guard 和 std::unique_lock 两种方式，使用方式都类似，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>std::mutex mutex_;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> func1 = [](<span class="hljs-keyword">int</span> k) &#123;<br>       <span class="hljs-comment">// std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span><br>       std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mutex_);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>           cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>       cout &lt;&lt; endl;<br>  &#125;;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(func1, <span class="hljs-number">200</span>);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>std::lock_gurad 相比于 std::unique_lock 更加轻量级，少了一些成员函数，std::unique_lock 类有 unlock 函数，可以手动释放锁，所以条件变量都配合 std::unique_lock 使用，而不是 std::lock_guard，因为条件变量在wait时需要有手动释放锁的能力。</p><h2 id="std-atomic相关"><a href="#std-atomic相关" class="headerlink" title="std::atomic相关"></a>std::atomic相关</h2><p>c++11提供了原子类型std::atomic&lt; T &gt;，理论上这个T可以是任意类型，但是我平时只存放整形，别的还真的没用过，整形有这种原子变量已经足够方便，就<strong>不需要使用 std::mutex 来保护该变量</strong>啦。看一个计数器的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OriginCounter</span> &#123;</span> <span class="hljs-comment">// 普通的计数器</span><br>   <span class="hljs-keyword">int</span> count;<br>   std::mutex mutex_;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       ++count;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       --count;<br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>       <span class="hljs-keyword">return</span> count;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewCounter</span> &#123;</span> <span class="hljs-comment">// 使用原子变量的计数器</span><br>   std::atomic&lt;<span class="hljs-keyword">int</span>&gt; count;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       ++count;<br>       <span class="hljs-comment">// count.store(++count);这种方式也可以</span><br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">()</span> </span>&#123;<br>       --count;<br>       <span class="hljs-comment">// count.store(--count);</span><br>  &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> count.<span class="hljs-built_in">load</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="std-call-once相关"><a href="#std-call-once相关" class="headerlink" title="std::call_once相关"></a>std::call_once相关</h2><p>c++11提供了std::call_once来保证某一函数在多线程环境中只调用一次，它需要配合std::once_flag使用，直接看使用代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>std::once_flag onceflag;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CallOnce</span><span class="hljs-params">()</span> </span>&#123;<br>   std::<span class="hljs-built_in">call_once</span>(onceflag, []() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;call once&quot;</span> &lt;&lt; endl;<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   std::thread threads[<span class="hljs-number">5</span>];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>       threads[i] = std::<span class="hljs-built_in">thread</span>(CallOnce);<br>  &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>       th.<span class="hljs-built_in">join</span>();<br>  &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="volatile相关"><a href="#volatile相关" class="headerlink" title="volatile相关"></a>volatile相关</h2><p>volatile通常用来建立内存屏障，volatile修饰的变量，编译器对访问该变量的代码通常不再进行优化，看下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = xxx;<br><span class="hljs-keyword">int</span> a = *p;<br><span class="hljs-keyword">int</span> b = *p;<br></code></pre></td></tr></table></figure><p>a 和 b 都等于 p 指向的值，一般编译器会对此做优化，把 *p 的值放入<code>寄存器</code>，就是传说中的工作内存(不是主内存)，之后 a 和 b 都等于寄存器的值，但是如果中间 p 地址的值改变，内存上的值改变啦，但 a , b 还是从寄存器中取的值(不一定，看编译器优化结果)，这就不符合需求，所以在此对 p 加 <code>volatile </code>修饰可以避免进行此类优化。</p><blockquote><p><strong>注意：</strong>volatile不能解决多线程安全问题，针对特种内存才需要使用 volatile，它和 atomic 的特点如下：</p></blockquote><p>• std::atomic 用于多线程访问的数据，且不用互斥量，用于并发编程中</p><p>• volatile 用于读写操作不可以被优化掉的内存，用于特种内存中</p><h2 id="std-condition-variable相关"><a href="#std-condition-variable相关" class="headerlink" title="std::condition_variable相关"></a>std::condition_variable相关</h2><p><code>条件变量</code>是c++11引入的一种同步机制，它可以阻塞一个线程或者个线程，直到有线程通知或者超时才会唤醒正在阻塞的线程，条件变量需要和锁配合使用，这里的锁就是上面介绍的 std::unique_lock。</p><p>这里使用条件变量实现一个CountDownLatch（倒计时锁存器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatch</span> &#123;</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> count)</span> : count_(count);</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CountDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        --count_;<br>        <span class="hljs-keyword">if</span> (count_ == <span class="hljs-number">0</span>) &#123;<br>            cv_.<span class="hljs-built_in">notify_all</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Await</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> time_ms = <span class="hljs-number">0</span>)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">while</span> (count_ &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (time_ms &gt; <span class="hljs-number">0</span>) &#123;<br>                cv_.<span class="hljs-built_in">wait_for</span>(lock, std::chrono::<span class="hljs-built_in">milliseconds</span>(time_ms));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cv_.<span class="hljs-built_in">wait</span>(lock);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">GetCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>      <span class="hljs-keyword">return</span> count_;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span>:<br>    std::condition_variable cv_;<br>    <span class="hljs-keyword">mutable</span> std::mutex mutex_;<br>    <span class="hljs-keyword">uint32_t</span> count_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="std-future相关"><a href="#std-future相关" class="headerlink" title="std::future相关"></a>std::future相关</h2><p>c++11关于异步操作提供了 <code>future</code> 相关的类，主要有 std::future、std::promise和std::packaged_task，std::future 比 std::thread 高级些，std::future 作为异步结果的传输通道，通过 get() 可以很方便的获取线程函数的返回值，std::promise 用来包装一个值，将数据和 future 绑定起来，而 std::packaged_task 则用来包装一个调用对象，将函数和 future 绑定起来，方便异步调用。而 std::future 是不可以复制的，如果需要复制放到容器中可以使用std::shared_future。</p><p><strong>std::promise 与 std::future 配合使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::future&lt;<span class="hljs-keyword">int</span>&gt;&amp; fut)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = fut.<span class="hljs-built_in">get</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-keyword">int</span>&gt; prom;<br>    std::future&lt;<span class="hljs-keyword">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func, std::ref(fut))</span></span>;<br>    prom.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">144</span>);<br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">value</span>: <span class="hljs-number">144</span><br></code></pre></td></tr></table></figure><p><strong>std::packaged_task 与 std::future 配合使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> in + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(func)</span></span>;<br>    std::future&lt;<span class="hljs-keyword">int</span>&gt; fut = task.<span class="hljs-built_in">get_future</span>();<br>    std::<span class="hljs-built_in">thread</span>(std::<span class="hljs-built_in">move</span>(task), <span class="hljs-number">5</span>).<span class="hljs-built_in">detach</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;result &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">result</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>三者之间的关系</strong></p><p>std::future 用于访问异步操作的结果，而 std::promise 和 std::packaged_task 在 future 高一层，它们内部都有一个 future，promise 包装的是一个值，packaged_task 包装的是一个函数，当需要获取线程中的某个值，可以使用 std::promise，当需要获取线程函数返回值，可以使用 std::packaged_task。</p><h2 id="async相关"><a href="#async相关" class="headerlink" title="async相关"></a>async相关</h2><p>async 是比 future，packaged_task，promise 更高级的东西，它是基于任务的异步操作，通过 async 可以直接创建异步的任务，返回的结果会保存在 future 中，不需要像 packaged_task 和 promise 那么麻烦，关于线程操作应该优先使用 async，看一段使用代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> in)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> in + <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">async</span>(func, <span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// res.wait();</span><br>    cout &lt;&lt; res.<span class="hljs-built_in">get</span>() &lt;&lt; endl; <span class="hljs-comment">// 阻塞直到函数返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用async异步执行函数是不是方便多啦。</p><p>async具体语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span>(std::launch::<span class="hljs-keyword">async</span> | std::launch::deferred, func, args...);<br></code></pre></td></tr></table></figure><p>第一个参数是创建策略：</p><ul><li>std::launch::async 表示任务执行在另一线程</li><li>std::launch::deferred 表示延迟执行任务，调用 get 或者 wait 时才会执行，不会创建线程，惰性执行在当前线程。 </li></ul><p>如果不明确指定创建策略，以上两个都不是async的默认策略，而是未定义，它是一个基于任务的程序设计，内部有一个调度器(线程池)，会根据实际情况决定采用哪种策略。</p><p>若从 std::async 获得的 std::future 未被移动或绑定到引用，则在完整表达式结尾， std::future 的析构函数将阻塞直至异步计算完成，实际上相当于同步操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">async</span>(std::launch::async, []&#123; <span class="hljs-built_in">f</span>(); &#125;); <span class="hljs-comment">// 临时量的析构函数等待 f()</span><br>std::<span class="hljs-built_in">async</span>(std::launch::async, []&#123; <span class="hljs-built_in">g</span>(); &#125;); <span class="hljs-comment">// f() 完成前不开始</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>std::thread使线程的创建变得非常简单，还可以获取线程id等信息。</li><li>std::mutex通过多种方式保证了线程安全，互斥量可以独占，也可以重入，还可以设置互斥量的超时时间，避免一直阻塞等锁。</li><li>std::lock通过RAII技术方便了加锁和解锁调用，有std::lock_guard和std::unique_lock。</li><li>std::atomic提供了原子变量，更方便实现实现保护，不需要使用互斥量</li><li>std::call_once保证函数在多线程环境下只调用一次，可用于实现单例。</li><li>volatile常用于读写操作不可以被优化掉的内存中。</li><li>std::condition_variable提供等待的同步机制，可阻塞一个或多个线程，等待其它线程通知后唤醒。</li><li>std::future用于异步调用的包装和返回值。</li><li>async更方便的实现了异步调用，异步调用优先使用async取代创建线程。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : c++11新特性之线程相关所有知识点 (<a href="https://mp.weixin.qq.com/s/rPjRTOTYK2SGr6WxgWI_Vg">https://mp.weixin.qq.com/s/rPjRTOTYK2SGr6WxgWI_Vg</a>)</p><p>[ 2 ] : C++11 并发指南系列_章志强的专栏-CSDN博客(<a href="https://blog.csdn.net/zhangzq86/article/details/70623394">https://blog.csdn.net/zhangzq86/article/details/70623394</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;七、线程相关所有知识点&quot;&gt;&lt;a href=&quot;#七、线程相关所有知识点&quot; class=&quot;headerlink&quot; title=&quot;七、线程相关所有知识点&quot;&gt;&lt;/a&gt;七、线程相关所有知识点&lt;/h1&gt;&lt;p&gt;c++11关于并发引入了好多好东西，这里按照如下顺序介绍：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="C++11 新特性" scheme="http://pakchoi007.gitee.io/categories/C-11-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="C++11" scheme="http://pakchoi007.gitee.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 41-45</title>
    <link href="http://pakchoi007.gitee.io/2021/06/22/%E5%89%91%E6%8C%87offer41-45/"/>
    <id>http://pakchoi007.gitee.io/2021/06/22/%E5%89%91%E6%8C%87offer41-45/</id>
    <published>2021-06-22T07:36:00.000Z</published>
    <updated>2021-06-22T09:03:33.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-41-45"><a href="#剑指offer-41-45" class="headerlink" title="剑指offer    41~45"></a>剑指offer    41~45</h1><h2 id="四十一、和为S的连续正数序列"><a href="#四十一、和为S的连续正数序列" class="headerlink" title="四十一、和为S的连续正数序列"></a>四十一、<a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">和为S的连续正数序列</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">9<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><p>一刷：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-keyword">int</span> target) &#123;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;ret;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;vec;<br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i;; j++) &#123;<br>sum += j;<br><span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target) &#123;<br>vec.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++) &#123;<br>vec.<span class="hljs-built_in">push_back</span>(k);<br>&#125;<br>ret.<span class="hljs-built_in">push_back</span>(vec);<br>sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>暴力搜索，从 $1 $ 开始加，一直加到 $target$ 的一半</p><ul><li>若 $&gt;target$ ，$sum = 0$ ，重新从 $2$ 开始加</li><li>若 $=target$ ，把值给 $vec$</li></ul><p><strong>二刷：</strong></p><p><strong>滑动窗口（双指针）</strong></p><blockquote><p>算法流程：</p></blockquote><ol><li>初始化： 左边界 $i = 1$ ，右边界 $j = 2$ ，元素和 $s = 3$ ，结果列表 $res$ ；</li><li>循环： 当 $i \geq j$ 时跳出；<ul><li>当 $s &gt; target$ 时： 向右移动左边界 $i = i + 1$ ，并更新元素和 $s$ ；</li><li>当 $s &lt; target$ 时： 向右移动右边界 $j = j + 1$ ，并更新元素和 $s$ ；</li><li>当 $s = target$ 时： 记录连续整数序列，并向右移动左边界 $i = i + 1$ ；</li></ul></li><li>返回值： 返回结果列表 $res$ ；</li></ol><p><img src="/2021/06/22/%E5%89%91%E6%8C%87offer41-45/1611495306-LsrxgS-Picture2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>, s = <span class="hljs-number">3</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">if</span>(s == sum) &#123;<br>                vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(k);<br>                &#125;<br>                res.<span class="hljs-built_in">push_back</span>(ans);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s &gt;= sum)&#123;<br>                s -= i;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                j++;<br>                s += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四十二、和为S的两个数字"><a href="#四十二、和为S的两个数字" class="headerlink" title="四十二、和为S的两个数字"></a>四十二、<a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">和为S的两个数字</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，返回两个数的乘积最小的，如果无法找出这样的数字，返回一个空数组即可。</p><h3 id="返回值描述：-1"><a href="#返回值描述：-1" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>对应每个测试案例，输出两个数，小的先输出。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,4,7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">11</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = array.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> s = array[i] + array[j];<br>            <span class="hljs-keyword">if</span>(s &gt; sum)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; sum) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;array[i], array[j]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>算法流程：</strong></p><ol><li>初始化： 双指针 $i$ , $j$ 分别指向数组 $nums$ 的左右两端 （俗称对撞双指针）。</li><li>循环搜索： 当双指针相遇时跳出；<ol><li>计算和 $s = nums[i] + nums[j]$ ；</li><li>若 $s &gt; target$ ，则指针 $j$ 向左移动，即执行 $j = j - 1$ ；</li><li>若 $s &lt; target$ ，则指针 ii 向右移动，即执行 $i = i + 1$ ；</li><li>若 $s = target$ ，立即返回数组 $nums[i],nums[j]$ ；</li></ol></li><li>返回空数组，代表无和为 $target$ 的数字组合。</li></ol><h2 id="四十三、左旋转字符串"><a href="#四十三、左旋转字符串" class="headerlink" title="四十三、左旋转字符串"></a>四十三、<a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">左旋转字符串</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出（保证 K 小于等于 S 的长度）。例如，字符序列S=”abcXYZdef”,要求输出循环左移 3 位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl"><span class="hljs-string">&quot;abcXYZdef&quot;</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;XYZdefabc&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">begin</span>() + n);<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>() + n, str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>例如：输入: s = “abcdefg”, k = 2</p><ol><li>“abcdefg” 反转前2个字符 “bacdefg”</li><li>“bacdefg” 反转后5个字符 “bagfedc”</li><li>“bagfedc” 反转整个字符串 “cdefgab”</li></ol><h2 id="四十四、翻转单词序列"><a href="#四十四、翻转单词序列" class="headerlink" title="四十四、翻转单词序列"></a>四十四、<a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">翻转单词序列</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;nowcoder. <span class="hljs-selector-tag">a</span> am <span class="hljs-selector-tag">I</span>&quot;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">I</span> am <span class="hljs-selector-tag">a</span> nowcoder.&quot;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">//删除最前面的空格</span><br><span class="hljs-keyword">while</span> (str.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>());<br>&#125;<br><span class="hljs-comment">//删除最后面的空格</span><br><span class="hljs-keyword">while</span> (str.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; str[str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">begin</span>() + str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br>        <span class="hljs-keyword">int</span> j = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, i = j;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; str[i] != <span class="hljs-string">&#x27; &#x27;</span>) i--;<br>            res = res + str.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - i) + <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) i--;<br>            j = i;<br>        &#125;<br>        res.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//去除最后多加的一个空格</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>双指针</strong></p><p>加了首尾若有空格的情况</p><p>算法解析：</p><ul><li>倒序遍历字符串 $s$ ，记录单词左右索引边界 $i$ , $j$ ；</li><li>每确定一个单词的边界，则将其添加至单词列表 $res$ ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><h2 id="四十五、扑克牌顺子"><a href="#四十五、扑克牌顺子" class="headerlink" title="四十五、扑克牌顺子"></a>四十五、<a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">扑克牌顺子</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。<br>有如下规则：</p><ol><li>A为1，J为11，Q为12，K为13，A不能视为14</li><li>大、小王为 0，0可以看作任意牌</li><li>如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。</li></ol><p>例如：给出数据[6,0,2,0,4]</p><p>中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]</p><p>这样这五张牌在[2,6]区间连续，输出true</p><p>数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">13</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-keyword">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> joker = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[i] == <span class="hljs-number">0</span>) joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[i] == numbers[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">4</span>] - numbers[joker] &lt; <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>根据题意，此 5 张牌是顺子的 <strong>充分条件</strong> 如下：</p><ol><li>除大小王外，所有牌 <strong>无重复</strong> ；</li><li>设此 5 张牌中最大的牌为 $max$ ，最小的牌为 $min$ （大小王除外），则需满足：$max - min &lt; 5$</li></ol><p><strong>排序 + 遍历</strong></p><ul><li>先对数组执行排序。</li><li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 $nums[i] = nums[i + 1]$ 是否成立来判重。</li><li>获取最大 / 最小的牌： 排序后，数组末位元素 $nums[4]$ 为最大牌；元素 $nums[joker]$ 为最小牌，其中 $joker$ 为大小王的数量。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-41-45&quot;&gt;&lt;a href=&quot;#剑指offer-41-45&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    41~45&quot;&gt;&lt;/a&gt;剑指offer    41~45&lt;/h1&gt;&lt;h2 id=&quot;四十一、和为S的连续正数序列&quot;</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 36-40</title>
    <link href="http://pakchoi007.gitee.io/2021/06/21/%E5%89%91%E6%8C%87offer36-40/"/>
    <id>http://pakchoi007.gitee.io/2021/06/21/%E5%89%91%E6%8C%87offer36-40/</id>
    <published>2021-06-21T05:50:10.000Z</published>
    <updated>2021-06-21T08:15:43.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-36-40"><a href="#剑指offer-36-40" class="headerlink" title="剑指offer    36~40"></a>剑指offer    36~40</h1><h2 id="三十六、两个链表的第一个公共结点"><a href="#三十六、两个链表的第一个公共结点" class="headerlink" title="三十六、两个链表的第一个公共结点"></a>三十六、<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">两个链表的第一个公共结点</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,2,3&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;4,5&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;6,7&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">第一个参数</span><span class="hljs-template-variable">&#123;1,2,3&#125;</span><span class="xml">代表是第一个链表非公共部分，第二个参数</span><span class="hljs-template-variable">&#123;4,5&#125;</span><span class="xml">代表是第二个链表非公共部分，最后的</span><span class="hljs-template-variable">&#123;6,7&#125;</span><span class="xml">表示的是2个链表的公共部分</span><br><span class="xml">这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的    </span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2,3&#125;</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span>个链表没有公共节点 ,返回<span class="hljs-literal">null</span>，后台打印&#123;&#125; <br></code></pre></td></tr></table></figure><p><strong>一刷写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        ListNode* p = pHead1;<br>        ListNode* q = pHead2;<br>        <span class="hljs-keyword">int</span> size1 = <span class="hljs-number">0</span>, size2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>) &#123;<br>            size1++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>) &#123;<br>            size2++;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(size1 - size2);<br>        <span class="hljs-keyword">if</span>(size1 &gt; size2)&#123;<br>            p = pHead1;<br>            q = pHead2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p = pHead2;<br>            q = pHead1;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num)&#123;<br>            p = p-&gt;next;<br>            num--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p == q) <span class="hljs-keyword">return</span> p;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><ol><li>先计算两个链表的长度 $size1$，$size2$</li><li>根据长度差使头指针 $p$，$q$ 在同一起跑线</li><li> $p$，$q$ 同时后移，相等时即为公共节点</li></ol><p><strong>二刷思路：</strong></p><p>设「第一个公共节点」为 <code>node</code> ，「链表 <code>pHead1</code>」的节点数量为 $a$ ，「链表 <code>pHead2</code>」的节点数量为 $b$ ，「两链表的公共尾部」的节点数量为 $ c$ ，则有：</p><ul><li>头节点 <code>pHead1</code> 到 <code>node</code> 前，共有 $a - c$ 个节点；</li><li>头节点 <code>pHead2</code> 到 <code>node</code> 前，共有 $b - c$ 个节点；</li></ul><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/1615224578-EBRtwv-Picture1.png"></p><p>考虑构建两个节点指针 <code>A</code> , <code>B</code> 分别指向两链表头节点 <code>pHead1</code> , <code>pHead2</code> ，做如下操作：</p><ul><li>指针 <code>A</code> 先遍历完链表 <code>pHead1</code> ，再开始遍历链表 <code>pHead2</code> ，当走到 <code>node</code> 时，共走步数为：$a+(b−c)$</li><li>指针 <code>B</code> 先遍历完链表 <code>pHead2</code> ，再开始遍历链表 <code>pHead1</code> ，当走到 <code>node</code> 时，共走步数为：$b + (a - c)$</li></ul><p>此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：$a + (b - c) = b + (a - c)$</p><ol><li><p>若两链表 <strong>有</strong> 公共尾部 (即 $c &gt; 0$ ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</p></li><li><p>若两链表 <strong>无</strong> 公共尾部 (即 $c = 0$ ) ：指针 <code>A</code> , <code>B</code> 同时指向 $nullptr$ 。</p></li></ol><p>因此返回 <code>A</code> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        ListNode *A = pHead1, *B = pHead2;<br>        <span class="hljs-keyword">while</span> (A != B) &#123;<br>            A = A != <span class="hljs-literal">nullptr</span> ? A-&gt;next : pHead2;<br>            B = B != <span class="hljs-literal">nullptr</span> ? B-&gt;next : pHead1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三十七、数字在升序数组中出现的次数"><a href="#三十七、数字在升序数组中出现的次数" class="headerlink" title="三十七、数字在升序数组中出现的次数"></a>三十七、<a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数字在升序数组中出现的次数</a></h2><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>统计一个数字在升序数组中出现的次数。</p><h2 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,3,3</span>,<span class="hljs-number">3,3,4,5</span>],<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(data[left] &lt; k &amp;&amp; left &lt; data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)left++;<br>        <span class="hljs-keyword">while</span>(data[right] &gt; k &amp;&amp; right &gt; <span class="hljs-number">0</span>)right--;<br>        <span class="hljs-keyword">if</span>(left == right)<span class="hljs-keyword">return</span> data[left] == k;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &lt; right)<span class="hljs-keyword">return</span> right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>定义左指针 $left$ ，右指针 $right$</p><p>向内收缩判断出现次数</p><p>注意当 $left == right$ 时，可能存在<code>目标元素</code>不存在数组里的情况，此时要判断指针所指的元素是否等于<code>目标元素</code></p><p><strong>二分法：</strong></p><p>当题目为排序数组时，首先应该想到二分法！</p><p>本题要求统计数字 $target$ 的出现次数，可转化为：使用二分法分别找到 左边界 $left$ 和 右边界 $right$ ，易得数字 $target$ 的数量为 $right - left - 1$ 。</p><blockquote><p>算法解析：</p></blockquote><ol><li>初始化： 左边界 $i = 0$ ，右边界 $j = nums.size() - 1$ 。</li><li>循环二分： 当闭区间 [i, j][i,j] 无元素时跳出；<ol><li>计算中点 $m = (i + j) /2$ （向下取整）；</li><li>若 $nums[m] &lt; target$ ，则 $target$ 在闭区间 [m + 1, j] 中，因此执行 $i = m + 1$；</li><li>若 $nums[m] &gt; target$ ，则 $target$ 在闭区间 [i, m - 1] 中，因此执行 $j = m - 1$ ;</li><li>若 $nums[m] = target$ ，则右边界 $right$ 在闭区间 [m+1, j] 中；左边界 $left$ 在闭区间 [i, m-1] 中。因此分为以下两种情况：<ol><li>若查找 右边界 $right$ ，则执行 $i = m + 1$ ；（跳出时 $i$ 指向右边界）</li><li>若查找 左边界 $left$ ，则执行 $j = m - 1$ ；（跳出时 $j$ 指向左边界）</li></ol></li></ol></li><li>返回值： 应用两次二分，分别查找 $right$ 和 $left$ ，最终返回 $right - left - 1$ 即可。</li></ol><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/b4521d9ba346cad9e382017d1abd1db2304b4521d4f2d839c32d0ecff17a9c0d-Picture1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data ,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m] &lt;= k) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> right = i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; data[j] != k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 搜索左边界 right</span><br>        i = <span class="hljs-number">0</span>, j = data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m] &lt; k) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = j;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="三十八、二叉树的深度"><a href="#三十八、二叉树的深度" class="headerlink" title="三十八、二叉树的深度"></a>三十八、<a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的深度</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,#,<span class="hljs-number">6</span>,#,#,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1</p><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png"></p><p><strong>算法解析：</strong></p><ol><li>终止条件： 当 root 为空，说明已越过叶节点，因此返回 深度 0 。</li><li>递推工作： 本质上是对树做后序遍历。<ol><li>计算节点 root 的 左子树的深度 ，即调用 maxDepth(root.left)；</li><li>计算节点 root 的 右子树的深度 ，即调用 maxDepth(root.right)；</li></ol></li><li>返回值： 返回 此树的深度 ，即 max(maxDepth(root.left), maxDepth(root.right)) + 1。</li></ol><h2 id="三十九、平衡二叉树"><a href="#三十九、平衡二叉树" class="headerlink" title="三十九、平衡二叉树"></a>三十九、<a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">平衡二叉树</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p><p><strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>注：我们约定空树是平衡二叉树。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);<br><span class="hljs-keyword">if</span> (leftdepth == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);<br><span class="hljs-keyword">if</span> (rightdepth == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftdepth - rightdepth) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(pRoot) != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则“剪枝”，直接向上返回。</p><p><strong>算法流程：</strong></p><p><strong>getdepth(root) 函数：</strong></p><ul><li><p>返回值：</p><ol><li><p>当节点 <code>root</code> 左 / 右子树的深度差 $\leq 1$ ：则返回当前子树的深度，即节点 <code>root</code> 的左 / 右子树的深度最大值 $+1$ （ <code>max(left, right) + 1</code> ）；</p></li><li><p>当节点<code>root</code> 左 / 右子树的深度差 $&gt; 2$ ：则返回 $-1$ ，代表 <strong>此子树不是平衡树</strong> 。</p></li></ol></li><li><p>终止条件：</p><ol><li><p>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 $0$ ；</p></li><li><p>当左（右）子树深度为 $-1$ ：代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 $-1$ ；</p></li></ol></li></ul><p><strong>IsBalanced_Solution(root) 函数：</strong></p><p>返回值： 若 <code>getdepth(root) != -1</code> ，则说明此树平衡，返回 $true$ ； 否则返回 $false$ 。</p><h2 id="四十、数组中只出现一次的两个数字"><a href="#四十、数组中只出现一次的两个数字" class="headerlink" title="四十、数组中只出现一次的两个数字"></a>四十、<a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中只出现一次的两个数字</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>说明：</p><p>返回的结果中较小的数排在前面 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;map;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;ret;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>map[array[i]]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : map) &#123;<br><span class="hljs-keyword">if</span> (m.second == <span class="hljs-number">1</span>)ret.<span class="hljs-built_in">push_back</span>(m.first);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>常规做法：<strong>哈希表</strong></p><p>创建哈希表计算元素个数，再遍历哈希表找出个数为1的元素</p><p>方法二：<strong>位运算</strong></p><p><strong>算法流程：</strong></p><ol><li><p><strong>遍历 $nums$ 执行异或：</strong></p><ul><li>设整型数组 $nums = [a, a, b, b, …, x, y]$ ，对 $nums$ 中所有数字执行异或，得到的结果为 $ x \oplus y$ ，即：<br>$\begin{aligned} &amp; \ \ a \oplus a \oplus b \oplus b \oplus … \oplus x \oplus y \ = &amp; \ \ 0 \oplus 0 \oplus … \oplus x \oplus y \ = &amp; \ \ x \oplus y \end{aligned}$</li></ul></li><li><p><strong>循环左移计算 $m$ ：</strong></p></li></ol><ul><li>根据异或运算定义，若整数 $x \oplus y$ 某二进制位为 $1$ ，则 $x$ 和 $y$ 的此二进制位一定不同。换言之，找到 $x \oplus y$ 某为 $1$ 的二进制位，即可将数组 $nums$ 拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 $a$ 有：<ul><li><p>若 a &amp; 0001 = 1 ，则 $a$ 的第一位为 $1$ ；</p></li><li><p>若 a &amp; 0010 = 1 ，则 $a$ 的第二位为 $1$ ；</p></li><li><p>以此类推……</p></li></ul></li><li>因此，初始化一个辅助变量 $m = 1$ ，通过与运算从右向左循环判断，可获取整数 $x \oplus y$ 首位 $1$ ，记录于 $m$中</li></ul><ol start="3"><li><strong>拆分 $nums$ 为两个子数组：</strong></li><li><strong>分别遍历两个子数组执行异或：</strong><ul><li>通过遍历判断 $nums$ 中各数字和 $m$ 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字</li></ul></li><li><strong>返回值</strong>：<ul><li>返回只出现一次的数字 x, y 即可。</li></ul></li></ol><blockquote><p>设 nums = [3, 3, 4, 4, 1, 6] ，以上计算流程如下图所示。</p></blockquote><p><img src="/2021/06/21/%E5%89%91%E6%8C%87offer36-40/1614836837-oygHyk-Picture2.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : array)         <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) == <span class="hljs-number">0</span>)         <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : array) &#123;       <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>(num &amp; m) x ^= num;   <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;          <span class="hljs-comment">// 4. 当 num &amp; m == 0</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(x &lt; y)<span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;x, y&#125;;<span class="hljs-comment">// 5. 返回出现一次的数字</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;y, x&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-36-40&quot;&gt;&lt;a href=&quot;#剑指offer-36-40&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    36~40&quot;&gt;&lt;/a&gt;剑指offer    36~40&lt;/h1&gt;&lt;h2 id=&quot;三十六、两个链表的第一个公共结</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>排序总结</title>
    <link href="http://pakchoi007.gitee.io/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://pakchoi007.gitee.io/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-18T10:14:21.000Z</published>
    <updated>2021-06-18T10:04:49.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h1><p><img src="/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png"></p><p>1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p><p>2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序</p><p>3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p><p>4、非原地排序：需要利用额外的数组来辅助排序。</p><p>5、时间复杂度：一个算法执行所消耗的时间。</p><p>6、空间复杂度：运行完一个算法所需的内存大小</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序总结&quot;&gt;&lt;a href=&quot;#排序总结&quot; class=&quot;headerlink&quot; title=&quot;排序总结&quot;&gt;&lt;/a&gt;排序总结&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/06/18/11_%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</summary>
      
    
    
    
    <category term="基础算法" scheme="http://pakchoi007.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://pakchoi007.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="http://pakchoi007.gitee.io/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://pakchoi007.gitee.io/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-18T09:43:51.000Z</published>
    <updated>2021-06-18T10:01:57.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。</p><p><strong>算法思想</strong>：</p><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ol><p><img src="/2021/06/18/10_%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/640"></p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>; <span class="hljs-comment">//保存最大的位数</span><br>        <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= p)<br>            &#123;<br>                p *= <span class="hljs-number">10</span>;<br>                d++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">maxbit</span>(nums, n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> j, k;<br>        <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//进行d次排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= d; i++) &#123;<br>            <span class="hljs-comment">//每次分配前清空计数器</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                count[j] = <span class="hljs-number">0</span>; <br>            <span class="hljs-comment">//统计每个桶中的记录数</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                k = (nums[j] / radix) % <span class="hljs-number">10</span>; <br>                count[k]++;<br>            &#125;<br>            <span class="hljs-comment">//将tmp中的位置依次分配给每个桶,类似于计数排序</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                count[j] += count[j - <span class="hljs-number">1</span>]; <br>            <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>            <span class="hljs-keyword">for</span> (j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <br>            &#123;<br>                k = (nums[j] / radix) % <span class="hljs-number">10</span>;<br>                tmp[count[k] - <span class="hljs-number">1</span>] = nums[j];<br>                count[k]--;<br>            &#125;<br>            <span class="hljs-comment">//将临时数组的内容复制到nums中</span><br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++) <br>                nums[j] = tmp[j];<br>            radix = radix * <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">radixsort</span>(nums, nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h1&gt;&lt;p&gt;一种多关键字的排序算法，可用桶排序实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;l</summary>
      
    
    
    
    <category term="基础算法" scheme="http://pakchoi007.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://pakchoi007.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="http://pakchoi007.gitee.io/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://pakchoi007.gitee.io/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-18T09:10:51.000Z</published>
    <updated>2021-06-18T09:33:34.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序可以说是<strong>插入排序的一种变种</strong>。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p><p>希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。</p><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p><img src="/2021/06/18/9_%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/111111.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellinsertsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> gap, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><span class="hljs-keyword">int</span> inserted = nums[i];<br><span class="hljs-keyword">int</span> j = i - gap;<br><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; inserted &lt; nums[j]) &#123;<br>nums[j + gap] = nums[j];<br>j -= gap;<br>&#125;<br>nums[j + gap] = inserted;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shellsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//进行分组，最开始的时候，gap为数组长度一半</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; n; i++) &#123;<br><span class="hljs-built_in">shellinsertsort</span>(nums, gap, i);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums)</span> </span>&#123;<br><span class="hljs-built_in">shellsort</span>(nums);<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h1&gt;&lt;p&gt;希尔排序可以说是&lt;strong&gt;插入排序的一种变种&lt;/strong&gt;。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第</summary>
      
    
    
    
    <category term="基础算法" scheme="http://pakchoi007.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://pakchoi007.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://pakchoi007.gitee.io/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://pakchoi007.gitee.io/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-18T08:25:51.000Z</published>
    <updated>2021-06-18T08:56:54.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序统计小于等于该元素值的元素的个数 $i$ ，于是该元素就放在目标数组的索引 $i$ 位（ $i≥0$ ）。</p><ul><li>计数排序基于一个假设，待排序数列的所有数均为<code>整数</code>，且出现在（0，k）的区间之内。</li><li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来<code>排序 0 到 100 之间的数字</code>的最好的算法，但是它不适合按字母顺序排序人名。</li><li>计数排序不是比较排序，<strong>排序的速度快于任何比较排序算法</strong>。</li></ul><p><strong>算法思想</strong>：</p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li><li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li></ol><p><img src="/2021/06/18/8_%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">countsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//使用nums的最大值 +1 作为计数容器countvec的大小</span><br><span class="hljs-keyword">int</span> vecSize = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">countvec</span>(vecSize, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//计算每个键值出现的次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>countvec[nums[i]]++;<br>&#125;<br><span class="hljs-comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; vecSize; i++) &#123;<br>countvec[i] += countvec[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//将键值放到目标位置</span><br><span class="hljs-comment">//此处逆序是为了保持相同键值的稳定性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>res[--countvec[nums[i]]] = nums[i];<br>&#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;nums)</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">res</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">countsort</span>(nums, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计数排序&quot;&gt;&lt;a href=&quot;#计数排序&quot; class=&quot;headerlink&quot; title=&quot;计数排序&quot;&gt;&lt;/a&gt;计数排序&lt;/h1&gt;&lt;p&gt;计数排序统计小于等于该元素值的元素的个数 $i$ ，于是该元素就放在目标数组的索引 $i$ 位（ $i≥0$ ）。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="基础算法" scheme="http://pakchoi007.gitee.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://pakchoi007.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 31-35</title>
    <link href="http://pakchoi007.gitee.io/2021/06/17/%E5%89%91%E6%8C%87offer31-35/"/>
    <id>http://pakchoi007.gitee.io/2021/06/17/%E5%89%91%E6%8C%87offer31-35/</id>
    <published>2021-06-17T06:00:10.000Z</published>
    <updated>2021-06-17T08:13:29.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-31-35"><a href="#剑指offer-31-35" class="headerlink" title="剑指offer    31~35"></a>剑指offer    31~35</h1><h2 id="三十一、整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#三十一、整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="三十一、整数中1出现的次数（从1到n整数中1出现的次数）"></a>三十一、<a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">整数中1出现的次数（从1到n整数中1出现的次数）</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数<br>例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">13<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">6<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> digit = <span class="hljs-number">1</span>, ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> high = n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) ret += high * digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>) ret += high * digit + low + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> ret += high * digit + digit;<br>            low += cur * digit;<br>            cur = high % <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>将 1 ~ $n$ 的个位、十位、百位、…的 $1 $ 出现次数相加，即为 $1$ 出现的总次数。</p><p>设数字 $n$ 是个 $x$ 位数，记 $n$ 的第 $ i$ 位为 $n_i$ ，则可将 $n$ 写为 $n_{x} n_{x-1} \cdots n_{2} n_{1}$ ：</p><ul><li>称 “  $n_i$ “ 为当前位 ，记为 $cur$ ，</li><li>将 “ $n_{i-1} n_{i-2} \cdots n_{2} n_{1}$” 称为低位 ，记为 $low$ ；</li><li>将 “ $n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}$” 称为高位 ，记为 $high$ 。</li><li>将 $10^i$ 称为位因子 ，记为 $digit$ 。</li></ul><p><strong>某位中 11 出现次数的计算方法：</strong></p><p>根据当前位 $cur$ 值的不同，分为以下三种情况：</p><ol><li><p>当 $cur = 0$ 时： 此位 $1$ 的出现次数只由高位 $high$ 决定，计算公式为：$high \times digit$</p><p>如下图所示，以 $n = 2304$ 为例，求 $digit = 10$（即十位）的 $1$ 出现次数。</p></li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture1.png"></p><ol start="2"><li><p>当 $cur = 1$ 时： 此位 $1$ 的出现次数由高位 $high$ 和低位 $low$ 决定，计算公式为：$high \times digit + low + 1$ </p><p>如下图所示，以 $n = 2314$ 为例，求 $digit = 10$ （即十位）的 $1$ 出现次数。</p></li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture2.png"></p><ol start="3"><li>当 $cur = 2, 3, \cdots, 9$ 时： 此位 $1$ 的出现次数只由高位 $high$ 决定，计算公式为：$(high + 1) \times digit$<br>如下图所示，以 $n = 2324$ 为例，求 $digit = 10$ （即十位）的 $1$ 出现次数。</li></ol><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture3.png"></p><h2 id="三十二、把数组排成最小的数"><a href="#三十二、把数组排成最小的数" class="headerlink" title="三十二、把数组排成最小的数"></a>三十二、<a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">把数组排成最小的数</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">32</span>,<span class="hljs-number">321</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;321323&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; x, <span class="hljs-keyword">const</span> string&amp; y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y &lt; y + x;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        vector&lt;string&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : numbers) &#123;<br>            str.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(x));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), cmp);<br>        string ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : str) &#123;<br>            ret += s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 $numbers$ 中任意两数字的字符串为 $x$ 和 $y$ ，则规定 排序判断规则为：</p><ul><li><p>若拼接字符串 $x + y &gt; y + x$ ，则 $x$ “大于” $y$ ；</p></li><li><p>反之，若 $x + y &lt; y + x$ ，则 $x$ “小于” $y$ ；</p></li></ul><p>$x $ “小于” $y$ 代表：排序完成后，数组中 $x$ 应在 $y$ 左边；“大于” 则反之。</p><p>根据以上规则，套用任何排序方法对 $numbers$ 执行排序即可。</p><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture4.png"></p><h2 id="三十三、丑树"><a href="#三十三、丑树" class="headerlink" title="三十三、丑树"></a>三十三、<a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">丑树</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">8<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(index + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">1</span>, p3 = <span class="hljs-number">1</span>, p5 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= index; i++)&#123;<br>            <span class="hljs-keyword">int</span> num2 = dp[p2] * <span class="hljs-number">2</span>, num3 = dp[p3] * <span class="hljs-number">3</span>, num5 = dp[p5] * <span class="hljs-number">5</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(num2, num3), num5);<br>            <span class="hljs-keyword">if</span>(dp[i] == num2) p2++;<br>            <span class="hljs-keyword">if</span>(dp[i] == num3) p3++;<br>            <span class="hljs-keyword">if</span>(dp[i] == num5) p5++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>定义数组 $\textit{dp}$，其中 $\textit{dp}[i]$ 表示第 $i$ 个丑数，第 $n$ 个丑数即为 $\textit{dp}[n]$ 。</p><p>由于最小的丑数是 $1$，因此 $\textit{dp}[1]=1$ 。</p><p>如何得到其余的丑数呢？定义三个指针 $p_2$,$p_3$,$p_5$，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。初始时，三个指针的值都是 $1$ 。</p><p>当 $2 \le i \le n$ 时，令 $\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)$，然后分别比较 $\textit{dp}[i]$ 和 $\textit{dp}[p_2],\textit{dp}[p_3],\textit{dp}[p_5]$是否相等，如果相等则将对应的指针加 $1$。</p><h2 id="三十四、第一个只出现一次的字符"><a href="#三十四、第一个只出现一次的字符" class="headerlink" title="三十四、第一个只出现一次的字符"></a>三十四、<a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">第一个只出现一次的字符</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;google&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            mp[str[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[str[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>使用哈希表存储频数</strong></p><p>我们可以对字符串进行两次遍历。</p><p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。</p><p>在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符索引，否则在遍历结束后返回 $-1$ 。</p><h2 id="☆☆☆三十五、数组中的逆序对"><a href="#☆☆☆三十五、数组中的逆序对" class="headerlink" title="☆☆☆三十五、数组中的逆序对"></a>☆☆☆三十五、<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数组中的逆序对</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出 P % 1000000007</p><p>对于50%的数据, $size\leq 10^4$<br>对于100%的数据, $size\leq 10^5$</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>题目保证输入的数组中没有的相同的数字</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">7<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; data, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; tmp)</span> </span>&#123;<br>        <span class="hljs-comment">//终止条件</span><br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//递归划分</span><br>        <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">mergeSort</span>(l, mid, data, tmp);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">mergeSort</span>(mid + <span class="hljs-number">1</span>, r, data, tmp);<br>        <span class="hljs-comment">//合并阶段</span><br>        <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++)<br>            tmp[k] = data[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)<br>                data[k] = tmp[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == r + <span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j])<br>                data[k] = tmp[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                data[k] = tmp[j++];<br>                res = (res + (mid - i + <span class="hljs-number">1</span>)) % <span class="hljs-number">1000000007</span>; <span class="hljs-comment">// 统计逆序对</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (res + left + right) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(data.size())</span></span>;<br>        ret = <span class="hljs-built_in">mergeSort</span>(<span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, data, tmp);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>「归并排序」与「逆序对」是息息相关的</strong></p><p><strong>merge_sort( ) 归并排序与逆序对统计：</strong></p><ol><li>终止条件： 当 $l \geq r$ 时，代表子数组长度为 1 ，此时终止划分；</li><li>递归划分： 计算数组中点 $m$ ，递归划分左子数组 <code>merge_sort(l, m)</code> 和右子数组 <code>merge_sort(m + 1, r)</code> ；</li><li>合并与逆序对统计：<ol><li>暂存数组 $nums$ 闭区间 [i, r]内的元素至辅助数组 $tmp$ ；</li><li>循环合并： 设置双指针 $i$ , $j$ 分别指向左 / 右子数组的首元素；<ul><li>当 $i = m + 1$ 时： 代表左子数组已合并完，因此添加右子数组当前元素 $tmp[j]$ ，并执行 $j = j + 1$ ；</li><li>否则，当 $j=r+1$ 时： 代表右子数组已合并完，因此添加左子数组当前元素 $tmp[i]$ ，并执行 $i=i+1$ ；</li><li>否则，当 $tmp[i] \leq tmp[j]$ 时： 添加左子数组当前元素 $tmp[i]$ ，并执行 $i = i + 1$；</li><li>否则（即 $tmp[i] &gt; tmp[j]$）时： 添加右子数组当前元素 $tmp[j]$ ，并执行 $j = j + 1$ ；此时构成 $m−i+1$ 个「逆序对」，统计添加至 $res$ ；</li></ul></li></ol></li><li>返回值： 返回直至目前的逆序对总数 $res$ ；</li></ol><p><strong>InversePairs() 主函数：</strong></p><ol><li>初始化： 辅助数组 $tmp$ ，用于合并阶段暂存元素；</li><li>返回值： 执行归并排序 merge_sort() ，并返回逆序对总数即可；</li></ol><p>如下图所示，为数组 [7, 3, 2, 6, 0, 1, 5, 4] 的归并排序与逆序对统计过程。</p><p><img src="/2021/06/17/%E5%89%91%E6%8C%87offer31-35/Picture5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-31-35&quot;&gt;&lt;a href=&quot;#剑指offer-31-35&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    31~35&quot;&gt;&lt;/a&gt;剑指offer    31~35&lt;/h1&gt;&lt;h2 id=&quot;三十一、整数中1出现的次数（从</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 26-30</title>
    <link href="http://pakchoi007.gitee.io/2021/06/16/%E5%89%91%E6%8C%87offer26-30/"/>
    <id>http://pakchoi007.gitee.io/2021/06/16/%E5%89%91%E6%8C%87offer26-30/</id>
    <published>2021-06-16T07:02:10.000Z</published>
    <updated>2021-06-17T03:47:47.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-26-30"><a href="#剑指offer-26-30" class="headerlink" title="剑指offer    26~30"></a>剑指offer    26~30</h1><h2 id="☆二十六、二叉搜索树与双向链表"><a href="#☆二十六、二叉搜索树与双向链表" class="headerlink" title="☆二十六、二叉搜索树与双向链表"></a>☆二十六、<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树与双向链表</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p><p><img src="/2021/06/16/%E5%89%91%E6%8C%87offer26-30/1.jpg"></p><p>注意:</p><ol><li>要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继</li><li>返回链表中的第一个节点的指针</li><li>函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构</li><li>你不用输出或者处理，示例中输出里面的英文，比如”From left to right are:”这样的，程序会根据你的返回值自动打印输出</li></ol><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">From</span> left to right are:<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>;From right to left are:<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        vector&lt;TreeNode*&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (pRootOfTree != <span class="hljs-literal">nullptr</span>) st.<span class="hljs-built_in">push</span>(pRootOfTree);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            result[i + <span class="hljs-number">1</span>]-&gt;left = result[i];<br>            result[i]-&gt;right = result[i + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>采用<strong>代码随想录</strong>中<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484687&idx=1&sn=85cd297b3c9927467e4048b1f50aa938&scene=21#wechat_redirect">二叉树遍历模板</a>，将二叉搜索树中序遍历后，这样在数组中节点就按顺序保存了，然后再来修改指针。</p><h2 id="二十七、字符串的排列"><a href="#二十七、字符串的排列" class="headerlink" title="二十七、字符串的排列"></a>二十七、<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">字符串的排列</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;ab&quot;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    string cur;<br>    vector&lt;string&gt;res;<br>    set&lt;string&gt;store;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string&amp; str,vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>())&#123;<br>            store.<span class="hljs-built_in">insert</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            cur += str[i];<br>            <span class="hljs-built_in">backtracking</span>(str, used);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt;<span class="hljs-built_in">used</span>(str.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtracking</span>(str, used);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : store) res.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>采用<code>回溯</code>的方法</p><p>因为要按字典序输出，先把结果存在<code>set容器</code>中，再从set中取到vector</p><p>用一个used判断字符是否使用</p><h2 id="二十八、数组中出现次数超过一半的数字"><a href="#二十八、数组中出现次数超过一半的数字" class="headerlink" title="二十八、数组中出现次数超过一半的数字"></a>二十八、<a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中出现次数超过一半的数字</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1&lt;=数组长度&lt;=50000</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> numbers[numbers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>先给数组排序，返回数组中位数就是数组中出现次数超过一半的数字</p><p><strong>方法二：哈希表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; numbers)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;mp;<br>        <span class="hljs-keyword">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : numbers) &#123;<br>            mp[x]++;<br>            <span class="hljs-keyword">if</span> (mp[x] &gt; n / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二十九、最小的K个数"><a href="#二十九、最小的K个数" class="headerlink" title="二十九、最小的K个数"></a>二十九、<a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">最小的K个数</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">4,5,1,6</span>,<span class="hljs-number">2,7,3,8</span>],<span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt; k) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : input) &#123;<br>            q.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>构造一个小顶堆的优先队列priority_queue&lt;int, vector&lt; int &gt;, greater&lt; int &gt;&gt; q</p><p>一般遇到最小或最大的K个数优先想到使用优先队列</p><h2 id="三十、连续子数组的最大和"><a href="#三十、连续子数组的最大和" class="headerlink" title="三十、连续子数组的最大和"></a>三十、<a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">连续子数组的最大和</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-5</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">18<br></code></pre></td></tr></table></figure><p>说明：输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4,7,2}，因此输出为该子数组的和 18。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(array.<span class="hljs-built_in">size</span>());<br>        dp[<span class="hljs-number">0</span>] = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + array[i], array[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>动态规划解析：</strong></p><ul><li><p>状态定义： 设动态规划列表 $dp$ ，$dp[i]$ 代表以元素 $array[i]$ 为结尾的连续子数组最大和。</p><ul><li>为何定义最大和 $dp[i]$ 中必须包含元素 $array[i]$ ：保证 $dp[i]$ 递推到 $dp[i+1]$ 的正确性；如果不包含 $array[i]$ ，递推时则不满足题目的 连续子数组 要求。</li></ul></li><li><p>转移方程： 若 $dp[i-1] \leq 0$ ，说明 $dp[i - 1]$ 对 $dp[i]$ 产生负贡献，即 $dp[i-1] + array[i]$] 还不如 $array[i]$ 本身大。</p><ul><li>当 $dp[i - 1] &gt; 0$ 时：执行 $dp[i] = dp[i-1] + array[i]$ ；</li><li>当 $dp[i - 1] \leq 0$ 时：执行 $dp[i] = array[i]$ ；</li></ul></li><li><p>初始状态： $dp[0] = array[0]$，即以 $array[0]$ 结尾的连续子数组最大和为 $array[0]$ 。</p></li><li><p>返回值： 返回 $dp$ 列表中的最大值，代表全局最大值。</p></li></ul><p><img src="/2021/06/16/%E5%89%91%E6%8C%87offer26-30/2.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-26-30&quot;&gt;&lt;a href=&quot;#剑指offer-26-30&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    26~30&quot;&gt;&lt;/a&gt;剑指offer    26~30&lt;/h1&gt;&lt;h2 id=&quot;☆二十六、二叉搜索树与双向链表</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>C++11 智能指针</title>
    <link href="http://pakchoi007.gitee.io/2021/06/15/c++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://pakchoi007.gitee.io/2021/06/15/c++11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2021-06-15T11:39:19.000Z</published>
    <updated>2021-06-15T13:06:21.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、智能指针"><a href="#六、智能指针" class="headerlink" title="六、智能指针"></a>六、智能指针</h1><p>c++的<code>内存管理</code>，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过c++11引入的<code>智能指针</code>来解决。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。</p><h2 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><strong>shared_ptr</strong></h3><p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p><ul><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li><li>每次创建类的新对象时，初始化指针并将引用计数置为1</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li><li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li></ul><p>使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClassWrapper</span> &#123;</span><br>    <span class="hljs-built_in">ClassWrapper</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct&quot;</span> &lt;&lt; endl;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    &#125;<br>    ~<span class="hljs-built_in">ClassWrapper</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;print&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">int</span>* data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(std::shared_ptr&lt;ClassWrapper&gt; ptr)</span> </span>&#123;<br>    ptr-&gt;<span class="hljs-built_in">Print</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> smart_ptr = std::make_shared&lt;ClassWrapper&gt;();<br>    <span class="hljs-keyword">auto</span> ptr2 = smart_ptr; <span class="hljs-comment">// 引用计数+1</span><br>    ptr2-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-built_in">Func</span>(smart_ptr); <span class="hljs-comment">// 引用计数+1</span><br>    smart_ptr-&gt;<span class="hljs-built_in">Print</span>();<br>    ClassWrapper *p = smart_ptr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 可以通过get获取裸指针</span><br>    p-&gt;<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">construct<br>print<br>print<br>print<br>print<br>deconstruct<br></code></pre></td></tr></table></figure><p>智能指针还可以自定义删除器，在引用计数为0的时候自动调用删除器来释放对象的内存，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>, [](<span class="hljs-keyword">int</span> *p)&#123; <span class="hljs-keyword">delete</span> p; &#125;)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>关于shared_ptr有几点需要注意：</strong></p><p>• 不要用一个裸指针初始化多个shared_ptr，会出现double_free导致程序崩溃</p><p>• 通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能会导致重复析构，不能把this指针交给智能指针管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">GetSelf</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>       <span class="hljs-comment">// return shared_ptr&lt;A&gt;(this); 错误，会导致double free</span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>尽量使用make_shared，少用new。</li><li>不要delete get()返回来的裸指针。</li><li>不是new出来的空间要自定义删除器。</li><li>要避免<code>循环引用</code>，循环引用导致内存永远不会被释放，造成内存泄漏。</li></ul><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   std::shared_ptr&lt;B&gt; bptr;<br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span><br>   std::shared_ptr&lt;A&gt; aptr;<br>   ~<span class="hljs-built_in">B</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;B delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> aaptr = std::make_shared&lt;A&gt;();<br>   <span class="hljs-keyword">auto</span> bbptr = std::make_shared&lt;B&gt;();<br>   aaptr-&gt;bptr = bbptr;<br>   bbptr-&gt;aptr = aaptr;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码，产生了循环引用，导致aptr和bptr的引用计数为2，离开作用域后aptr和bptr的引用计数-1，但是永远不会为0，导致指针永远不会析构，产生了内存泄漏，如何解决这种问题呢，答案是使用weak_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><strong>weak_ptr</strong></h3><p>weak_ptr是用来监视shared_ptr的生命周期，它不管理shared_ptr内部的指针，它的拷贝和析构都不会影响引用计数，纯粹是作为一个旁观者监视shared_ptr中管理的资源是否存在，可以用来返回this指针和解决循环引用问题。</p><ul><li>作用1：返回this指针，上面介绍的shared_from_this()其实就是通过weak_ptr返回的this指针；</li><li>作用2：解决循环引用问题。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   std::shared_ptr&lt;B&gt; bptr;<br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span><br>   std::weak_ptr&lt;A&gt; aptr; <span class="hljs-comment">// 这里改成weak_ptr</span><br>   ~<span class="hljs-built_in">B</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;B delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (!aptr.<span class="hljs-built_in">expired</span>()) &#123; <span class="hljs-comment">// 监视shared_ptr的生命周期</span><br>           <span class="hljs-keyword">auto</span> ptr = aptr.<span class="hljs-built_in">lock</span>();<br>           ptr-&gt;<span class="hljs-built_in">Print</span>();<br>      &#125;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> aaptr = std::make_shared&lt;A&gt;();<br>   <span class="hljs-keyword">auto</span> bbptr = std::make_shared&lt;B&gt;();<br>   aaptr-&gt;bptr = bbptr;<br>   bbptr-&gt;aptr = aaptr;<br>   bbptr-&gt;<span class="hljs-built_in">PrintA</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">delete</span><br><span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">delete</span><br></code></pre></td></tr></table></figure><p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><strong>unique_ptr</strong></h3><p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p><p>unique_ptr是一个独占型的智能指针，它不允许其它智能指针共享其内部指针，也不允许unique_ptr的拷贝和赋值。使用方法和shared_ptr类似，区别是不可以拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>   ~<span class="hljs-built_in">A</span>() &#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A delete&quot;</span> &lt;&lt; endl;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl;<br>   &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> ptr = std::unique_ptr&lt;A&gt;(<span class="hljs-keyword">new</span> A);<br>   <span class="hljs-keyword">auto</span> tptr = std::make_unique&lt;A&gt;(); <span class="hljs-comment">// error, c++11还不行，需要c++14</span><br>   std::unique_ptr&lt;A&gt; tem = ptr; <span class="hljs-comment">// error, unique_ptr不允许移动</span><br>   ptr-&gt;<span class="hljs-built_in">Print</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><strong>auto_ptr</strong></h3><p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p><p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p><p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p><ol><li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li><li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li><li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li><li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li><li>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li><li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li><li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li><li>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</li></ol><h2 id="手写实现智能指针类需要实现哪些函数？"><a href="#手写实现智能指针类需要实现哪些函数？" class="headerlink" title="手写实现智能指针类需要实现哪些函数？"></a>手写实现智能指针类需要实现哪些函数？</h2><ol><li><p>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</p><p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p><p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p></li><li><p>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[ 1 ] : c++11新特性之智能指针(<a href="https://mp.weixin.qq.com/s/Aujdxj3k_apNwW9Cnd3_eg">https://mp.weixin.qq.com/s/Aujdxj3k_apNwW9Cnd3_eg</a>)</p><p>[ 2 ] : 阿秀的学习笔记 (interviewguide.cn)(<a href="https://interviewguide.cn/#/Doc/Knowledge/C++/C++11%E6%96%B0%E6%A0%87%E5%87%86/C++11%E6%96%B0%E6%A0%87%E5%87%86">https://interviewguide.cn/#/Doc/Knowledge/C++/C++11新标准/C++11新标准</a>)</p><p>[ 3 ] : 搞定技术面试：C++ 11 智能指针详解 (juejin.cn)(<a href="https://juejin.cn/post/6844903993055920141#heading-16">https://juejin.cn/post/6844903993055920141#heading-16</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六、智能指针&quot;&gt;&lt;a href=&quot;#六、智能指针&quot; class=&quot;headerlink&quot; title=&quot;六、智能指针&quot;&gt;&lt;/a&gt;六、智能指针&lt;/h1&gt;&lt;p&gt;c++的&lt;code&gt;内存管理&lt;/code&gt;，不像java那样有虚拟机动态的管理内存，在程序运行过程中可能就会</summary>
      
    
    
    
    <category term="C++11 新特性" scheme="http://pakchoi007.gitee.io/categories/C-11-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="C++11" scheme="http://pakchoi007.gitee.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 21-25</title>
    <link href="http://pakchoi007.gitee.io/2021/06/15/%E5%89%91%E6%8C%87offer21-25/"/>
    <id>http://pakchoi007.gitee.io/2021/06/15/%E5%89%91%E6%8C%87offer21-25/</id>
    <published>2021-06-15T04:32:10.000Z</published>
    <updated>2021-06-15T07:21:01.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-21-25"><a href="#剑指offer-21-25" class="headerlink" title="剑指offer    21~25"></a>剑指offer    21~25</h1><h2 id="二十一、栈的压入、弹出序列"><a href="#二十一、栈的压入、弹出序列" class="headerlink" title="二十一、栈的压入、弹出序列"></a>二十一、<a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">栈的压入、弹出序列</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4,3,5,1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pushV,vector&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : pushV) &#123;<br>            st.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popV[i]) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>借助一个辅助栈</p><p><strong>算法流程：</strong></p><ol><li><p>初始化： 辅助栈 stack ，弹出序列的索引 $i$ ；</p></li><li><p>遍历压栈序列： 各元素记为 $num$ ；</p><ol><li><p>元素 $num$ 入栈；</p></li><li><p>循环出栈：若 stack 的栈顶元素 == 弹出序列元素 $popV[i]$ ，则执行出栈与 $i++$ ；</p></li></ol></li><li><p>返回值： 若 stack 为空，则此弹出序列合法。</p></li></ol><h2 id="二十二、从上往下打印二叉树"><a href="#二十二、从上往下打印二叉树" class="headerlink" title="二十二、从上往下打印二叉树"></a>二十二、<a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">从上往下打印二叉树</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,#,<span class="hljs-number">3</span>,#,<span class="hljs-number">2</span>,#,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;();<br>        queue&lt;TreeNode*&gt;q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        TreeNode *node = <span class="hljs-literal">nullptr</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            node = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>算法流程：</strong></p><ol><li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li><li>初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；</li><li>BFS 循环： 当队列 queue 为空时跳出；<ol><li>出队： 队首元素出队，记为 node；</li><li>打印： 将 node.val 添加至列表 res 尾部；</li><li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li></ol></li><li>返回值： 返回打印结果列表 res 即可。</li></ol><h2 id="☆☆二十三、二叉搜索树的后序遍历序列"><a href="#☆☆二十三、二叉搜索树的后序遍历序列" class="headerlink" title="☆☆二十三、二叉搜索树的后序遍历序列"></a>☆☆二十三、<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉搜索树的后序遍历序列</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">14</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; sequence, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> root = sequence[end];<span class="hljs-comment">//根节点</span><br>        <span class="hljs-keyword">int</span> pos = start;<br>        <span class="hljs-keyword">for</span> (; pos &lt; end; pos++) &#123;<br>            <span class="hljs-comment">//右子树全部大于根节点，找到第一个大于根节点的元素，那么在他之前都是左子树，之后都是右子树</span><br>            <span class="hljs-keyword">if</span>(sequence[pos] &gt; root) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = pos; j &lt; end; j++) &#123;<br>            <span class="hljs-keyword">if</span>(sequence[j] &lt; root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//右子树必须全部大于根，否则返回false</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(sequence, start, pos - <span class="hljs-number">1</span>) <span class="hljs-comment">//判断左子树</span><br>            &amp;&amp; <span class="hljs-built_in">recur</span>(sequence, pos, end - <span class="hljs-number">1</span>);<span class="hljs-comment">//判断右子树</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>递归解析：</strong></p><ul><li><p>终止条件： 当 $start \geq end$ ，说明此子树节点数量 $\leq 1$ ，无需判别正确性，因此直接返回 $true$ ；</p></li><li><p>递推工作：</p><ol><li><p>划分左右子树： 遍历后序遍历的 $[start, end]$ 区间元素，寻找第一个大于根节点的节点，索引记为 $pos$ 。此时，可划分出左子树区间 $[start,pos-1]$ 、右子树区间 $[pos, end - 1]$ 、根节点索引 $end$ 。</p></li><li><p>判断是否为二叉搜索树：</p><ul><li><p>左子树区间 $[start, pos - 1]$ 内的所有节点都应 $&lt;sequence[end]$ 。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</p></li><li><p>右子树区间 $[pos, end-1]$ 内的所有节点都应 $&gt; sequence[end]$ 。实现方式为遍历，当遇到 $\leq sequence[end]$ 的节点则返回 $false$ 。</p></li></ul></li></ol></li><li><p>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp; 连接。</p><ol><li>$recur(start, pos - 1)$ ： 判断 此树的左子树是否正确。</li><li>$recur(pos, end - 1)$ ： 判断 此树的右子树是否正确。</li></ol></li></ul><h2 id="二十四、二叉树中和为某一值的路径"><a href="#二十四、二叉树中和为某一值的路径" class="headerlink" title="二十四、二叉树中和为某一值的路径"></a>二十四、<a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树中和为某一值的路径</a></h2><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">10,5,12,4</span>,<span class="hljs-number">7</span>&#125;,<span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">10,5,12,4</span>,<span class="hljs-number">7</span>&#125;,<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;path;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;ret;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        target -= root-&gt;val;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            ret.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-built_in">backtracking</span>(root-&gt;left, target);<br>        <span class="hljs-built_in">backtracking</span>(root-&gt;right, target);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">FindPath</span>(TreeNode* root,<span class="hljs-keyword">int</span> expectNumber) &#123;<br>        path.<span class="hljs-built_in">clear</span>();<br>        ret.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(root, expectNumber);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析:</p></blockquote><p><strong>算法流程：</strong></p><p><strong>$FindPath(root, expectNumber)$ 函数：</strong></p><ul><li><p>初始化： 结果列表 $ret$ ，路径列表 $path$ 。</p></li><li><p>返回值： 返回 $ret$ 即可。</p></li></ul><p><strong>$backtracking(root, target)$ 函数：</strong></p><ul><li>递推参数： 当前节点 $root$ ，当前目标值 $target$ 。</li><li>终止条件： 若节点 $root$ 为空，则直接返回。</li><li>递推工作：<ol><li>路径更新： 将当前节点值 $root.val$ 加入路径 $path$ ；</li><li>目标值更新： $target = target - root.val$（即目标值 $target$ 从 $expectNumber$ 减至 0 ）；</li><li>路径记录： 当 ① $root$ 为叶节点 <strong>且</strong> ② 路径和等于目标值 ，则将此路径 $path$ 加入 $ret$ 。</li><li>先序遍历： 递归左 / 右子节点。</li><li>路径恢复： 向上回溯前，需要将当前节点从路径 $path$ 中删除，即执行 path.pop_back() 。</li></ol></li></ul><h2 id="二十五、复杂链表的复制"><a href="#二十五、复杂链表的复制" class="headerlink" title="二十五、复杂链表的复制"></a>二十五、<a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">复杂链表的复制</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p><img src="/2021/06/15/%E5%89%91%E6%8C%87offer21-25/e1.png" alt="img"></p><p>输入：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        RandomListNode* node = pHead;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            RandomListNode* clonenode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(node-&gt;label);<br>            clonenode-&gt;next = node-&gt;next;<br>            node-&gt;next = clonenode;<br>            node = clonenode-&gt;next;<br>        &#125;<br>        node = pHead;<br>        RandomListNode* clonehead = node-&gt;next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;random != <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;next-&gt;random = node-&gt;random-&gt;next;<br>            &#125;<br>            node = node-&gt;next-&gt;next;<br>        &#125;<br>        node = pHead;<br>        RandomListNode* clonenode = clonehead;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node-&gt;next-&gt;next;<br>            node = node-&gt;next;<br>            <span class="hljs-keyword">if</span> (clonenode-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>                clonenode-&gt;next = clonenode-&gt;next-&gt;next;<br>                clonenode = clonenode-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> clonehead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>方法一：拼接 + 拆分</strong><br>考虑构建 <code>原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; ……</code> 的拼接链表，如此便可在访问原节点的 <code>random</code> 指向节点的同时找到新对应新节点的 <code>random</code> 指向节点。</p><p><strong>算法流程：</strong></p><ol><li><p>复制各节点，构建拼接链表:</p><ul><li>设原链表为 $node1 \rightarrow node2 \rightarrow \cdots$ ，构建的拼接链表如下所示：<br>$<br>node1 \rightarrow node1_{clone} \rightarrow node2 \rightarrow node2_{clone} \rightarrow \cdots<br>$</li></ul></li><li><p>构建新链表各节点的 <code>random</code> 指向：</p><ul><li>当访问原节点 <code>node</code> 的随机指向节点 <code>node.random</code> 时，对应新节点 <code>node.next</code> 的随机指向节点为 <code>node.random.next</code> 。</li></ul></li><li><p>拆分原 / 新链表：</p><ul><li>设置 <code>node</code> / <code>clonenode</code> 分别指向原 / 新链表头节点，遍历执行 <code>node.next = node.next.next</code> 和 <code>clonenode.next = clonenode.next.next</code> 将两链表拆分开。</li></ul></li><li><p>返回新链表的头节点 <code>clonehead</code> 即可。</p></li></ol><p>需要三次遍历链表</p><p><strong>方法二：哈希表</strong></p><p>利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。</p><p><strong>算法流程：</strong></p><ol><li>若头节点 head 为空节点，直接返回 null ；</li><li>初始化： 哈希表 dic ， 节点 cur 指向头节点；</li><li>复制链表：<ol><li>建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li>构建新链表的引用指向：<ol><li>构建新节点的 next 和 random 引用指向；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li>返回值： 新链表的头节点 dic[head] ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        unordered_map&lt;RandomListNode*, RandomListNode*&gt;dic;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        RandomListNode* cur = pHead;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            dic[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur = pHead;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            dic[cur]-&gt;next = dic[cur-&gt;next];<br>            dic[cur]-&gt;random = dic[cur-&gt;random];<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dic[pHead];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-21-25&quot;&gt;&lt;a href=&quot;#剑指offer-21-25&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    21~25&quot;&gt;&lt;/a&gt;剑指offer    21~25&lt;/h1&gt;&lt;h2 id=&quot;二十一、栈的压入、弹出序列&quot;&gt;</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 16-20</title>
    <link href="http://pakchoi007.gitee.io/2021/06/12/%E5%89%91%E6%8C%87offer16-20/"/>
    <id>http://pakchoi007.gitee.io/2021/06/12/%E5%89%91%E6%8C%87offer16-20/</id>
    <published>2021-06-12T13:32:10.000Z</published>
    <updated>2021-06-12T13:43:09.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-16-20"><a href="#剑指offer-16-20" class="headerlink" title="剑指offer    16~20"></a>剑指offer    16~20</h1><h2 id="十六、合并两个排序的链表"><a href="#十六、合并两个排序的链表" class="headerlink" title="十六、合并两个排序的链表"></a>十六、<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&&tqId=11169&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">合并两个排序的链表</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1,3,5&#125;</span><span class="xml">,</span><span class="hljs-template-variable">&#123;2,4,6&#125;</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span> (pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead1;<br>        ListNode* node;<br>        <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>            node = pHead1;<br>            pHead1 = pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            node = pHead2;<br>            pHead2 = pHead2-&gt;next;<br>        &#125;<br>        ListNode* cur = node;<br>        <span class="hljs-keyword">while</span>(pHead1 &amp;&amp; pHead2) &#123;<br>            <span class="hljs-keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>                cur-&gt;next = pHead1;<br>                pHead1 = pHead1-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = pHead2;<br>                pHead2 = pHead2-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        cur-&gt;next = (pHead1 ? pHead1:pHead2);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>先把最小的值放在头结点，之后循环比较 $pHead1$ 和 $pHead2$ ，小的放进链表。</p><p>注意每次放进链表后，$cur=cur-&gt;next$ </p><p>另一种递归版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span> (pHead2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pHead1;<br>        <span class="hljs-keyword">if</span> (pHead1-&gt;val &lt;= pHead2-&gt;val) &#123;<br>            pHead1-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1-&gt;next, pHead2);<br>            <span class="hljs-keyword">return</span> pHead1;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            pHead2-&gt;next = <span class="hljs-built_in">Merge</span>(pHead1, pHead2-&gt;next);<br>            <span class="hljs-keyword">return</span> pHead2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="☆十七、树的子结构"><a href="#☆十七、树的子结构" class="headerlink" title="☆十七、树的子结构"></a>☆十七、<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">树的子结构</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,#,<span class="hljs-number">9</span>,#,<span class="hljs-number">2</span>,#,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,#,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; <span class="hljs-built_in">recur</span>(pRoot1-&gt;right, pRoot2-&gt;right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span> || pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot1, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>recur</strong>(A, B) 函数：</p><ol><li>终止条件：<ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；<br>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li></ol><p><strong>HasSubtree</strong>(A, B) 函数：</p><ol><li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false；</li><li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol><li>以 节点 A 为根节点的子 包含树 B ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 HasSubtree(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 HasSubtree(A.right, B)；</li></ol></li></ol><h2 id="十八、二叉树的镜像"><a href="#十八、二叉树的镜像" class="headerlink" title="十八、二叉树的镜像"></a>十八、<a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">二叉树的镜像</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>比如：    </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> 源二叉树 <br>    <span class="hljs-number">8</span><br>   /  <span class="hljs-string">\</span><br>  <span class="hljs-number">6</span>   <span class="hljs-number">10</span><br> / <span class="hljs-string">\</span>  / <span class="hljs-string">\</span><br><span class="hljs-number">5</span>   <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">11</span><br> 镜像二叉树<br>    <span class="hljs-number">8</span><br>   /  <span class="hljs-string">\</span><br>  <span class="hljs-number">10</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span>  / <span class="hljs-string">\</span><br><span class="hljs-number">11</span>  <span class="hljs-number">9</span> <span class="hljs-number">7</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">11</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        stack&lt;TreeNode*&gt;s;<br>        s.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left) s.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) s.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>辅助栈（或队列）</strong></p><ul><li>利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点</li></ul><p>算法流程：</p><ol><li>特例处理： 当 root 为空时，直接返回 null ；</li><li>初始化： 栈（或队列），本文用栈，并加入根节点 root 。</li><li>循环交换： 当栈 stack 为空时跳出；</li><li>出栈： 记为 node ；</li><li>添加子节点： 将 node 左和右子节点入栈；</li><li>交换： 交换 node 的左 / 右子节点。</li><li>返回值： 返回根节点 root 。</li></ol><h2 id="十九、顺时针打印矩阵"><a href="#十九、顺时针打印矩阵" class="headerlink" title="十九、顺时针打印矩阵"></a>十九、<a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">顺时针打印矩阵</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<br>[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>],<br>[<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]]<br></code></pre></td></tr></table></figure><p>则依次打印出数字</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = left; j &lt;= right; j++)&#123;<br>                ret.<span class="hljs-built_in">push_back</span>(matrix[top][j]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top + <span class="hljs-number">1</span>; i &lt;= bottom; i++)&#123;<br>                ret.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = right - <span class="hljs-number">1</span>; j &gt; left; j--)&#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(matrix[bottom][j]);<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt; top; i--)&#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>                &#125;<br>            &#125;<br>            left++;<br>            right--;<br>            top++;<br>            bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>按层模拟</p><p>可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。</p><p>定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br> [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于 $(\textit{top}, \textit{left} )$，右下角位于$ (\textit{bottom}, \textit{right})$，按照如下顺序遍历当前层的元素。</p><ol><li>从左到右遍历上侧元素，依次为 $(\textit{top}, \textit{left})$到 $(\textit{top}, \textit{right})$。</li><li>从上到下遍历右侧元素，依次为 $(\textit{top} + 1, \textit{right})$到 $(\textit{bottom}, \textit{right})$。</li><li>如果 $\textit{left} &lt; \textit{right}$ 且 $\textit{top} &lt; \textit{bottom}$，则从右到左遍历下侧元素，依次为 $(\textit{bottom}, \textit{right} - 1)$ 到 $(\textit{bottom}, \textit{left} + 1)$，以及从下到上遍历左侧元素，依次为 $(\textit{bottom}, \textit{left})$ 到 $(\textit{top} + 1, \textit{left})$。</li></ol><p>遍历完当前层的元素之后，将 $\textit{left}$ 和 $\textit{top}$ 分别增加 1，将 $\textit{right}$ 和 $\textit{bottom}$ 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p><h2 id="二十、包含min函数的栈"><a href="#二十、包含min函数的栈" class="headerlink" title="二十、包含min函数的栈"></a>二十、<a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">包含min函数的栈</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为$O(1)$ ）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; minst;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        st.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(minst.<span class="hljs-built_in">empty</span>()) minst.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> minst.<span class="hljs-built_in">push</span>(value &lt; minst.<span class="hljs-built_in">top</span>() ? value : minst.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        minst.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minst.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p><strong>解题思路：</strong></p><p>普通栈的 push() 和 pop() 函数的复杂度为 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) </p><p><strong>本题难点：</strong> 将 min() 函数复杂度降为 O(1) ，可通过建立<code>辅助栈</code>实现；</p><ul><li><p>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。</p></li><li><p>辅助栈 B ： 栈 B 中存储栈 A 中所有非严格降序的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</p></li></ul><p>因此，只需设法维护好栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1) 复杂度。</p><p><strong>函数设计：</strong></p><p>push(value) 函数： 重点为保持栈 B 的元素是非严格降序的。</p><ol><li><p>将 value 压入栈 A （即 A.push(value) ）；</p></li><li><p>① 若栈 B 为空，说明是第一个元素，直接将 value 压入栈 B （即 B.push(value) ）</p><p>② value 与 栈 B 的栈顶元素比较，则将 小的那个 压入栈 B （即 B.push(value &lt; B.top() ? value : B.top())）。</p></li></ol><p>pop() 函数： 重点为保持栈 A, B 的元素一致性 。</p><ol><li>执行栈 A 出栈（即 A.pop()）；</li><li>执行栈 B 出栈（即 B.pop()）。</li></ol><p>top() 函数： 直接返回栈 A 的栈顶元素即可，即返回 A.top() 。</p><p>min() 函数： 直接返回栈 B 的栈顶元素即可，即返回 B.top() 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-16-20&quot;&gt;&lt;a href=&quot;#剑指offer-16-20&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    16~20&quot;&gt;&lt;/a&gt;剑指offer    16~20&lt;/h1&gt;&lt;h2 id=&quot;十六、合并两个排序的链表&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 11-15</title>
    <link href="http://pakchoi007.gitee.io/2021/06/10/%E5%89%91%E6%8C%87offer11-15/"/>
    <id>http://pakchoi007.gitee.io/2021/06/10/%E5%89%91%E6%8C%87offer11-15/</id>
    <published>2021-06-10T10:23:10.000Z</published>
    <updated>2021-06-10T10:31:04.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-11-15"><a href="#剑指offer-11-15" class="headerlink" title="剑指offer    11~15"></a>剑指offer    11~15</h1><h2 id="十一、二进制中1的个数"><a href="#十一、二进制中1的个数" class="headerlink" title="十一、二进制中1的个数"></a>十一、<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二进制中1的个数</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">10<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>         <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>             n= (n &amp; n - <span class="hljs-number">1</span>);<br>             res++;<br>         &#125;<br>         <span class="hljs-keyword">return</span> res;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>一刷在LeetCode上，给的格式是uint32_t。当时写的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n) &#123;<br>ret += (n &amp; <span class="hljs-number">1</span>);<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当时想法是循环取 $n$ 的最后一位，是 $1$ 就 $ret$ 加一。</p><p>二刷牛客网给的类型是 int</p><p>思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有高位将不会受到影响。</p><p><strong>举个例子</strong>：一个二进制数 $1100$，从左边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是 $1011$ 。我们发现减1的结果是把最右边的一个1开始的所有位都取反了。</p><p>这个时候如果我们再把原来的整数和减去1之后的结果做&amp;运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100 &amp; 1011 = 1000 。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><h2 id="十二、数值的整数次方"><a href="#十二、数值的整数次方" class="headerlink" title="十二、数值的整数次方"></a>十二、<a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">数值的整数次方</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。</p><p>保证 base 和 exponent 不同时为 0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面 0 的位数。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00000</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>.<span class="hljs-number">00000</span><br></code></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">10000</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">9</span>.<span class="hljs-number">26100</span><br></code></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p>输入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">00000</span>,-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">25000</span><br></code></pre></td></tr></table></figure><p>说明：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>的-<span class="hljs-number">2</span>次方等于<span class="hljs-number">1</span>/<span class="hljs-number">4</span>=<span class="hljs-number">0</span>.<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>) &#123;<br>            base = <span class="hljs-number">1</span> / base;<br>            exponent = - exponent;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(exponent &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(exponent &amp; <span class="hljs-number">1</span>)&#123;<br>                res *= base;<br>            &#125;<br>            base *= base;<br>            exponent &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>快速幂算法</p><p>快速幂实际上是二分思想的一种应用。</p><ul><li><p>二分推导： $x^n = x^{n/2} \times x^{n/2} = (x^2)^{n/2}$ ，令 $n/2$ 为整数，则需要分为奇偶两种情况（设向下取整除法符号为 “//“ ）：</p><ul><li>当 $n$ 为偶数： $x^n = (x^2)^{n//2}$ ；</li><li>当 $n$ 为奇数： $x^n = x(x^2)^{n//2}$ ，即会多出一项 $x$ ；</li></ul></li><li><p>幂结果获取：</p><ul><li>根据二分推导，可通过循环 $x = x^2$ 操作，每次把幂从 $n$ 降至 $n//2$ ，直至将幂降为 $0$ ；</li><li>设 $res=1$ ，则初始状态 $x^n = x^n \times res$x 。在循环二分时，每当 $n$ 为奇数时，将多出的一项 $x$ 乘入 $res$ ，则最终可化至 $x^n = x^0 \times res = res$ ，返回 $res$ 即可。</li></ul></li></ul><p><img src="/2021/06/10/%E5%89%91%E6%8C%87offer11-15/1.png" alt="Picture2.png"></p><ul><li><p>转化为位运算：</p><ul><li><p>向下整除 $n // 2$ 等价于右移一位 $n &gt;&gt; 1$ ；</p></li><li><p>取余数 $n % 2$ 等价于判断二进制最右一位值 n &amp; 1​；</p></li></ul></li></ul><p><code>算法流程：</code></p><ol><li>当 $x = 0$ 时：直接返回 $0$ （避免后续 $x = 1 / x$ 操作报错）。</li><li>初始化 $res = 1$ ；</li><li>当 $n &lt; 0$ 时：把问题转化至 $n \geq 0$ 的范围内，即执行 $x = 1/x$，$n = - n$ ；</li><li>循环计算：当 $n = 0$ 时跳出；<ol><li>当 n &amp; 1 = 1 时：将当前 $x$ 乘入 $res$ （即 $res *= x$ ）；</li><li>执行 $x = x^2$（即 $x *= x$ ）；</li><li>执行 $n$ 右移一位（即 $n &gt;&gt;= 1$）。</li></ol></li><li>返回 $res$ 。</li></ol><p><code>复杂度分析：</code></p><p>时间复杂度 $O(log_2 n)$ ：二分的时间复杂度为对数级别。</p><p>空间复杂度 $O(1)$ ：$ res$ 变量占用常数大小额外空间。</p><p>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></p><h2 id="☆十三、调整数组顺序使奇数位于偶数前面"><a href="#☆十三、调整数组顺序使奇数位于偶数前面" class="headerlink" title="☆十三、调整数组顺序使奇数位于偶数前面"></a>☆十三、<a href="https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">调整数组顺序使奇数位于偶数前面</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = array.<span class="hljs-built_in">size</span>(),evenIndex = <span class="hljs-number">0</span>,oddIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> array;        <br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ( (array[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)  array[oddIndex++] = array[i];<br>            <span class="hljs-keyword">else</span>&#123;<br>                temp[evenIndex++] = array[i];<span class="hljs-comment">//将偶数另外保存起来</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; evenIndex; ++j) &#123;<br>            array[j + oddIndex] = temp[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>开辟一个新的数组空间 $temp$，从前往后遍历数组 $array$ ,遇到偶数就存到 $temp$ 里，最后将 $temp$ 接在 $array$ 之后</p><ul><li>下面是另一种方法（在牛客上超时）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> array;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len - <span class="hljs-number">1</span>; j &gt; i; --j) &#123;<br>                <span class="hljs-keyword">if</span> ( (array[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; (array[j - <span class="hljs-number">1</span>] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">swap</span>(array[j], array[j - <span class="hljs-number">1</span>]);    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从后向前进行修正，类似于冒泡法。遇到先偶后奇的情况时，就交换。把奇数放到前面去，空间复杂度为$O(1)$ 。不知道为什么超时，可能是时间复杂度 $O(n^2)$ 的缘故</p><ul><li>LeetCode上没有保证奇数和奇数，偶数和偶数之间的相对位置不变的条件，一刷的时候使用了<code>双指针</code>的写法，代码如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//双指针</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">if</span> ((nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>left++;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> ((nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>right--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>left++;<br>right--;<br>&#125;<br><span class="hljs-keyword">return</span> nums;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="十四、链表中倒数最后-k-个结点"><a href="#十四、链表中倒数最后-k-个结点" class="headerlink" title="十四、链表中倒数最后 $k$ 个结点"></a>十四、<a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">链表中倒数最后 $k$ 个结点</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表，输出一个链表，该输出链表包含原链表中从倒数第 $k$ 个结点至尾节点的全部节点。</p><p>如果该链表长度小于 $k$，请返回一个长度为 0 的链表。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">&#123;<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>&#125;,<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = pHead;<br>        <span class="hljs-keyword">while</span>(k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(pHead != <span class="hljs-literal">nullptr</span>) pHead = pHead-&gt;next;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            pHead = pHead-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>快慢指针</p><p>先定义慢指针 $slow$ ，先让 $pHead$ 走 $k$ 步，再让 $slow$ 与 $pHead$ 同时走，当 $pHead$ 走到 $nullptr$ 时，$slow$ 正好走到倒数 $k$个结点</p><p>另一种方法，先计算链表长度 $num$ , $pHead$ 只要走 $num-k$ 步就行。代码如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* cur = pHead;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>num++;<br>cur = cur-&gt;next;<br>&#125;<br>        <span class="hljs-keyword">if</span>(k &gt; num)<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>cur = pHead;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num - k; i++) &#123;<br>cur = cur-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="☆☆☆十五、反转链表"><a href="#☆☆☆十五、反转链表" class="headerlink" title="☆☆☆十五、反转链表"></a>☆☆☆十五、<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">反转链表</a></h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><h3 id="示例1-4"><a href="#示例1-4" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = pHead;<br>        ListNode* tmp;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            tmp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>借助三个结点进行不断更替</p><p>$cur$ 为当前指针， $pre$ 为当前指针的前一指针， $tmp$ 为当前指针的后一指针</p><ol><li><code>pre</code>置为<code>nullptr</code>，它将作为链表的尾结点向前推进处理，<code>cur</code>指向旧链表的头指针<code>head</code>，<code>tmp</code>指向旧链表的头指针的<code>next</code>结点。</li><li>开始遍历链表，循环判定因子为<code>cur</code>，当它为空时到达链表尾部跳出循环。否则在表中执行循环内逻辑：将<code>cur</code>指向<code>pre</code>，即前一个结点。此时<code>pre</code>为<code>nullptr</code>，那么<code>cur</code>的下一个结点就为空了，它现在是最后一个结点。</li><li>然后将<code>pre</code>指针指向<code>cur</code>，将<code>cur</code>指针指向<code>tmp</code>，注意这两步不可以调换顺序，否则不能向后挪移一位。此时完成了三个指针的一轮更迭。</li><li>判定<code>cur</code>指针是否为空，如果为空说明此时<code>cur</code>到达了链表结尾。如果不为空，将<code>cur</code>更新到下一个结点，进行下一次循环。</li><li>下一次进行循环时，就会把截断结点链接到新链表的头部，同时更新三个指针。继续循环。</li><li>循环终止条件为：<code>cur</code>指向了链表尾部的<code>nullptr</code>，此时<code>cur</code>的前指针<code>pre</code>即指向了反转后的链表，它就是新链表的<code>head</code>头指针。此时返回<code>pre</code>即可。</li></ol><blockquote><p>另一种方法：头插法</p></blockquote><p>先对原链表做头删操作，再对新链表做头插</p><ol><li><p>定义一个新<code>head</code>头指针，标记为<code>newHead</code>，将它初始为<code>NULL</code>，并非指向<code>NULL</code>，最后我们选择返回这个<code>newHead</code>指针作为新链表的头指针。</p></li><li><p>定义一个结点<code>node</code>作为”临时中转站”，初始化与否并无大影响。</p></li><li><p>进行循环遍历链表各个结点，判定<code>head</code>指针是否为空，即是否到达了原链表的结尾。如果不为空，说明还没有到达尾部。如果程序第一次运行就没有进入循环，说明传入了一个空链表，此时返回<code>newHead</code>新链表的头指针，同样返回<code>NULL</code>，这样处理也是合理的。</p></li><li><p>以下开始逆序链表逻辑：在当前指针不为<code>NULL</code>时，先对原链表做头删操作，再对新链表做头插操作。即使用循环进行操作</p></li><li><p>让<code>node</code>指针指向传入函数链表的头指针<code>head</code>，两指针指向保持相同。</p></li><li><p>然后让<code>head</code>指针指向它的<code>next</code>结点，此时旧链表已经完成了头删操作。第一个结点已经被”切割”下来。接下来要做的就是对新链表进行头插操作，使结点放入新链表。</p></li><li><p>让<code>node</code>指针的<code>next</code>下一个结点指向新链表的头指针<code>newHead</code>，完成结点的链接，即头插入新的链表中。然后更新<code>newHead</code>指向为新链表的头结点。进行下一次循环。</p></li><li><p>最终<code>head</code>指针指向了原链表的结尾，即为<code>NULL</code>，退出循环，此时新链表已经反转完毕</p></li><li><p>最终返回新链表头指针<code>newHead</code>即可。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode* newhead = <span class="hljs-literal">nullptr</span>;<br>        ListNode* node;<br>        <span class="hljs-keyword">while</span>(pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            node = pHead;<br>            pHead = pHead-&gt;next;<br>            node-&gt;next = newhead;<br>            newhead = node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newhead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-11-15&quot;&gt;&lt;a href=&quot;#剑指offer-11-15&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    11~15&quot;&gt;&lt;/a&gt;剑指offer    11~15&lt;/h1&gt;&lt;h2 id=&quot;十一、二进制中1的个数&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 6-10</title>
    <link href="http://pakchoi007.gitee.io/2021/06/09/%E5%89%91%E6%8C%87offer6-10/"/>
    <id>http://pakchoi007.gitee.io/2021/06/09/%E5%89%91%E6%8C%87offer6-10/</id>
    <published>2021-06-09T10:23:10.000Z</published>
    <updated>2021-06-09T11:12:20.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer-6-10"><a href="#剑指offer-6-10" class="headerlink" title="剑指offer    6~10"></a>剑指offer    6~10</h1><h2 id="六、旋转数组的最小数字"><a href="#六、旋转数组的最小数字" class="headerlink" title="六、旋转数组的最小数字"></a>六、<a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">旋转数组的最小数字</a></h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; rotateArray)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = rotateArray.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-keyword">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(rotateArray[pivot] &lt; rotateArray[high]) high = pivot;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotateArray[pivot] &gt; rotateArray[high]) low = pivot + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> high = high - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rotateArray[low];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/1.png"></p><p>考虑数组中的最后一个元素 $x$：在最小值右侧的元素，它们的值一定都小于等于 $x$；而在最小值左侧的元素，它们的值一定都大于等于 $x$。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p><p>我们将中轴元素 $rotateArray[pivot]$ 与右边界元素 $rotateArray[high]$ 进行比较，可能会有以下的三种情况：</p><p><code>第一种情况</code>是 $rotateArray[pivot]$ &lt; $rotateArray[high]$ 。如下图所示，这说明$rotateArray[pivot]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/2.png"></p><p><code>第二种情况</code>是  $rotateArray[pivot]$ &gt; $rotateArray[high]$ 。如下图所示，这说明 $rotateArray[pivot]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/3.png"></p><p><code>第三种情况</code>是  $rotateArray[pivot]$ == $rotateArray[high]$。如下图所示，由于重复元素的存在，我们并不能确定 $rotateArray[pivot]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论 $rotateArray[high]$ 是不是最小值，都有一个它的「替代品」$rotateArray[high]$，因此我们可以忽略二分查找区间的右端点。</p><p>![](剑指offer 6-10/4.png)</p><p>当二分查找结束时，我们就得到了最小值所在的位置。</p><h2 id="七、斐波那契数列"><a href="#七、斐波那契数列" class="headerlink" title="七、斐波那契数列"></a>七、<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">斐波那契数列</a></h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p><p><em>n</em> ≤ 39</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">1</span>, num2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">3</span>)&#123;<br>            sum = num1 + num2;<br>            num1 = num2;<br>            num2 = sum;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>用三个变量存储中间值</p><p>斐波那契数列为 1,1,2,3,5,8,13……</p><p>$num1$ 为第一个数，$num2$ 为第二个数，$sum$ 为两数相加。之后把 $num1$ 更新为 $num2$，把 $num2$ 更新为 $sum$</p><p>递归做法容易超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="八、跳台阶"><a href="#八、跳台阶" class="headerlink" title="八、跳台阶"></a>八、<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1">跳台阶</a></h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// n-2跳法</span><br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">1</span>;<span class="hljs-comment">// n-1跳法</span><br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<span class="hljs-comment">// n 跳法</span><br>        <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span> || number == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> number;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>; i &lt;= number; i++)&#123;<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>总体思路跟斐波那契数列一致</p><p>下面是dp算法的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//dp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(number + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="九、变态跳台阶"><a href="#九、变态跳台阶" class="headerlink" title="九、变态跳台阶"></a>九、<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tags=&title=&difficulty=0&judgeStatus=0&rp=1(https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)">变态跳台阶</a></h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1"></a>示例1</h3><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">3<br></code></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">jumpFloorII</span>(number - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (number == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>,a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= number; i++)&#123;<br>            count = a * <span class="hljs-number">2</span>;<br>            a = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>设 $f[i]$ 表示当前跳到第 $i$ 个台阶的方法数。那么$f[n]$就是所求答案。</p><p>假设现在已经跳到了第 $n$ 个台阶，那么前一步可以从哪些台阶到达呢？</p><p>如果上一步跳 1 步到达第 $n$ 个台阶，说明上一步在第 $n-1$ 个台阶。已知跳到第 $n-1$ 个台阶的方法数为 $f[n-1]$</p><p>如果上一步跳 2 步到达第 $n$ 个台阶，说明上一步在第 $n-2$ 个台阶。已知跳到第 $n-2$ 个台阶的方法数为 $f[n-2]$</p><p>。。。</p><p>如果上一步跳 $n$ 步到达第 $n$ 个台阶，说明上一步在第 0 个台阶。已知跳到第0个台阶的方法数为 $f[0]$</p><p>那么总的方法数就是所有可能的和。也就是 $f[n] = f[n-1] + f[n-2] + … + f[0]$</p><p>显然初始条件 $f[0] = f[1] = 1$</p><p>所以我们就可以先求 $f[2]$，然后 $f[3]…f[n-1]$， 最后 $f[n]$</p><p>由：$f[n-1] = f[n-2] + f[n-3] + … + f[0]$</p><p>得到 $f[n] = 2*f[n-1]$</p><p>可以采用递归，记忆化递归，动态规划，递推。</p><h2 id="十、矩形覆盖"><a href="#十、矩形覆盖" class="headerlink" title="十、矩形覆盖"></a>十、<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩形覆盖</a></h2><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，从同一个方向看总共有多少种不同的方法？</p><p>比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)：</p><p><img src="/2021/06/09/%E5%89%91%E6%8C%87offer6-10/5.jpg"></p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>2*1的小矩形的总个数n</p><h3 id="返回值描述："><a href="#返回值描述：" class="headerlink" title="返回值描述："></a>返回值描述：</h3><p>覆盖一个2*n的大矩形总共有多少种不同的方法(从同一个方向看)</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> rectCover(<span class="hljs-built_in">int</span> <span class="hljs-keyword">number</span>) &#123;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">number</span> == <span class="hljs-number">1</span> || <span class="hljs-keyword">number</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">number</span>;<br>        &#125;<br>        for (<span class="hljs-built_in">int</span> i =<span class="hljs-number">2</span>; i &lt;= <span class="hljs-keyword">number</span>; i++)&#123;<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>分析：</p></blockquote><p>实际上就是斐波那契数列的变种</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;剑指offer-6-10&quot;&gt;&lt;a href=&quot;#剑指offer-6-10&quot; class=&quot;headerlink&quot; title=&quot;剑指offer    6~10&quot;&gt;&lt;/a&gt;剑指offer    6~10&lt;/h1&gt;&lt;h2 id=&quot;六、旋转数组的最小数字&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="笔试练习" scheme="http://pakchoi007.gitee.io/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="剑指offer" scheme="http://pakchoi007.gitee.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
